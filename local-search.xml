<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Linux网络编程</title>
    <link href="/2023/06/03/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <url>/2023/06/03/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux网络编程"><a href="#Linux网络编程" class="headerlink" title="Linux网络编程"></a>Linux网络编程</h1><h2 id="基础API"><a href="#基础API" class="headerlink" title="基础API"></a>基础API</h2><h3 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h3><p>字节序就是字节在内存中排列方式，现代PC中大多小端序，<strong>主机字节序</strong>。</p><p>网络中，以大端序作为基准，因此被称为 <strong>网络字节序</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜netinet/in.h＞ </span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-title function_">htonl</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> hostlong)</span>; <br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> <span class="hljs-title function_">htons</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> hostshort)</span>; <br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ntohl</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> netlong)</span>; <br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ntohs</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> netshort)</span>;<br></code></pre></td></tr></table></figure><p>host to network long，用于转换IP地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">192</span>,<span class="hljs-number">168</span>,<span class="hljs-number">100</span>,<span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-type">int</span> num = *(<span class="hljs-type">int</span>*)buf;<br>    <span class="hljs-type">int</span> ret = htonl(num);<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *p = (<span class="hljs-type">char</span>*) &amp;ret;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d,%d,%d,%d\n&quot;</span>,*p,*(p+<span class="hljs-number">1</span>),*(p+<span class="hljs-number">2</span>),*(p+<span class="hljs-number">3</span>));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="通用socket地址（不用）"><a href="#通用socket地址（不用）" class="headerlink" title="通用socket地址（不用）"></a>通用socket地址（不用）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/socket.h&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr</span> &#123;</span><br>    <span class="hljs-type">sa_family_t</span> sa_family; <span class="hljs-comment">//地址族类型 AF_INET ipv4 AF_UNIX</span><br>    <span class="hljs-type">char</span> sa_data[<span class="hljs-number">14</span>];<br>&#125;<br><span class="hljs-comment">// 新定义的</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_storage</span></span><br><span class="hljs-class">  &#123;</span><br>    __SOCKADDR_COMMON (ss_);<span class="hljs-comment">/* Address family, etc.  */</span><br>    <span class="hljs-type">char</span> __ss_padding[_SS_PADSIZE];<br>    __ss_aligntype __ss_align;<span class="hljs-comment">/* Force desired alignment.  */</span><br>  &#125;;<br></code></pre></td></tr></table></figure><p><strong>编程中基本上不用这个，会用专用的socket地址</strong></p><h3 id="专用scoket地址"><a href="#专用scoket地址" class="headerlink" title="专用scoket地址"></a>专用scoket地址</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> &#123;</span><br>  <span class="hljs-type">sa_family_t</span> sin_family;<span class="hljs-comment">/*地址族：AF_INET*/</span><br>  <span class="hljs-type">in_port_t</span> sin_port;<span class="hljs-comment">/*端口号，要用网络字节序表示*/</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span> <span class="hljs-title">sin_addr</span>;</span><span class="hljs-comment">/*IPv4地址结构体，见下面*/</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span> &#123;</span> <span class="hljs-type">u_int32_t</span> s_addr;<span class="hljs-comment">/*IPv4地址，要用网络字节序表示*/</span> &#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">uint16_t</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-type">uint32_t</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">uint16_t</span> <span class="hljs-type">in_port_t</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">uint32_t</span> <span class="hljs-type">in_addr_t</span>;<br></code></pre></td></tr></table></figure><p>所有专用 socket 地址（以及 sockaddr_storage）类型的变量在实际使用时都需要转化为通用socket地址类型 sockaddr（强制转化即可），因为所有 socket 编程接口使用的地址参数类型都是sockaddr。</p><h3 id="IP地址转换"><a href="#IP地址转换" class="headerlink" title="IP地址转换"></a>IP地址转换</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span> </span><br><span class="hljs-comment">// p:点分十进制的IP字符串，n:表示network，网络字节序的整数 </span><br> <span class="hljs-type">int</span> <span class="hljs-title function_">inet_pton</span><span class="hljs-params">(<span class="hljs-type">int</span> af, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *src, <span class="hljs-type">void</span> *dst)</span>;<br>af:地址族： AF_INET AF_INET6 <br>src:需要转换的点分十进制的IP字符串 <br>dst:转换后的结果保存在这个里面<br><br><span class="hljs-comment">// 将网络字节序的整数，转换成点分十进制的IP地址字符串 </span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title function_">inet_ntop</span><span class="hljs-params">(<span class="hljs-type">int</span> af, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *src, <span class="hljs-type">char</span> *dst, <span class="hljs-type">socklen_t</span> size)</span>; <br>af:地址族： AF_INET AF_INET6 <br>src: 要转换的ip的整数的地址 <br>dst: 转换成IP地址字符串保存的地方 <br>size：第三个参数的大小（数组的大小） <br>返回值：返回转换后的数据的地址（字符串），和 dst 是一样的<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">//创建一个ipv4的socket</span><br>    <span class="hljs-type">char</span> buf[] = <span class="hljs-string">&quot;192.168.1.1&quot;</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> num=<span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//将点分十进制的IP字符串转换为网络字节序的整数</span><br>    inet_pton(AF_INET,buf,&amp;num);<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>* p = (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*)&amp;num;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d.%d.%d.%d\n&quot;</span>,p[<span class="hljs-number">0</span>],p[<span class="hljs-number">1</span>],p[<span class="hljs-number">2</span>],p[<span class="hljs-number">3</span>]);<br>  <span class="hljs-comment">//将一个整数转换成点分十进制的ip地址</span><br>    <span class="hljs-type">char</span> ip[<span class="hljs-number">16</span>]=<span class="hljs-string">&quot;&quot;</span>;<br>    inet_ntop(AF_INET,&amp;num,ip,<span class="hljs-keyword">sizeof</span>(ip));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,ip);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br></code></pre></td></tr></table></figure><h3 id="TCP通信流程"><a href="#TCP通信流程" class="headerlink" title="TCP通信流程"></a>TCP通信流程</h3><h4 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h4><ol><li>创建监听的套接字（fd文件描述符）</li><li>将监听的fd和本地的IP和端口绑定</li><li>设置监听</li><li>阻塞等待，当有客户端发起连接时，接触阻塞，接受连接，得到一个和客户端通信的套接字<ul><li>accept()函数是阻塞的</li><li>这里的文件描述符是新建的，不是用于监听的那个fd</li></ul></li><li>通信，收发数据</li><li>通信结束，断开连接</li></ol><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><ol><li>创建用于通信的套接字</li><li>连接服务器，需要指定IP和port</li><li>通信</li><li>断开连接</li></ol><h3 id="scoket函数"><a href="#scoket函数" class="headerlink" title="scoket函数"></a>scoket函数</h3><p>看书和PPT</p><h3 id="TCP通信实现"><a href="#TCP通信实现" class="headerlink" title="TCP通信实现"></a>TCP通信实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">// 创建一个ipv4的socket</span><br>    <span class="hljs-type">int</span> cfd = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 连接服务器</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">serv</span>;</span><br>    <span class="hljs-built_in">memset</span>(&amp;serv.sin_addr.s_addr, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(serv.sin_addr.s_addr));<br>    serv.sin_family = AF_INET;<br>    inet_pton(AF_INET, <span class="hljs-string">&quot;127.0.0.101&quot;</span>, &amp;serv.sin_addr.s_addr);<br>    serv.sin_port = htons(<span class="hljs-number">8686</span>);<br>    <span class="hljs-type">int</span> ret = connect(cfd,(<span class="hljs-keyword">struct</span> sockaddr*)&amp;serv,<span class="hljs-keyword">sizeof</span>(serv));<br>    <span class="hljs-keyword">if</span>(ret==<span class="hljs-number">-1</span>)&#123;<br>        perror(<span class="hljs-string">&quot;connect error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br>    <span class="hljs-comment">// 通信</span><br>    <span class="hljs-type">char</span> *sendbuf=<span class="hljs-string">&quot;fuck you&quot;</span>;<br>    <span class="hljs-type">char</span> recvbuf[<span class="hljs-number">1024</span>] =&#123;<span class="hljs-number">0</span>&#125;;<br>    write(cfd,sendbuf,<span class="hljs-built_in">strlen</span>(sendbuf));<br>    <span class="hljs-type">int</span> len = read(cfd,recvbuf,<span class="hljs-keyword">sizeof</span>(recvbuf));<br>    <span class="hljs-keyword">if</span>(len==<span class="hljs-number">-1</span>)&#123;<br>        perror(<span class="hljs-string">&quot;read&quot;</span>);<br>        close(cfd);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(len&gt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;recv %s&quot;</span>,recvbuf);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(len==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;close&quot;</span>);<br>    &#125;<br>    close(cfd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 创建一个ipv4的socket</span><br>    <span class="hljs-type">int</span> lfd = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 绑定</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">serv</span>;</span><br>    <span class="hljs-built_in">memset</span>(&amp;serv.sin_addr.s_addr, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(serv.sin_addr.s_addr));<br>    serv.sin_family = AF_INET;<br>    inet_pton(AF_INET, <span class="hljs-string">&quot;127.0.0.101&quot;</span>, &amp;serv.sin_addr.s_addr);<br>    serv.sin_port = htons(<span class="hljs-number">8686</span>);<br>    <span class="hljs-type">int</span> ret = bind(lfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;serv, <span class="hljs-keyword">sizeof</span>(serv));<br>    assert(ret != <span class="hljs-number">-1</span>);<br>    <span class="hljs-comment">// 监听</span><br>    ret = listen(lfd, <span class="hljs-number">5</span>);<br>    assert(ret != <span class="hljs-number">-1</span>);<br>    <span class="hljs-comment">// 接受client</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">client</span>;</span><br>    <span class="hljs-type">socklen_t</span> len = <span class="hljs-keyword">sizeof</span>(client);<br>    <span class="hljs-type">int</span> cfd = accept(lfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;client, &amp;len);<br>    assert(cfd != <span class="hljs-number">-1</span>);<br>    <span class="hljs-comment">// 打印客户端信息</span><br>    <span class="hljs-type">char</span> client_addr[<span class="hljs-number">16</span>];<br>    inet_ntop(AF_INET, &amp;client.sin_addr.s_addr, client_addr, <span class="hljs-keyword">sizeof</span>(client_addr));<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> client_port = ntohs(client.sin_port);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;client ip %s , port %d&quot;</span>, client_addr, client_port);<br>    <span class="hljs-comment">// 通信</span><br>    <span class="hljs-type">char</span> recvbuf[<span class="hljs-number">1024</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span> length = read(cfd,recvbuf,<span class="hljs-keyword">sizeof</span>(recvbuf));<br>    <span class="hljs-keyword">if</span>(length==<span class="hljs-number">-1</span>)&#123;<br>        perror(<span class="hljs-string">&quot;read error&quot;</span>);<br>        close(cfd);<br>        close(lfd);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(length&gt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;recv buf:%s\n&quot;</span>,recvbuf);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(length==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;client close\n&quot;</span>);<br>        close(cfd);<br>        close(lfd);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-type">char</span>* data = <span class="hljs-string">&quot;hello world&quot;</span>;<br>    write(cfd,data,<span class="hljs-built_in">strlen</span>(data));<br>    <span class="hljs-comment">// 关闭</span><br>    close(cfd);<br>    close(lfd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="多进程实现并发服务器"><a href="#多进程实现并发服务器" class="headerlink" title="多进程实现并发服务器"></a>多进程实现并发服务器</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>一个父进程，多个子进程</li><li>父进程负责等待并接受客户端的连接</li><li>子进程：完成通信，接受到一个客户端连接，就创建一个子进程用于通信</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-comment">// 回收资源的回调，相当于一个软中断</span><br><span class="hljs-comment">// accpet阻塞的时候，如果有子进程退出，会触发回调函数，相当于一个软中断。回调函数执行完毕后，会返回到accpet的位置，继续向下执行，不再阻塞。那么就会导致accept返回-1，父进程退出，没办法处理新接入的客户端</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">recyleChild</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span><br>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-type">int</span> ret = waitpid(<span class="hljs-number">-1</span>, <span class="hljs-literal">NULL</span>, WNOHANG);<br>        <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>)<br>        &#123;<br>            <span class="hljs-comment">// 所有子进程都回收完毕</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-comment">// 还有子进程未回收完毕</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ret &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child died pid=%d\n&quot;</span>, ret);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 子进程退出信号</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigaction</span> <span class="hljs-title">act</span>;</span><br>    act.sa_flags = <span class="hljs-number">0</span>;<br>    sigemptyset(&amp;act.sa_mask);<br>    act.sa_handler = recyleChild;<br>    sigaction(SIGCHLD, &amp;act, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-comment">// 创建scoket</span><br>    <span class="hljs-type">int</span> lfd = socket(PF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (lfd == <span class="hljs-number">-1</span>)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;socket error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br>    <span class="hljs-comment">// 绑定</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">serv</span>;</span><br>    <span class="hljs-built_in">memset</span>(&amp;serv, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(serv));<br>    serv.sin_family = AF_INET;<br>    inet_pton(AF_INET, <span class="hljs-string">&quot;127.0.0.101&quot;</span>, &amp;serv.sin_addr.s_addr);<br>    serv.sin_port = htons(<span class="hljs-number">8686</span>);<br>    <span class="hljs-type">int</span> ret = bind(lfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;serv, <span class="hljs-keyword">sizeof</span>(serv));<br>    <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;bind error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br>    <span class="hljs-comment">// 监听</span><br>    ret = listen(lfd, <span class="hljs-number">5</span>);<br>    <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;listen error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br>    <span class="hljs-comment">// 循环</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-comment">// 接收连接</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">cliaddr</span>;</span><br>        <span class="hljs-type">socklen_t</span> len = <span class="hljs-keyword">sizeof</span>(cliaddr);<br>        <span class="hljs-type">int</span> cfd = accept(lfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;cliaddr, &amp;len);<br>        <span class="hljs-keyword">if</span> (cfd == <span class="hljs-number">-1</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (errno == EINTR)<br>            &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            perror(<span class="hljs-string">&quot;accept error&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>        &#125;<br>        <span class="hljs-type">pid_t</span> pid = fork();<br>        <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-type">char</span> cliIP[<span class="hljs-number">16</span>];<br>            inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr, cliIP, <span class="hljs-keyword">sizeof</span>(cliIP));<br>            <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> port = ntohs(cliaddr.sin_port);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;client IP:%s,port:%d\n&quot;</span>, cliIP, port);<br>            <span class="hljs-comment">// 通信</span><br>            <span class="hljs-type">char</span> recvBuf[<span class="hljs-number">1024</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>            &#123;<br>                <span class="hljs-type">int</span> len = read(cfd, recvBuf, <span class="hljs-keyword">sizeof</span>(recvBuf));<br>                <span class="hljs-keyword">if</span> (len == <span class="hljs-number">-1</span>)<br>                &#123;<br>                    perror(<span class="hljs-string">&quot;read error&quot;</span>);<br>                    <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (len &gt; <span class="hljs-number">0</span>)<br>                &#123;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;recv buf:%s\n&quot;</span>, recvBuf);<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;客户端已经断开连接\n&quot;</span>);<br>                    <span class="hljs-comment">// 当客户端关闭的时候，跳出循环，不进行下面的写数据操作</span><br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                write(cfd, recvBuf, <span class="hljs-built_in">strlen</span>(recvBuf) + <span class="hljs-number">1</span>);<br>            &#125;<br>            close(cfd);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;<br>    close(lfd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="多线程实现服务器"><a href="#多线程实现服务器" class="headerlink" title="多线程实现服务器"></a>多线程实现服务器</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sock_info_s</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> fd;<br>    <span class="hljs-type">pthread_t</span> tid;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">sockaddr</span>;</span><br>&#125;;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sock_info_s</span> <span class="hljs-title">sock_info_t</span>;</span><br><br><span class="hljs-type">sock_info_t</span> infos[<span class="hljs-number">128</span>];<br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">working</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-comment">// 子线程和客户端进行通信,可能需要cfd、客户端的信息、线程号</span><br>    <span class="hljs-type">char</span> client_ip[<span class="hljs-number">16</span>];<br>    <span class="hljs-type">sock_info_t</span> *client = (<span class="hljs-type">sock_info_t</span> *)arg;<br>    inet_ntop(AF_INET, &amp;(client-&gt;sockaddr.sin_addr.s_addr), client_ip, <span class="hljs-keyword">sizeof</span>(client_ip));<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> port = ntohs(client-&gt;sockaddr.sin_port);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;client IP:%s,port:%d\n&quot;</span>, client_ip, port);<br>    <span class="hljs-type">char</span> recv_buf[<span class="hljs-number">1024</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-type">int</span> len = read(client-&gt;fd, recv_buf, <span class="hljs-keyword">sizeof</span>(recv_buf));<br>        <span class="hljs-keyword">if</span> (len == <span class="hljs-number">-1</span>)<br>        &#123;<br>            perror(<span class="hljs-string">&quot;read error&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (len &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;recv buf:%s\n&quot;</span>, recv_buf);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;客户端已经断开连接\n&quot;</span>);<br>            <span class="hljs-comment">// 当客户端关闭的时候，跳出循环，不进行下面的写数据操作</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        write(client-&gt;fd, recv_buf, <span class="hljs-built_in">strlen</span>(recv_buf) + <span class="hljs-number">1</span>);<br>    &#125;<br>    close(client-&gt;fd);<br>    pthread_exit(<span class="hljs-literal">NULL</span>);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> lfd = socket(PF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (lfd == <span class="hljs-number">-1</span>)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;socket error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">serv</span>;</span><br>    <span class="hljs-built_in">memset</span>(&amp;serv, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(serv));<br>    serv.sin_family = AF_INET;<br>    inet_pton(AF_INET, <span class="hljs-string">&quot;0.0.0.0&quot;</span>, &amp;serv.sin_addr.s_addr);<br>    serv.sin_port = htons(<span class="hljs-number">8686</span>);<br>    <span class="hljs-type">int</span> ret = bind(lfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;serv, <span class="hljs-keyword">sizeof</span>(serv));<br>    <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;bind error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br>    ret = listen(lfd, <span class="hljs-number">5</span>);<br>    <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;listen error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br>    <span class="hljs-type">char</span> recv_buf[<span class="hljs-number">1024</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-comment">// 初始化infos</span><br>    <span class="hljs-type">int</span> max = <span class="hljs-keyword">sizeof</span>(infos) / <span class="hljs-keyword">sizeof</span>(infos[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; max; i++)<br>    &#123;<br>        <span class="hljs-built_in">memset</span>(&amp;infos[i], <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(infos[i]));<br>        <span class="hljs-comment">// -1表示该文件描述符待用</span><br>        infos[i].fd = <span class="hljs-number">-1</span>;<br>        infos[i].tid = <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    whil<br>    &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">client_addr</span>;</span><br>        <span class="hljs-type">socklen_t</span> client_addr_len = <span class="hljs-keyword">sizeof</span>(client_addr);<br>        <span class="hljs-type">int</span> cfd = accept(lfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;client_addr, &amp;client_addr_len);<br>        <span class="hljs-comment">// 创建子线程</span><br>        <span class="hljs-comment">// 这里非常重要，需要向子线程中传递参数，使用结构体进行了封装。</span><br>        <span class="hljs-comment">// 但是后续就会出现一系列的问题，参数需要构建在堆上、需要对申请的内存进行释放、当线程很多时内存的分配消耗很大</span><br>        <span class="hljs-type">sock_info_t</span> *ptr_info;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; max; i++)<br>        &#123;<br>            <span class="hljs-comment">// 从数组中找到一个可用的sockinfo的元素,这里使用线性遍历</span><br>            <span class="hljs-keyword">if</span> (infos[i].fd == <span class="hljs-number">-1</span>)<br>            &#123;<br>                ptr_info = &amp;infos[i];<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (i == max - <span class="hljs-number">1</span>)<br>            &#123;<br>                sleep(<span class="hljs-number">1</span>);<br>                i = <span class="hljs-number">-1</span>;<br>            &#125;<br>        &#125;<br>        ptr_info-&gt;fd = cfd;<br>        <span class="hljs-built_in">memcpy</span>(&amp;ptr_info-&gt;sockaddr, &amp;client_addr, client_addr_len);<br>        pthread_create(&amp;ptr_info-&gt;tid, <span class="hljs-literal">NULL</span>, working, ptr_info);<br>        <span class="hljs-comment">// 不能用pthread_join，会一直阻塞</span><br>        pthread_detach(ptr_info-&gt;tid);<br>    &#125;<br>    close(lfd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="端口复用"><a href="#端口复用" class="headerlink" title="端口复用"></a>端口复用</h2><p>setsockopt(lfd, SOL_SOKCET, &amp;optval, sizeof(optval))</p><p>在bind()函数之前调用才会生效</p><h2 id="I-x2F-O多路复用技术"><a href="#I-x2F-O多路复用技术" class="headerlink" title="I&#x2F;O多路复用技术"></a>I&#x2F;O多路复用技术</h2><h3 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h3><p><a href="https://zhuanlan.zhihu.com/p/115220699">https://zhuanlan.zhihu.com/p/115220699</a> 一文看懂IO多路复用</p><p><a href="https://zhuanlan.zhihu.com/p/367591714">https://zhuanlan.zhihu.com/p/367591714</a> 深入浅出理解select、poll、epoll的实现</p><h3 id="B站视频笔记"><a href="#B站视频笔记" class="headerlink" title="B站视频笔记"></a>B站视频笔记</h3><p><a href="https://www.bilibili.com/video/BV1qJ411w7du/?spm_id_from=333.337.search-card.all.click&vd_source=341953e3cc61103cce8a3b9bf2c71374">https://www.bilibili.com/video/BV1qJ411w7du/?spm_id_from=333.337.search-card.all.click&amp;vd_source=341953e3cc61103cce8a3b9bf2c71374</a></p><h4 id="出现场景"><a href="#出现场景" class="headerlink" title="出现场景"></a>出现场景</h4><p>设计高性能网络服务器，对应并发请求。可以选择多线程，但是多线程需要CPU上下文切换，切换带来的代价比较高。</p><p>所以将目光转到单线程。单线程怎么出来大量的连接呢？当A发送消息时，B发送消息，会不会丢失呢？不会的。有DMA控制器。</p><p>在Linux系统中，每个网络连接都被视为文件。</p><p>一般人：遍历网络连接的文件描述符。判断里面有没有新的数据。</p><img src="截屏2023-03-27 16.23.25.png" alt="截屏2023-03-27 16.23.25" style="zoom: 33%;" /><h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>SELECT函数会将要监听的<strong>文件bitmap拷贝到内核态</strong>。如果没有数据到来，程序会一直阻塞到select这一行。</p><h5 id="当有数据到来的时候："><a href="#当有数据到来的时候：" class="headerlink" title="当有数据到来的时候："></a>当有数据到来的时候：</h5><ol><li>select函数会将rset中对应的fd置位，标识为有数据到来。</li><li>select函数返回，程序继续向下执行。返回后要遍历所有的文件描述符，因为可能会同时有多个数据到来。</li></ol><h5 id="select函数提高效率："><a href="#select函数提高效率：" class="headerlink" title="select函数提高效率："></a>select函数提高效率：</h5><p>将fdset放到了内核态，由内核去判断。</p><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ol><li>bitmap -》 rset的大小有限制</li><li>每次的rset是不能重用的。每次循环的开头，都要有<code>FD_ZERO(&amp;rset)</code>函数对其进行重制。</li><li>用户态到内核态仍然有开销</li><li>select返回后，并不知道是哪一个文件有了新数据。需要遍历一遍，有一个O(N)的开销。</li></ol><h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><img src="截屏2023-03-27 16.47.30.png" alt="截屏2023-03-27 16.47.30" style="zoom:50%;" /><p>poll方法在库中自己定义了一个结构体polldf，包含了文件描述符、可执行的事件、要返回的事件。</p><p>poll方法将结构体数组拷贝到内核态，当有数据到来的时候，将revents置位，poll返回。</p><p>程序进行对文件的处理，但是在处理之前要将revent置为0。这样就保证了对该pollfd数组的重用。</p><h5 id="poll的改进之处"><a href="#poll的改进之处" class="headerlink" title="poll的改进之处"></a>poll的改进之处</h5><ol><li>改进了select的前两个缺点。没有文件描述符的限制</li><li>可以重用fd数组</li></ol><p>但是用户内核态切换的开销没有变，每次返回需要遍历的缺点也没有变</p><h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><ol><li>先用<code>epoll_create()</code>创建epfd。epfd可以理解为一个白板。</li><li>然后用<code>epoll_ctl()</code>，对epfd进行配置。增加文件描述符、对应的事件。这些变量用epoll_event结构体储存。</li><li>epfd是在内核态和用户态中共享的，不再进行拷贝了。这样就解决了第3个缺点。</li><li>最后是<code>epoll_wait()</code>，没数据就阻塞。</li><li>有数据时：<ol><li>置位，通过重排。eg：将有数据的fd放到最前面的位置。有多个就将其都往前放。</li><li>返回值为触发事件的fd总数 &#x3D;nfd。</li></ol></li><li>程序向下运行，只需要遍历前nfd个文件描述符就好</li></ol><img src="截屏2023-03-27 17.10.11.png" alt="截屏2023-03-27 17.10.11" style="zoom:33%;" /><p>redis 和 nginx都用的epoll</p><p>java的NIO 底层也是epoll</p><h2 id="IO多路复用《手册》"><a href="#IO多路复用《手册》" class="headerlink" title="IO多路复用《手册》"></a>IO多路复用《手册》</h2><h3 id="整体概览"><a href="#整体概览" class="headerlink" title="整体概览"></a>整体概览</h3><p>IO多路复用的目的是同时检查多个文件，看他们是否做好执行IO操作的准备。</p><h4 id="为什么不用非阻塞和多进-x2F-线程？"><a href="#为什么不用非阻塞和多进-x2F-线程？" class="headerlink" title="为什么不用非阻塞和多进&#x2F;线程？"></a>为什么不用非阻塞和多进&#x2F;线程？</h4><p>非阻塞IO需要我们不断的轮询，如果轮询的频率不高，就会导致相应IO的事件延迟很高。而在一个循环中不断的轮询，是浪费CPU的操作。</p><p>多进程和线程都存在着开销昂贵且复杂的问题，同时父子之间需要通信机制去通知IO事件。</p><h4 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h4><h5 id="select和poll的优缺点"><a href="#select和poll的优缺点" class="headerlink" title="select和poll的优缺点"></a>select和poll的优缺点</h5><p>优点：方便移植，缺点：同时检查大量的文件性能低</p><h5 id="epoll优缺点"><a href="#epoll优缺点" class="headerlink" title="epoll优缺点"></a>epoll优缺点</h5><p>优点：性能高，缺点：linux专属</p><h5 id="解决移植性"><a href="#解决移植性" class="headerlink" title="解决移植性"></a>解决移植性</h5><p>需要编写软件抽象层去检查底层的文件描述符，进行机制的选用。</p><h4 id="水平触发和边缘触发"><a href="#水平触发和边缘触发" class="headerlink" title="水平触发和边缘触发"></a>水平触发和边缘触发</h4><ul><li>水平触发：文件描述符可以进行操作了（select、poll、epoll），可以任意时刻检查文件描述符</li><li>边缘触发：和上次比有了新的变化（epoll）尽可能在通知来了以后的某一时刻尽可能多的读写</li></ul><h4 id="非阻塞IO"><a href="#非阻塞IO" class="headerlink" title="非阻塞IO"></a>非阻塞IO</h4><p>在IO多路复用中应该将要监听的文件设置为非阻塞的</p><h3 id="I-x2F-O多路复用（select和poll）"><a href="#I-x2F-O多路复用（select和poll）" class="headerlink" title="I&#x2F;O多路复用（select和poll）"></a>I&#x2F;O多路复用（select和poll）</h3><h4 id="select-1"><a href="#select-1" class="headerlink" title="select()"></a>select()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/select.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> lfd = socket(PF_INET,SOCK_STREAM,<span class="hljs-number">0</span>);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">saddr</span>;</span><br>    saddr.sin_port=htons(<span class="hljs-number">9999</span>);<br>    saddr.sin_family = AF_INET;<br>    saddr.sin_addr.s_addr = INADDR_ANY;<br>    bind(lfd,(<span class="hljs-keyword">struct</span> sockaddr*)&amp;saddr,<span class="hljs-keyword">sizeof</span>(saddr));<br>    listen(lfd,<span class="hljs-number">8</span>);<br>    <span class="hljs-comment">// 创建一个fd_set的集合，存放需要检测的文件描述符</span><br>    fd_set rdset,tempset;<br>    FD_ZERO(&amp;rdset);<br>    FD_SET(lfd,&amp;rdset);<br>    <span class="hljs-type">int</span> max_fd = lfd;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        tempset = rdset;<br>        <span class="hljs-comment">// 调用select系统函数，让内核帮忙检测哪些文件描述符有数据</span><br>        <span class="hljs-type">int</span> ret = select(max_fd+<span class="hljs-number">1</span>,&amp;tempset,<span class="hljs-literal">NULL</span>,<span class="hljs-literal">NULL</span>,<span class="hljs-literal">NULL</span>);<br>        <span class="hljs-keyword">if</span>(ret==<span class="hljs-number">-1</span>)&#123;<br>            perror(<span class="hljs-string">&quot;select&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">// 说明监测到了文件描述符对应的缓冲区数据发生了改变</span><br>            <span class="hljs-keyword">if</span>(FD_ISSET(lfd,&amp;tempset))&#123;<br>                <span class="hljs-comment">// 表示有新的客户端连接进来了</span><br>                <span class="hljs-keyword">struct</span> sockaddr_in cliaddr;<br>                <span class="hljs-type">int</span> len = <span class="hljs-keyword">sizeof</span>(cliaddr);<br>                <span class="hljs-type">int</span> cfd = accept(lfd,(<span class="hljs-keyword">struct</span> sockaddr*)&amp;cliaddr,&amp;len);<br>                <span class="hljs-comment">// 将新的文件描述符加入到集合中</span><br>                FD_SET(cfd,&amp;rdset);<br>                max_fd = max_fd&gt;cfd?max_fd:cfd;<br>            &#125;<br>            <span class="hljs-comment">// 遍历集合，找到有数据的文件描述符</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=lfd+<span class="hljs-number">1</span>;i&lt;max_fd+<span class="hljs-number">1</span>;i++)&#123;<br>                <span class="hljs-keyword">if</span>(FD_ISSET(i,&amp;rdset))&#123;<br>                    <span class="hljs-comment">// 说明文件描述符i有数据</span><br>                    <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br>                    <span class="hljs-type">int</span> len = recv(i,buf,<span class="hljs-keyword">sizeof</span>(buf),<span class="hljs-number">0</span>);<br>                    <span class="hljs-keyword">if</span>(len==<span class="hljs-number">-1</span>)&#123;<br>                        perror(<span class="hljs-string">&quot;recv&quot;</span>);<br>                        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>                    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(len==<span class="hljs-number">0</span>)&#123;<br>                        <span class="hljs-comment">// 客户端关闭了连接</span><br>                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;客户端关闭了连接\n&quot;</span>);<br>                        close(i);<br>                        FD_CLR(i,&amp;rdset);<br>                    &#125;<span class="hljs-keyword">else</span>&#123;<br>                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;recv buf:%s\n&quot;</span>,buf);<br>                        <span class="hljs-comment">// send(i,&quot;ok&quot;,2,0);</span><br>                        write(i,buf,<span class="hljs-built_in">strlen</span>(buf)+<span class="hljs-number">1</span>);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    close(lfd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="poll-1"><a href="#poll-1" class="headerlink" title="poll()"></a>poll()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/poll.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> lfd = socket(PF_INET,SOCK_STREAM,<span class="hljs-number">0</span>);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">saddr</span>;</span><br>    saddr.sin_port=htons(<span class="hljs-number">9999</span>);<br>    saddr.sin_family = AF_INET;<br>    saddr.sin_addr.s_addr = INADDR_ANY;<br>    bind(lfd,(<span class="hljs-keyword">struct</span> sockaddr*)&amp;saddr,<span class="hljs-keyword">sizeof</span>(saddr));<br>    listen(lfd,<span class="hljs-number">8</span>);<br>    <span class="hljs-comment">// 初始化pollfd结构体数组，fds[1]-fds[1023]存放需要监测的文件描述符,初始化为-1</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pollfd</span> <span class="hljs-title">fds</span>[1024];</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">1024</span>;i++)&#123;<br>        fds[i].fd = <span class="hljs-number">-1</span>;<br>        fds[i].events = POLLIN;<br>    &#125;<br>    fds[<span class="hljs-number">0</span>].fd = lfd;<br>    <span class="hljs-type">int</span> nfds = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-comment">// nfd 是需要监测的文件描述符的个数，个数，个数</span><br>        <span class="hljs-type">int</span> ret = poll(fds,nfds,<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">if</span>(ret==<span class="hljs-number">-1</span>)&#123;<br>            perror(<span class="hljs-string">&quot;poll&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">// 说明监测到了文件描述符对应的缓冲区数据发生了改变</span><br>            <span class="hljs-comment">// revents的值可能是多个状态的或，所以不能用==去判断</span><br>            <span class="hljs-keyword">if</span>(fds[<span class="hljs-number">0</span>].revents&amp;POLLIN)&#123;<br>                <span class="hljs-comment">// 表示有新的客户端连接进来了</span><br>                <span class="hljs-keyword">struct</span> sockaddr_in cliaddr;<br>                <span class="hljs-type">int</span> len = <span class="hljs-keyword">sizeof</span>(cliaddr);<br>                <span class="hljs-type">int</span> cfd = accept(lfd,(<span class="hljs-keyword">struct</span> sockaddr*)&amp;cliaddr,&amp;len);<br>                <span class="hljs-comment">// 将新的文件描述符加入到集合中</span><br>                <span class="hljs-type">int</span> new_nfd = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;<span class="hljs-number">1024</span>;i++)&#123;<br>                    <span class="hljs-keyword">if</span>(fds[i].fd==<span class="hljs-number">-1</span>)&#123;<br>                        fds[i].fd = cfd;<br>                        fds[i].events = POLLIN;<br>                        <span class="hljs-comment">// 比如说nfd是1，现在加了一个，就变成2了，需要在序号的基础上加1</span><br>                        new_nfd = i+<span class="hljs-number">1</span>;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>                nfds = nfds&gt;new_nfd?nfds:new_nfd;<br>            &#125;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;nfd:%d\n&quot;</span>,nfds);<br>            <span class="hljs-comment">// 遍历集合，找到有数据的文件描述符</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;nfds+<span class="hljs-number">1</span>;i++)&#123;<br>                <span class="hljs-keyword">if</span>(fds[i].revents&amp;POLLIN)&#123;<br>                    <span class="hljs-comment">// 说明文件描述符i有数据</span><br>                    <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br>                    <span class="hljs-type">int</span> len = recv(fds[i].fd,buf,<span class="hljs-keyword">sizeof</span>(buf),<span class="hljs-number">0</span>);<br>                    <span class="hljs-keyword">if</span>(len==<span class="hljs-number">-1</span>)&#123;<br>                        perror(<span class="hljs-string">&quot;recv&quot;</span>);<br>                        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>                    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(len==<span class="hljs-number">0</span>)&#123;<br>                        <span class="hljs-comment">// 客户端关闭了连接</span><br>                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;客户端关闭了连接\n&quot;</span>);<br>                        close(fds[i].fd);<br>                        fds[i].fd = <span class="hljs-number">-1</span>;<br>                    &#125;<span class="hljs-keyword">else</span>&#123;<br>                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;recv buf:%s\n&quot;</span>,buf);<br>                        write(fds[i].fd,buf,<span class="hljs-built_in">strlen</span>(buf)+<span class="hljs-number">1</span>);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    close(lfd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="epoll的两种工作模式"><a href="#epoll的两种工作模式" class="headerlink" title="epoll的两种工作模式"></a>epoll的两种工作模式</h3><h4 id="ET模式"><a href="#ET模式" class="headerlink" title="ET模式"></a>ET模式</h4><p>文件描述符变化后，会通知，然后就不会再进行通知了。所以这个模式下，需要在通知到来以后，尽可能将缓冲区的数据读进来。</p><p>ET模式的效率高，因为减少了epoll事件被重复触发的次数。</p><p>epoll使用ET模式的时候，必须使用非阻塞套接口，避免由于一个文件句柄的堵塞IO操作将处理多个文件描述符的任务饿死。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 创建socket</span><br>    <span class="hljs-type">int</span> lfd = socket(PF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">saddr</span>;</span><br>    saddr.sin_port = htons(<span class="hljs-number">9999</span>);<br>    saddr.sin_family = AF_INET;<br>    saddr.sin_addr.s_addr = INADDR_ANY;<br>    <span class="hljs-comment">// 绑定</span><br>    bind(lfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;saddr, <span class="hljs-keyword">sizeof</span>(saddr));<br>    <span class="hljs-comment">// 监听</span><br>    listen(lfd, <span class="hljs-number">8</span>);<br>    <span class="hljs-comment">// 调用epoll_create()创建一个epoll实例</span><br>    <span class="hljs-type">int</span> epfd = epoll_create(<span class="hljs-number">100</span>);<br>    <span class="hljs-comment">// 将监听的文件描述符相关的检测信息添加到epoll实例中</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> <span class="hljs-title">epev</span>;</span><br>    epev.events = EPOLLIN;<br>    epev.data.fd = lfd;<br>    epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &amp;epev);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> <span class="hljs-title">epevs</span>[1024];</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-type">int</span> ret = epoll_wait(epfd, epevs, <span class="hljs-number">1024</span>, <span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>)<br>        &#123;<br>            perror(<span class="hljs-string">&quot;epoll_wait&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ret = %d\n&quot;</span>, ret);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ret; i++)<br>        &#123;<br>            <span class="hljs-type">int</span> curfd = epevs[i].data.fd;<br>            <span class="hljs-keyword">if</span> (curfd == lfd)<br>            &#123;<br>                <span class="hljs-comment">// 监听的文件描述符有数据达到，有客户端连接</span><br>                <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">cliaddr</span>;</span><br>                <span class="hljs-type">int</span> len = <span class="hljs-keyword">sizeof</span>(cliaddr);<br>                <span class="hljs-type">int</span> cfd = accept(lfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;cliaddr, &amp;len);<br><br>                <span class="hljs-comment">// 设置cfd属性非阻塞</span><br>                <span class="hljs-type">int</span> flag = fcntl(cfd, F_GETFL);<br>                flag |= O_NONBLOCK;<br>                fcntl(cfd, F_SETFL, flag);<br><br>                epev.events = EPOLLIN | EPOLLET; <span class="hljs-comment">// 设置边沿触发</span><br>                epev.data.fd = cfd;<br>                epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &amp;epev);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">if</span> (epevs[i].events &amp; EPOLLOUT)<br>                &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-comment">// 循环读取出所有数据</span><br>                <span class="hljs-type">char</span> buf[<span class="hljs-number">5</span>];<br>                <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">while</span> ((len = read(curfd, buf, <span class="hljs-keyword">sizeof</span>(buf))) &gt; <span class="hljs-number">0</span>)<br>                &#123;<br>                    <span class="hljs-comment">// 打印数据</span><br>                    write(STDOUT_FILENO, buf, len);<br>                    write(curfd, buf, len);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>)<br>                &#123;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;client closed....\n&quot;</span>);<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (len == <span class="hljs-number">-1</span>)<br>                &#123;<br>                    <span class="hljs-comment">// 非阻塞IO，重复读数据，此时程序不会阻塞起来等待数据准备就绪返回，read函数会返回一个错误EAGAIN，提示你的应用程序现在没有数据可读请稍后再试。</span><br>                    <span class="hljs-keyword">if</span> (errno == EAGAIN)<br>                    &#123;<br>                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;data over.....\n&quot;</span>);<br>                    &#125;<br>                   <span class="hljs-comment">// 解决 read: Connection reset by peer</span><br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (errno == ECONNRESET)<br>                    &#123;<br>                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;client reset....\n&quot;</span>);<br>                    &#125;<br>                    <span class="hljs-keyword">else</span><br>                    &#123;<br>                        perror(<span class="hljs-string">&quot;read&quot;</span>);<br>                        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    close(lfd);<br>    close(epfd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="问题1-在关闭客户端的时候，可能会报错read-Connection-reset-by-peer"><a href="#问题1-在关闭客户端的时候，可能会报错read-Connection-reset-by-peer" class="headerlink" title="问题1:在关闭客户端的时候，可能会报错read: Connection reset by peer"></a>问题1:在关闭客户端的时候，可能会报错read: Connection reset by peer</h5><p>这个是正常现象，即客户端关闭后，服务器向客户端通信，会产生该错误。可以针对该错误进行catch，也可以在客户端关闭前sleep(1)，让其能接收到服务端的消息。</p><h4 id="LT模式"><a href="#LT模式" class="headerlink" title="LT模式"></a>LT模式</h4><p>缓冲区有数据-》epoll会进行通知</p><ol><li>不读数据，一直通知</li><li>读了一部分，一直通知</li><li>读完了，不通知</li></ol>]]></content>
    
    
    <categories>
      
      <category>Linux编程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux多线程</title>
    <link href="/2023/06/03/Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <url>/2023/06/03/Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux多线程"><a href="#Linux多线程" class="headerlink" title="Linux多线程"></a>Linux多线程</h1><h2 id="线程概述（PPT）"><a href="#线程概述（PPT）" class="headerlink" title="线程概述（PPT）"></a>线程概述（PPT）</h2><p>线程和进程是类似的，也是去完成并发任务，一般线程会处理相同的任务。</p><p>线程是轻量级的进程，线程之间共享数据很方便。</p><p>进程的代价是比较高的，尽管使用了写时复制的技术，但是仍然需要复制多种表。</p><h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C">一般情况下,main函数所在的线程我们称之为主线程（main线程），其余创建的线程<br>称之为子线程。<br>程序中默认只有一个进程，fork()函数调用，<span class="hljs-number">2</span>进行<br>程序中默认只有一个线程，pthread_create()函数调用，<span class="hljs-number">2</span>个线程。<br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_create</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> *thread, <span class="hljs-type">const</span> <span class="hljs-type">pthread_attr_t</span> *attr, <span class="hljs-type">void</span> *(*start_routine) (<span class="hljs-type">void</span> *), <span class="hljs-type">void</span> *arg)</span>;<br>    - 功能：创建一个子线程<br>    - 参数：<br>        - thread：传出参数，线程创建成功后，子线程的线程ID被写到该变量中。<br>        - attr : 设置线程的属性，一般使用默认值，<span class="hljs-literal">NULL</span><br>        - start_routine : 函数指针，这个函数是子线程需要处理的逻辑代码<br>        - arg : 给第三个参数使用，传参<br>    - 返回值：<br>        成功：<span class="hljs-number">0</span><br>        失败：返回错误号。这个错误号和之前errno不太一样。<br>        获取错误号的信息：  <span class="hljs-type">char</span> * <span class="hljs-title function_">strerror</span><span class="hljs-params">(<span class="hljs-type">int</span> errnum)</span>;<br></code></pre></td></tr></table></figure><h3 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">callback</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World!\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;arg: %s\n&quot;</span>, (<span class="hljs-type">char</span>*)arg);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">pthread_t</span> tid;<br>    <span class="hljs-type">char</span>* arg = <span class="hljs-string">&quot;i am arg!&quot;</span>;<br>    <span class="hljs-type">int</span> ret = pthread_create(&amp;tid, <span class="hljs-literal">NULL</span>, callback, arg);<br>    <span class="hljs-keyword">if</span> (ret != <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-type">char</span> *errstr = strerror(ret);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pthread_create error: %s\n&quot;</span>, errstr);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;main thread: %d\n&quot;</span>, i);<br>        sleep(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在编译这个代码的时候，需要加 -l pthread</p><p>如果不将主线程sleep，子线程可能抢占不到CPU，就直接结束了。</p><h2 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h2><p><code>void pthread_exit(void *retval);</code></p><ul><li>功能：终止一个线程，在哪个线程中调用，就表示终止哪个线程</li><li>参数：<ul><li>retval ：需要传递一个指针，作为一个返回值，可以在pthread_join()中获取到。</li></ul></li></ul><p> <code>pthread_t pthread_self(void);</code></p><ul><li>功能：获取当前的线程的线程ID</li></ul><p><code>int pthread_equal(pthread_t t1, pthread_t t2);</code></p><ul><li>功能：比较两个线程ID是否相等</li><li>不同的操作系统，pthread_t类型的实现不一样，有的是无符号的长整型，有的是使用结构体去实现的。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-type">void</span> * <span class="hljs-title function_">callback</span><span class="hljs-params">(<span class="hljs-type">void</span> * arg)</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child thread id : %ld\n&quot;</span>, pthread_self());<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;    <span class="hljs-comment">// pthread_exit(NULL);</span><br>&#125; <br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 创建一个子线程</span><br>    <span class="hljs-type">pthread_t</span> tid;<br>    <span class="hljs-type">int</span> ret = pthread_create(&amp;tid, <span class="hljs-literal">NULL</span>, callback, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span>(ret != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">char</span> * errstr = strerror(ret);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error : %s\n&quot;</span>, errstr);<br>    &#125;<br>    <span class="hljs-comment">// 主线程</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, i);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;tid : %ld, main thread id : %ld\n&quot;</span>, tid ,pthread_self());<br>    <span class="hljs-comment">// 让主线程退出,当主线程退出时，不会影响其他正常运行的线程。</span><br>    pthread_exit(<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;main thread exit\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   <span class="hljs-comment">// exit(0);</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="连接已经终止的线程"><a href="#连接已经终止的线程" class="headerlink" title="连接已经终止的线程"></a>连接已经终止的线程</h2><p><code>int pthread_join(pthread_t thread, void **retval);</code></p><ul><li><p>功能：和一个已经终止的线程进行连接</p><ul><li><p>回收子线程的资源</p></li><li><p>这个函数是阻塞函数，调用一次只能回收一个子线程</p></li><li><p>一般在主线程中使用</p></li></ul></li><li><p>参数：</p><ul><li>thread：需要回收的子线程的ID</li><li>retval: 接收子线程退出时的返回值</li></ul></li><li><p>返回值：</p><ul><li>0 : 成功</li><li>非0 : 失败，返回的错误号</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> value = <span class="hljs-number">10</span>;<br><span class="hljs-type">void</span> * <span class="hljs-title function_">callback</span><span class="hljs-params">(<span class="hljs-type">void</span> * arg)</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child thread id : %ld\n&quot;</span>, pthread_self());<br>    <span class="hljs-comment">// sleep(3);</span><br>    <span class="hljs-comment">// return NULL; </span><br>    <span class="hljs-comment">// int value = 10; // 局部变量</span><br>    pthread_exit((<span class="hljs-type">void</span> *)&amp;value);   <span class="hljs-comment">// return (void *)&amp;value;</span><br>&#125; <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 创建一个子线程</span><br>    <span class="hljs-type">pthread_t</span> tid;<br>    <span class="hljs-type">int</span> ret = pthread_create(&amp;tid, <span class="hljs-literal">NULL</span>, callback, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span>(ret != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">char</span> * errstr = strerror(ret);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error : %s\n&quot;</span>, errstr);<br>    &#125;<br>    <span class="hljs-comment">// 主线程</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, i);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;tid : %ld, main thread id : %ld\n&quot;</span>, tid ,pthread_self());<br>    <span class="hljs-comment">// 主线程调用pthread_join()回收子线程的资源</span><br>    <span class="hljs-type">int</span> * thread_retval;<br>    ret = pthread_join(tid, (<span class="hljs-type">void</span> **)&amp;thread_retval);<br>    <span class="hljs-keyword">if</span>(ret != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">char</span> * errstr = strerror(ret);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error : %s\n&quot;</span>, errstr);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;exit data : %d\n&quot;</span>, *thread_retval);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;回收子线程资源成功！\n&quot;</span>);<br>    <span class="hljs-comment">// 让主线程退出,当主线程退出时，不会影响其他正常运行的线程。</span><br>    pthread_exit(<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br></code></pre></td></tr></table></figure><p>当子线程的局部变量通过pthread_exit传出的时候，在主线程中接收到的是错误的值。因为子线程推出后，局部变量的<strong>栈空间</strong>会被编译器清空。所以不能使用这样的方式进行传参。应该传全局变量。</p><h2 id="线程分离"><a href="#线程分离" class="headerlink" title="线程分离"></a>线程分离</h2><p><code>int pthread_detach(pthread_t thread);</code></p><ul><li>功能：分离一个线程。<ul><li><p>被分离的线程在终止的时候，会自动释放资源返回给系统。</p></li><li><p>不能多次分离，会产生不可预料的行为。</p></li><li><p>不能去连接一个已经分离的线程，会报错。</p></li><li><p>参数：需要分离的线程的ID</p></li><li><p>返回值：</p><ul><li>成功：0</li><li>失败：返回错误号</li></ul></li></ul></li></ul><h2 id="线程取消"><a href="#线程取消" class="headerlink" title="线程取消"></a>线程取消</h2><p><code>int pthread_cancel(pthread_t thread);</code></p><ul><li>功能：取消线程（让线程终止）<ul><li>取消某个线程，可以终止某个线程的运行，</li><li>但是并不是立马终止，而是当子线程执行到一个取消点，线程才会终止。</li><li>取消点：系统规定好的一些系统调用，我们可以粗略的理解为从用户区到内核区的切换，这个位置称之为取消点。</li></ul></li></ul><h2 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    int pthread_attr_init(pthread_attr_t *attr);</span><br><span class="hljs-comment">        - 初始化线程属性变量</span><br><span class="hljs-comment">    int pthread_attr_destroy(pthread_attr_t *attr);</span><br><span class="hljs-comment">        - 释放线程属性的资源</span><br><span class="hljs-comment">    int pthread_attr_getdetachstate(const pthread_attr_t *attr, int *detachstate);</span><br><span class="hljs-comment">        - 获取线程分离的状态属性</span><br><span class="hljs-comment">    int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);</span><br><span class="hljs-comment">        - 设置线程分离的状态属性</span><br><span class="hljs-comment">*/</span>     <br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">void</span> * <span class="hljs-title function_">callback</span><span class="hljs-params">(<span class="hljs-type">void</span> * arg)</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;chid thread id : %ld\n&quot;</span>, pthread_self());<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 创建一个线程属性变量</span><br>    <span class="hljs-type">pthread_attr_t</span> attr;<br>    <span class="hljs-comment">// 初始化属性变量</span><br>    pthread_attr_init(&amp;attr);<br>    <span class="hljs-comment">// 设置属性</span><br>    pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);<br>    <span class="hljs-comment">// 创建一个子线程</span><br>    <span class="hljs-type">pthread_t</span> tid;<br>    <span class="hljs-type">int</span> ret = pthread_create(&amp;tid, &amp;attr, callback, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span>(ret != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">char</span> * errstr = strerror(ret);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error1 : %s\n&quot;</span>, errstr);<br>    &#125;<br>    <span class="hljs-comment">// 获取线程的栈的大小</span><br>    <span class="hljs-type">size_t</span> size;<br>    pthread_attr_getstacksize(&amp;attr, &amp;size);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;thread stack size : %ld\n&quot;</span>, size);<br>    <span class="hljs-comment">// 输出主线程和子线程的id</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;tid : %ld, main thread id : %ld\n&quot;</span>, tid, pthread_self());<br>    <span class="hljs-comment">// 释放线程属性资源</span><br>    pthread_attr_destroy(&amp;attr);<br>    pthread_exit(<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="线程同步（PPT）"><a href="#线程同步（PPT）" class="headerlink" title="线程同步（PPT）"></a>线程同步（PPT）</h2><h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><p>互斥量的类型 pthread_mutex_t</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_mutex_init</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *<span class="hljs-keyword">restrict</span> mutex, <span class="hljs-type">const</span> <span class="hljs-type">pthread_mutexattr_t</span> *<span class="hljs-keyword">restrict</span> attr)</span>;<br></code></pre></td></tr></table></figure><p>初始化互斥量</p><ul><li><p>参数</p><ul><li><p>mutex ： 需要初始化的互斥量变量</p></li><li><p>attr ： 互斥量相关的属性，NULL<br>- restrict : C语言的修饰符，被修饰的指针，不能由另外的一个指针进行操作。<br>pthread_mutex_t *restrict mutex &#x3D; xxx;<br>pthread_mutex_t * mutex1 &#x3D; mutex;</p></li></ul></li></ul><p><code>int pthread_mutex_destroy(pthread_mutex_t *mutex);</code></p><p>释放互斥量的资源</p><p><code>int pthread_mutex_lock(pthread_mutex_t *mutex);</code></p><p>加锁，阻塞的，如果有一个线程加锁了，那么其他的线程只能阻塞等待</p><p><code>int pthread_mutex_trylock(pthread_mutex_t *mutex);</code></p><p>尝试加锁，如果加锁失败，不会阻塞，会直接返回。</p><p><code>int pthread_mutex_unlock(pthread_mutex_t *mutex);</code></p><p>解锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-comment">// 全局变量，所有的线程都共享这一份资源。</span><br><span class="hljs-type">int</span> tickets = <span class="hljs-number">1000</span>;<br><span class="hljs-comment">// 创建一个互斥量</span><br><span class="hljs-type">pthread_mutex_t</span> mutex;<br><span class="hljs-type">void</span> * <span class="hljs-title function_">sellticket</span><span class="hljs-params">(<span class="hljs-type">void</span> * arg)</span> &#123;<br>    <span class="hljs-comment">// 卖票</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 加锁</span><br>        pthread_mutex_lock(&amp;mutex);<br>        <span class="hljs-keyword">if</span>(tickets &gt; <span class="hljs-number">0</span>) &#123;<br>            usleep(<span class="hljs-number">6000</span>);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%ld 正在卖第 %d 张门票\n&quot;</span>, pthread_self(), tickets);<br>            tickets--;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 解锁</span><br>            pthread_mutex_unlock(&amp;mutex);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">// 解锁</span><br>        pthread_mutex_unlock(&amp;mutex);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 初始化互斥量</span><br>    pthread_mutex_init(&amp;mutex, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-comment">// 创建3个子线程</span><br>    <span class="hljs-type">pthread_t</span> tid1, tid2, tid3;<br>    pthread_create(&amp;tid1, <span class="hljs-literal">NULL</span>, sellticket, <span class="hljs-literal">NULL</span>);<br>    pthread_create(&amp;tid2, <span class="hljs-literal">NULL</span>, sellticket, <span class="hljs-literal">NULL</span>);<br>    pthread_create(&amp;tid3, <span class="hljs-literal">NULL</span>, sellticket, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-comment">// 回收子线程的资源,阻塞</span><br>    pthread_join(tid1, <span class="hljs-literal">NULL</span>);<br>    pthread_join(tid2, <span class="hljs-literal">NULL</span>);<br>    pthread_join(tid3, <span class="hljs-literal">NULL</span>);<br>    pthread_exit(<span class="hljs-literal">NULL</span>); <span class="hljs-comment">// 退出主线程</span><br>    <span class="hljs-comment">// 释放互斥量资源</span><br>    pthread_mutex_destroy(&amp;mutex);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br></code></pre></td></tr></table></figure><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>有的时候，一个线程需要同时访问多个不同的共享资源，而每个资源又由不同的互斥量进行管理。当超过一个线程对这组互斥量进行加锁的时候，就可能出现死锁的现象。</p><p>两个或两个以上的进程在执行过程中，因为抢占资源而造成的一种互相等待的现象，若无外力作用，它们都无法推进下去，此时称系统产生了死锁。</p><p>死锁的几种场景：</p><ol><li>忘记释放锁</li><li>给一个变量多次加锁</li><li>多线程多锁，抢占锁资源</li></ol><h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p>死锁现象一般发生在对数据的写，而不是读。所以就来了读写锁。</p><ol><li>读写锁允许多个线程同时读。</li><li>如果有一个线程在写数据，那么其他线程都不可以读写操作。</li><li>写锁的优先级高于读。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-comment">// 全局变量，所有的线程都共享这一份资源。</span><br><span class="hljs-type">int</span> num = <span class="hljs-number">1</span>;<br><span class="hljs-type">pthread_rwlock_t</span> rwlock;<br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">writeNum</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        pthread_rwlock_wrlock(&amp;rwlock);<br>        num++;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;writeNum tid = %ld, num=%d\n&quot;</span>,pthread_self(), num);<br>        pthread_rwlock_unlock(&amp;rwlock);<br>        usleep(<span class="hljs-number">100</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-type">void</span> *<span class="hljs-title function_">readNum</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        pthread_rwlock_rdlock(&amp;rwlock);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;readNum tid = %ld, num=%d\n&quot;</span>,pthread_self(), num);<br>        pthread_rwlock_unlock(&amp;rwlock);<br>        usleep(<span class="hljs-number">100</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    pthread_rwlock_init(&amp;rwlock, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-type">pthread_t</span> wtid[<span class="hljs-number">3</span>], rtid[<span class="hljs-number">5</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)<br>    &#123;<br>        pthread_create(&amp;wtid[i], <span class="hljs-literal">NULL</span>, writeNum, <span class="hljs-literal">NULL</span>);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>    &#123;<br>        pthread_create(&amp;rtid[i], <span class="hljs-literal">NULL</span>, readNum, <span class="hljs-literal">NULL</span>);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)<br>    &#123;<br>        pthread_detach(wtid[i]);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>    &#123;<br>        pthread_detach(rtid[i]);<br>    &#125;<br>    pthread_exit(<span class="hljs-literal">NULL</span>);<br>    pthread_rwlock_destroy(&amp;rwlock);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h2><ol><li>多个生产者、多个消费者</li><li>线程同步问题</li><li>容器满了或者空了，对消费者生产者的通知和阻塞问题。</li></ol><p>初始版本代码，会出现报错。段错误。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// 生产者消费者模型</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> num;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">next</span>;</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">head</span> =</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br><span class="hljs-type">void</span> *<span class="hljs-title function_">producer</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-comment">// 生产者生产一个产品</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">newNode</span> =</span> (<span class="hljs-keyword">struct</span> Node *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Node));<br>        newNode-&gt;num = rand() % <span class="hljs-number">1000</span> + <span class="hljs-number">1</span>;<br>        newNode-&gt;next = head;<br>        head = newNode;<br>        sum ++;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;++++++ num = %d, tid = %lu, sum = %d\n&quot;</span>, newNode-&gt;num,pthread_self(),sum);<br>        usleep(<span class="hljs-number">100</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-type">void</span> *<span class="hljs-title function_">consumer</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-comment">// 消费者消费一个产品</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">temp</span> =</span> head;<br>        head = head-&gt;next;<br>        sum--;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-------: num = %d, tid = %ld, sum=%d\n&quot;</span>,temp-&gt;num,pthread_self(),sum);<br>        <span class="hljs-built_in">free</span>(temp);<br>        temp = <span class="hljs-literal">NULL</span>;<br>        usleep(<span class="hljs-number">100</span>);<br>    &#125;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 创健5个生产者线程，5个消费者线程</span><br>    <span class="hljs-type">pthread_t</span> ptid[<span class="hljs-number">5</span>], ctid[<span class="hljs-number">5</span>];<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>    &#123;<br>        pthread_create(&amp;ptid[i], <span class="hljs-literal">NULL</span>, producer, <span class="hljs-literal">NULL</span>);<br>        pthread_create(&amp;ctid[i], <span class="hljs-literal">NULL</span>, consumer, <span class="hljs-literal">NULL</span>);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>    &#123;<br>        pthread_detach(ptid[i]);<br>        pthread_detach(ctid[i]);<br>    &#125;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        sleep(<span class="hljs-number">10</span>);<br>    &#125;<br>    pthread_exit(<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><p>条件变量不是锁，是用于阻塞线程的。</p><p>条件变量的类型 <code>pthread_cond_t</code></p><p><code>int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr);</code></p><p>初始化</p><p><code>int pthread_cond_destroy(pthread_cond_t *cond);</code></p><p>销毁</p><p><code>int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex);</code></p><p>等待，调用了该函数，线程会阻塞。但是会对里面的锁先进行解锁，当不阻塞的时候，继续向下执行，会重新加锁</p><p><code>int pthread_cond_timedwait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex, const struct timespec *restrict abstime);</code></p><p>等待多长时间，调用了这个函数，线程会阻塞，直到指定的时间结束。</p><p><code>int pthread_cond_signal(pthread_cond_t *cond);</code></p><p>唤醒一个或者多个等待的线程，通知！</p><p><code>int pthread_cond_broadcast(pthread_cond_t *cond);</code></p><p>唤醒所有的等待的线程</p><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    信号量的类型 sem_t</span><br><span class="hljs-comment">    int sem_init(sem_t *sem, int pshared, unsigned int value);</span><br><span class="hljs-comment">        - 初始化信号量</span><br><span class="hljs-comment">        - 参数：</span><br><span class="hljs-comment">            - sem : 信号量变量的地址</span><br><span class="hljs-comment">            - pshared : 0 用在线程间 ，非0 用在进程间</span><br><span class="hljs-comment">            - value : 信号量中的值</span><br><span class="hljs-comment">    int sem_destroy(sem_t *sem);</span><br><span class="hljs-comment">        - 释放资源</span><br><span class="hljs-comment">    int sem_wait(sem_t *sem);</span><br><span class="hljs-comment">        - 对信号量加锁，调用一次对信号量的值-1，如果值为0，就阻塞</span><br><span class="hljs-comment">    int sem_trywait(sem_t *sem);</span><br><span class="hljs-comment">    int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);</span><br><span class="hljs-comment">    int sem_post(sem_t *sem);</span><br><span class="hljs-comment">        - 对信号量解锁，调用一次对信号量的值+1</span><br><span class="hljs-comment">    int sem_getvalue(sem_t *sem, int *sval);</span><br><span class="hljs-comment">    sem_t psem;</span><br><span class="hljs-comment">    sem_t csem;</span><br><span class="hljs-comment">    init(psem, 0, 8);</span><br><span class="hljs-comment">    init(csem, 0, 0);</span><br><span class="hljs-comment">    producer() &#123;</span><br><span class="hljs-comment">        sem_wait(&amp;psem);</span><br><span class="hljs-comment">        sem_post(&amp;csem)</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    customer() &#123;</span><br><span class="hljs-comment">        sem_wait(&amp;csem);</span><br><span class="hljs-comment">        sem_post(&amp;psem)</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// 生产者消费者模型</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;semaphore.h&gt;</span></span><br><span class="hljs-type">pthread_mutex_t</span> mutex;<br><span class="hljs-type">sem_t</span> csem;<br><span class="hljs-type">sem_t</span> psem;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> num;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">next</span>;</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">head</span> =</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br><span class="hljs-type">void</span> *<span class="hljs-title function_">producer</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-comment">// 生产者生产一个产品</span><br>        sem_wait(&amp;psem);<br>        pthread_mutex_lock(&amp;mutex);<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">newNode</span> =</span> (<span class="hljs-keyword">struct</span> Node *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Node));<br>        newNode-&gt;num = rand() % <span class="hljs-number">1000</span> + <span class="hljs-number">1</span>;<br>        newNode-&gt;next = head;<br>        head = newNode;<br>        sum++;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;++++++ num = %d, tid = %lu, sum = %d\n&quot;</span>, newNode-&gt;num, pthread_self(), sum);<br>        <span class="hljs-comment">// 只要sum&gt;0，就唤醒消费者</span><br>        pthread_mutex_unlock(&amp;mutex);<br>        sem_post(&amp;csem);<br>        usleep(<span class="hljs-number">100</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-type">void</span> *<span class="hljs-title function_">consumer</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-comment">// 消费者消费一个产品</span><br>        sem_wait(&amp;csem);<br>        pthread_mutex_lock(&amp;mutex);<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">temp</span> =</span> head;<br>        head = head-&gt;next;<br>        sum--;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-------: num = %d, tid = %ld, sum=%d\n&quot;</span>, temp-&gt;num, pthread_self(), sum);<br>        <span class="hljs-built_in">free</span>(temp);<br>        temp = <span class="hljs-literal">NULL</span>;<br>        pthread_mutex_unlock(&amp;mutex);<br>        sem_post(&amp;psem);<br>        usleep(<span class="hljs-number">100</span>);<br>    &#125;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 创健5个生产者线程，5个消费者线程</span><br>    <span class="hljs-type">pthread_t</span> ptid[<span class="hljs-number">5</span>], ctid[<span class="hljs-number">5</span>];<br>    sem_init(&amp;psem, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>);<br>    sem_init(&amp;csem, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>    &#123;<br>        pthread_create(&amp;ptid[i], <span class="hljs-literal">NULL</span>, producer, <span class="hljs-literal">NULL</span>);<br>        pthread_create(&amp;ctid[i], <span class="hljs-literal">NULL</span>, consumer, <span class="hljs-literal">NULL</span>);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>    &#123;<br>        pthread_join(ptid[i], <span class="hljs-literal">NULL</span>);<br>        pthread_join(ctid[i], <span class="hljs-literal">NULL</span>);<br>    &#125;<br>    pthread_mutex_destroy(&amp;mutex);<br>    pthread_exit(<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux编程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux多进程</title>
    <link href="/2023/06/03/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
    <url>/2023/06/03/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux多进程"><a href="#Linux多进程" class="headerlink" title="Linux多进程"></a>Linux多进程</h1><h2 id="程序和进程"><a href="#程序和进程" class="headerlink" title="程序和进程"></a>程序和进程</h2><p><strong>程序描述如何在运行时创建一个进程。</strong><img src="截屏2023-03-31 18.12.09-1135960.png" alt="截屏2023-03-31 18.12.09" style="zoom:50%;" /></p><p>![截屏2023-03-31 18.15.17](截屏2023-03-31 18.15.17-1135960.png)</p><h3 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h3><img src="截屏2023-04-01 17.55.50-1135960.png" alt="截屏2023-04-01 17.55.50" style="zoom: 25%;" /><h3 id="进程控制块PCB"><a href="#进程控制块PCB" class="headerlink" title="进程控制块PCB"></a>进程控制块PCB</h3><img src="截屏2023-04-01 17.58.35-1135960.png" alt="截屏2023-04-01 17.58.35" style="zoom: 33%;" /><img src="截屏2023-04-01 18.07.51-1135960.png" alt="截屏2023-04-01 18.07.51" style="zoom: 33%;" /><h2 id="进程的状态转换"><a href="#进程的状态转换" class="headerlink" title="进程的状态转换"></a>进程的状态转换</h2><img src="截屏2023-04-01 18.11.13-1135960.png" alt="截屏2023-04-01 18.11.13" style="zoom:50%;" /><img src="截屏2023-04-01 18.39.52-1135960.png" alt="截屏2023-04-01 18.39.52" style="zoom:50%;" /><h2 id="进程相关的命令"><a href="#进程相关的命令" class="headerlink" title="进程相关的命令"></a>进程相关的命令</h2><h3 id="查看进程的指令-ps"><a href="#查看进程的指令-ps" class="headerlink" title="查看进程的指令 ps"></a>查看进程的指令 ps</h3><p>![截屏2023-04-01 18.42.45](截屏2023-04-01 18.42.45-1135960.png)</p><h4 id="STAT参数（不用记）"><a href="#STAT参数（不用记）" class="headerlink" title="STAT参数（不用记）"></a>STAT参数（不用记）</h4><p>在Linux中，<code>ps</code>命令输出的进程状态中有一个<code>STAT</code>参数，它表示进程的状态。以下是常见的<code>STAT</code>参数及其含义：</p><ul><li><code>R</code>（Running）：进程正在运行或在运行队列中等待。</li><li><code>S</code>（Sleeping）：进程正在睡眠中，即进程正在等待某个事件的发生，如等待IO完成或等待信号。</li><li><code>D</code>（Disk sleep）：进程正在等待磁盘IO完成，即进程处于阻塞状态。</li><li><code>Z</code>（Zombie）：进程已经完成执行，但是其父进程尚未将其状态清除，导致其状态变为僵尸状态。</li><li><code>T</code>（Stopped）：进程已经被暂停，例如收到了SIGSTOP信号。</li><li><code>t</code>（Tracing stop）：进程已经被暂停，以等待跟踪器进程的指示，例如收到了SIGTRAP信号。</li><li><code>W</code>（Paging）：进程正在进行页面交换。</li><li><code>X</code>（Dead）：进程已经退出或被杀死。</li><li><code>&lt;</code>（High-priority）：进程具有高优先级。</li><li><code>N</code>（Low-priority）：进程具有低优先级。</li><li><code>s</code>（Session leader）：进程是一个会话的领导者。</li><li><code>+</code>（Foreground）：进程正在前台运行。</li></ul><p>其中，<code>R</code>、<code>S</code>和<code>D</code>是进程状态的主要状态，表示进程正在运行、睡眠或阻塞状态。<code>Z</code>状态表示僵尸进程，<code>T</code>状态表示停止状态，<code>t</code>状态表示正在跟踪进程，<code>W</code>状态表示页面交换状态，<code>X</code>状态表示进程已经退出或被杀死，<code>&lt;</code>和<code>N</code>状态表示进程的优先级，<code>s</code>状态表示会话的领导者，<code>+</code>状态表示进程正在前台运行。</p><h3 id="top命令"><a href="#top命令" class="headerlink" title="top命令"></a>top命令</h3><p><code>top</code>是一个常用的命令行工具，用于实时显示系统中运行的进程信息。它可以按照CPU使用率、内存使用率等多种指标对进程进行排序，还可以查看系统的负载、内存使用情况等系统性能指标。以下是一些常用的<code>top</code>命令选项：</p><ol><li><code>top</code>：默认情况下，<code>top</code>会显示当前系统中所有进程的信息，按照CPU使用率进行排序。</li><li><code>top -u username</code>：只显示指定用户的进程。</li><li><code>top -p pid</code>：只显示指定进程ID的进程。</li><li><code>top -b</code>：以批处理模式运行，输出结果到文件中。</li><li><code>top -n</code>：指定要显示的次数后退出。</li><li><code>top -d</code>：指定两次更新之间的时间间隔。</li><li><code>top -o</code>：指定排序方式，如<code>top -o %CPU</code>按照CPU使用率进行排序。</li></ol><p>在<code>top</code>的交互界面中，可以使用一些快捷键来进行操作，例如：</p><ol><li><code>k</code>：杀死一个进程。</li><li><code>r</code>：重新调度一个进程。</li><li><code>1</code>：切换到单CPU模式，只显示一个CPU的信息。</li><li><code>f</code>：切换显示不同的进程信息字段。</li><li><code>q</code>：退出<code>top</code>命令。</li></ol><p>通过<code>top</code>命令，我们可以实时了解系统中正在运行的进程的状态和资源占用情况，以及系统的性能指标，有助于及时发现和解决系统性能问题。</p><h3 id="kill命令"><a href="#kill命令" class="headerlink" title="kill命令"></a>kill命令</h3><p><code>kill</code>命令是Linux中一个常用的命令，用于向指定的进程发送信号，以控制进程的行为。通常情况下，<code>kill</code>命令用于停止或终止运行中的进程。以下是一些常用的<code>kill</code>命令选项：</p><ol><li><code>kill PID</code>：向指定PID的进程发送<code>SIGTERM</code>信号，以请求进程终止。</li><li><code>kill -9 PID</code>：向指定PID的进程发送<code>SIGKILL</code>信号，以强制进程立即终止。</li><li><code>killall process_name</code>：向所有同名进程发送<code>SIGTERM</code>信号，以请求进程终止。</li><li><code>killall -9 process_name</code>：向所有同名进程发送<code>SIGKILL</code>信号，以强制进程立即终止。</li></ol><p>除了上述常用的选项之外，<code>kill</code>命令还可以向进程发送其他类型的信号，例如：</p><ol><li><code>SIGINT</code>：向进程发送中断信号，通常由<code>Ctrl+C</code>产生。</li><li><code>SIGHUP</code>：向进程发送终端挂起信号，通常用于重新读取配置文件。</li><li><code>SIGUSR1</code>和<code>SIGUSR2</code>：向进程发送用户定义信号。</li></ol><p>需要注意的是，使用<code>kill</code>命令终止进程可能会导致数据丢失或系统不稳定，因此在终止进程之前最好先尝试通过其他方式结束进程，例如发送<code>SIGTERM</code>信号等待进程自行退出。</p><h2 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h2><img src="截屏2023-04-01 21.37.38-1135960.png" alt="截屏2023-04-01 21.37.38" style="zoom:50%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment">#include &lt;sys/types.h&gt;</span><br><span class="hljs-comment">#include &lt;unistd.h&gt;</span><br><span class="hljs-comment">    pid_t fork(void);</span><br><span class="hljs-comment">        函数的作用：创建一个新的进程，新的进程是原进程的一个副本</span><br><span class="hljs-comment">        返回值：新进程的进程号，一次是在父进程中返回，一次是在子进程中返回</span><br><span class="hljs-comment">        在父进程中返回子进程的进程号，在子进程中返回0</span><br><span class="hljs-comment">        如何判断是父进程还是子进程：通过返回值来判断</span><br><span class="hljs-comment">        在父进程中返回-1，表示创建子进程失败，并且设置errno</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">//创建子进程</span><br>    <span class="hljs-type">pid_t</span> pid = fork();<br>    <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">-1</span>)&#123;<br>        perror(<span class="hljs-string">&quot;fork&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> num = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">//子进程</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child pid = %d,parent pid = %d\n&quot;</span>,getpid(),getppid());<br>        num = <span class="hljs-number">100</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child num = %d\n&quot;</span>,num);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-comment">//父进程</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;parent pid = %d\n&quot;</span>,getpid());<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;parent num = %d\n&quot;</span>,num);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="父子进程"><a href="#父子进程" class="headerlink" title="父子进程"></a>父子进程</h2><h3 id="父子进程虚拟地址空间情况"><a href="#父子进程虚拟地址空间情况" class="headerlink" title="父子进程虚拟地址空间情况"></a>父子进程虚拟地址空间情况</h3><img src="截屏2023-04-01 22.16.23-1135960.png" alt="截屏2023-04-01 22.16.23" style="zoom:50%;" /><p>子进程会把父进程的变量全部拷贝下来，但是会把用户区的pid设置为0。子进程对变量的操作不会影响父进程。</p><h3 id="fork的写时拷贝"><a href="#fork的写时拷贝" class="headerlink" title="fork的写时拷贝"></a>fork的写时拷贝</h3><p>写时拷贝是一种内存管理技术，它通过在创建进程时共享原始进程的内存页来提高性能。当子进程需要修改共享的内存页时，操作系统会在这个内存页被修改前，将其复制到子进程的地址空间中。这样可以避免复制整个进程的地址空间，而只复制必要的部分。</p><p>在<code>fork()</code>中，父进程和子进程最初共享同一份内存。当父进程或子进程尝试修改共享的内存时，操作系统会使用写时拷贝技术来复制这个内存页，并且将这个内存页的副本分配给修改进程。这样，父进程和子进程的内存空间就被分开了，互不干扰，避免了不必要的内存复制。</p><p>使用写时拷贝技术可以减少内存使用，提高系统性能。在多个进程需要共享同一份内存时，这种技术可以避免复制整个内存区域，从而减少了开销。在<code>fork()</code>中，写时拷贝技术也可以避免复制整个进程的地址空间，从而提高了<code>fork()</code>的效率。</p><h3 id="父子进程关系总结"><a href="#父子进程关系总结" class="headerlink" title="父子进程关系总结"></a>父子进程关系总结</h3><h4 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h4><ol><li>fork()返回值不同，父进程为子进程pid，子进程为0</li><li>PCB(进程控制块)，当前进程的id，pid，信号集</li></ol><h4 id="相同："><a href="#相同：" class="headerlink" title="相同："></a>相同：</h4><ol><li>子进程在创建的时候，变量和父进程是一样。用户区数据，文件描述表</li><li>读时共享，写时拷贝</li></ol><h2 id="GDB多进程调试"><a href="#GDB多进程调试" class="headerlink" title="GDB多进程调试"></a>GDB多进程调试</h2><p>![截屏2023-04-01 22.39.24](截屏2023-04-01 22.39.24-1135960.png)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) show follow-fork-mode <br>Debugger response to a program call of fork or vfork is &quot;parent&quot;.<br>(gdb) set follow-fork-mode child <br>(gdb) show follow-fork-mode <br>Debugger response to a program call of fork or vfork is &quot;child&quot;.<br></code></pre></td></tr></table></figure><p>奶奶滴，gdb8x的版本多进程调试会出问题。</p><ol><li>先设置调试模式，让子进程挂起。</li><li>使用info inferior，查看现在的调试进程。使用inferior + id ，进行切换</li><li>切换到子进程，摁c让其运行至断点</li></ol><p>使用detach命令可以让选定的进程脱离GDB，自己继续运行。</p><h2 id="exec函数族"><a href="#exec函数族" class="headerlink" title="exec函数族"></a>exec函数族</h2><p>![截屏2023-04-02 15.35.23](截屏2023-04-02 15.35.23-1135960.png)</p><p>![截屏2023-04-02 15.43.08](截屏2023-04-02 15.43.08-1135960.png)</p><h3 id="execl"><a href="#execl" class="headerlink" title="execl"></a>execl</h3><p><code>execl()</code>是UNIX系统中用于在当前进程中执行另一个程序的函数。该函数在当前进程中用新的程序替换当前程序，因此原有的程序代码不再执行。<code>execl()</code>函数使用指定的参数列表调用一个新的程序，并将新程序的控制权传递给新程序。<code>execl()</code>函数是<code>exec()</code>函数族中的一个成员，它在<code>&lt;unistd.h&gt;</code>头文件中声明。</p><p><code>execl()</code>函数的声明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">execl</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *arg, ...)</span>;<br></code></pre></td></tr></table></figure><p>其中，<code>path</code>参数是要执行的程序的路径和名称（推荐使用绝对路径），<code>arg</code>参数指定新程序的命令行参数。<code>arg</code>参数以可变参数列表的形式表示，最后一个参数必须为NULL（哨兵）。</p><p>例如，以下代码片段演示了如何使用<code>execl()</code>函数在UNIX系统中执行<code>/bin/ls</code>命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    execl(<span class="hljs-string">&quot;/bin/ls&quot;</span>, <span class="hljs-string">&quot;ls&quot;</span>, <span class="hljs-string">&quot;-l&quot;</span>, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>execl()</code>函数调用将执行<code>/bin/ls</code>命令，并传递两个参数：<code>ls</code>和<code>-l</code>。由于最后一个参数必须为NULL，因此使用了<code>NULL</code>表示可变参数列表的结尾。</p><p>需要注意的是，<code>execl()</code>函数<strong>只有在调用失败时才会返回</strong>，否则它将在新程序中执行，并将控制权转移给新程序。因此，在调用<code>execl()</code>函数时，应该确保当前程序执行的任何代码都不会继续执行，以免出现未定义的行为。</p><h3 id="execlp"><a href="#execlp" class="headerlink" title="execlp"></a>execlp</h3><p><code>execlp()</code>函数是UNIX系统中用于在当前进程中执行另一个程序的函数之一。与<code>execl()</code>函数和<code>execvp()</code>函数不同，<code>execlp()</code>函数不需要在参数中指定程序的完整路径，而是从系统的环境变量<code>PATH</code>中查找可执行文件。</p><p><code>execlp()</code>函数的声明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">execlp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *file, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *arg, ...)</span>;<br></code></pre></td></tr></table></figure><p>其中，<code>file</code>参数是要执行的程序的名称（不带路径），<code>arg</code>参数是传递给新程序的第一个参数，后跟可变数量的参数。参数列表必须以一个空指针结束。</p><p>以下是使用<code>execlp()</code>函数执行<code>ls</code>命令的示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    execlp(<span class="hljs-string">&quot;ls&quot;</span>, <span class="hljs-string">&quot;ls&quot;</span>, <span class="hljs-string">&quot;-l&quot;</span>, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>execlp()</code>函数将在环境变量<code>PATH</code>指定的目录中搜索<code>ls</code>命令，并传递<code>-l</code>参数给<code>ls</code>。因为<code>execlp()</code>函数不需要指定程序的路径，所以调用非常简单。</p><h3 id="execv"><a href="#execv" class="headerlink" title="execv"></a>execv</h3><p><code>execv()</code>是UNIX系统中用于在当前进程中执行另一个程序的函数。该函数在当前进程中用新的程序替换当前程序，因此原有的程序代码不再执行。<code>execv()</code>函数使用指定的参数数组调用一个新的程序，并将新程序的控制权传递给新程序。<code>execv()</code>函数是<code>exec()</code>函数族中的一个成员，它在<code>&lt;unistd.h&gt;</code>头文件中声明。</p><p><code>execv()</code>函数的声明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">execv</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">char</span> *<span class="hljs-type">const</span> argv[])</span>;<br></code></pre></td></tr></table></figure><p>其中，<code>path</code>参数是要执行的程序的路径和名称，<code>argv</code>参数是指向指针数组的指针，其中每个指针都指向一个新程序的命令行参数。数组的最后一个元素必须为NULL。</p><p>例如，以下代码片段演示了如何使用<code>execv()</code>函数在UNIX系统中执行<code>/bin/ls</code>命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> *<span class="hljs-type">const</span> args[] = &#123;<span class="hljs-string">&quot;ls&quot;</span>, <span class="hljs-string">&quot;-l&quot;</span>, <span class="hljs-literal">NULL</span>&#125;;<br>    execv(<span class="hljs-string">&quot;/bin/ls&quot;</span>, args);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>execv()</code>函数调用将执行<code>/bin/ls</code>命令，并传递两个参数：<code>ls</code>和<code>-l</code>。由于<code>args</code>数组的最后一个元素必须为NULL，因此使用了<code>NULL</code>表示数组的结尾。</p><h3 id="execve"><a href="#execve" class="headerlink" title="execve"></a>execve</h3><p>增加了一个envp数组，这个数组里保存可执行程序搜索的路径，可以有多个，依次搜索。</p><h2 id="exit退出进程"><a href="#exit退出进程" class="headerlink" title="exit退出进程"></a>exit退出进程</h2><img src="截屏2023-04-02 16.40.11-1135960.png" alt="截屏2023-04-02 16.40.11" style="zoom:50%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">exit</span><span class="hljs-params">(<span class="hljs-type">int</span> status)</span>;<br><span class="hljs-comment">// status是进程退出时的状态信息，父进程回收子进程资源的时候可以获取</span><br></code></pre></td></tr></table></figure><h3 id="exit和-exit"><a href="#exit和-exit" class="headerlink" title="exit和_exit"></a>exit和_exit</h3><p>在C语言中，<code>exit()</code>函数是一个库函数，用于终止当前进程的执行，并返回一个退出状态码。同时，它还会自动调用所有已注册的<code>atexit()</code>函数，以确保程序的资源得到正确释放。</p><p>在C语言中，<code>_exit()</code>函数是一个系统调用函数，用于终止当前进程的执行，不返回任何值，也不自动调用<code>atexit()</code>函数。与<code>exit()</code>函数不同，<code>_exit()</code>函数不会将缓冲区中的数据写回到文件中，也不会关闭已打开的文件和流。</p><p>另外，在C语言中，还有一个与<code>_exit()</code>函数类似的函数，名为<code>_Exit()</code>，它也是一个系统调用函数，用于立即终止当前进程的执行，但不会执行清理处理。</p><h2 id="孤儿进程和僵尸进程"><a href="#孤儿进程和僵尸进程" class="headerlink" title="孤儿进程和僵尸进程"></a>孤儿进程和僵尸进程</h2><h3 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h3><p>父进程运行结束，但是子进程还在运行，这样的子进程称为孤儿进程。</p><p>每当孤儿进程出现的时候，内核会把其父进程设置为init，而init会循环的wait它的已退出的子进程。这样当一个孤儿进程死掉的时候，init会出面处理其善后工作。因此孤儿进程不会有危害。</p><h3 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h3><p>在Unix&#x2F;Linux操作系统中，僵尸进程（Zombie Process）是指已经完成执行（即进程已经退出），但其在进程表中仍然保留了一个记录（PCB）的进程。</p><p>产生僵尸进程的原因通常是<strong>父进程没有及时地对其子进程进行处理</strong>，也就是没有使用<code>wait()</code>或<code>waitpid()</code>等函数来等待子进程的结束，从而导致子进程成为僵尸进程。在这种情况下，子进程的进程表记录仍然存在，但是它已经不再占用系统资源，也无法进行任何操作。</p><p><strong>僵尸进程不会占用系统资源，但是如果僵尸进程太多，可能会占用大量的进程表项，导致进程表溢出。</strong>因此，应该尽量避免出现僵尸进程，方法是在父进程中及时调用<code>wait()</code>或<code>waitpid()</code>等函数，处理已经完成执行的子进程，释放相关的系统资源，从而避免僵尸进程的产生。</p><p><strong>另外，如果父进程不处理子进程的结束，而子进程的父进程又已经退出，那么子进程就会变成孤儿进程，</strong>这种情况下，操作系统会把子进程的父进程设置为进程1（init进程），从而避免出现僵尸进程。</p><h2 id="wait和waitpid进程回收"><a href="#wait和waitpid进程回收" class="headerlink" title="wait和waitpid进程回收"></a>wait和waitpid进程回收</h2><h3 id="wait函数"><a href="#wait函数" class="headerlink" title="wait函数"></a>wait函数</h3><p>![截屏2023-04-02 17.08.26](截屏2023-04-02 17.08.26-1135960.png)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    #include &lt;sys/types.h&gt;</span><br><span class="hljs-comment">    #include &lt;sys/wait.h&gt;</span><br><span class="hljs-comment">    pid_t wait(int *wstatus);</span><br><span class="hljs-comment">        功能：等待任意一个子进程结束，如果任意一个子进程结束了，次函数会回收子进程的资源。</span><br><span class="hljs-comment">        参数：int *wstatus</span><br><span class="hljs-comment">            进程退出时的状态信息，传入的是一个int类型的地址，传出参数。</span><br><span class="hljs-comment">        返回值：</span><br><span class="hljs-comment">            - 成功：返回被回收的子进程的id</span><br><span class="hljs-comment">            - 失败：-1 (所有的子进程都结束，调用函数失败)</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    调用wait函数的进程会被挂起（阻塞），直到它的一个子进程退出或者收到一个不能被忽略的信号时才被唤醒（相当于继续往下执行）</span><br><span class="hljs-comment">    如果没有子进程了，函数立刻返回，返回-1；如果子进程都已经结束了，也会立即返回，返回-1.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 父进程创建5个子进程</span><br>    <span class="hljs-type">pid_t</span> pid;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++)<br>    &#123;<br>        pid = fork();<br>        <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (pid &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> st = <span class="hljs-number">0</span>;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am parent, pid = %d\n&quot;</span>, getpid());<br>            <span class="hljs-comment">// int ret = wait(NULL);</span><br>            <span class="hljs-type">int</span> ret = wait(&amp;st);<br>            <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>)<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">// 是不是正常退出</span><br>            <span class="hljs-keyword">if</span> (WIFEXITED(st))<br>                <span class="hljs-comment">// 获取退出码</span><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child exit = %d\n&quot;</span>, WEXITSTATUS(st));<br>            <span class="hljs-comment">// 是不是异常退出</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (WIFSIGNALED(st))<br>                <span class="hljs-comment">// 获取信号值</span><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child signal = %d\n&quot;</span>, WTERMSIG(st));<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child die = %d\n&quot;</span>, ret);<br>            sleep(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">// while (1)</span><br>        <span class="hljs-comment">// &#123;</span><br>        <span class="hljs-comment">//     printf(&quot;I am child, pid = %d\n&quot;, getpid());</span><br>        <span class="hljs-comment">//     sleep(1);</span><br>        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am child, pid = %d\n&quot;</span>, getpid());<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p> ![截屏2023-04-02 17.33.32](截屏2023-04-02 17.33.32-1135960.png)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@iZ2zec9iqw5wve79bry35gZ:/home/clion/webserver/part_2# ./wait <br>I am parent, pid = 10117<br>I am child, pid = 10118<br>I am child, pid = 10119<br>child exit = 0<br>child die = 10118<br>I am parent, pid = 10117<br>child exit = 0<br>child die = 10119<br>I am parent, pid = 10117<br></code></pre></td></tr></table></figure><h3 id="waitpid函数"><a href="#waitpid函数" class="headerlink" title="waitpid函数"></a>waitpid函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-type">pid_t</span> <span class="hljs-title function_">waitpid</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid, <span class="hljs-type">int</span> *wstatus, <span class="hljs-type">int</span> options)</span>;<br></code></pre></td></tr></table></figure><p>回收指定进程号的子进程，可以设置为是否阻塞。</p><p>参数：</p><ul><li>pid：<ul><li>pid&gt;0，某个子进程；</li><li>&#x3D;0，回收当前进程组的所有子进程：由同一个父进程创建的（也会用到）</li><li>pid&#x3D;-1, 回收所有的子进程，和wait一样（最常用）</li><li>pid&lt;-1，某个子进程组的组id的绝对值，回收指定进程组的子进程</li></ul></li><li>options：设置阻塞或者非阻塞<ul><li>0：阻塞</li><li>WNOHANG：非阻塞</li></ul></li><li>返回值：<ul><li>大于0，返回子进程ID</li><li>等于0，options&#x3D;WNOHANG，表示还有子进程</li><li>等于-1，错误或者没有子进程了</li></ul></li></ul><h2 id="进程间通信（PPT-2-10）"><a href="#进程间通信（PPT-2-10）" class="headerlink" title="进程间通信（PPT-2.10）"></a>进程间通信（PPT-2.10）</h2><p>异步访问数据的时候容易产生数据安全的问题。</p><h3 id="匿名管道的使用"><a href="#匿名管道的使用" class="headerlink" title="匿名管道的使用"></a>匿名管道的使用</h3><h4 id="pipe-创建匿名管道"><a href="#pipe-创建匿名管道" class="headerlink" title="pipe()创建匿名管道"></a>pipe()创建匿名管道</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    #include &lt;unistd.h&gt;</span><br><span class="hljs-comment">    int pipe(int pipefd[2]);</span><br><span class="hljs-comment">        功能：创建一个匿名管道，用来进程间通信。</span><br><span class="hljs-comment">        参数：int pipefd[2] 这个数组是一个传出参数。</span><br><span class="hljs-comment">            pipefd[0] 对应的是管道的读端</span><br><span class="hljs-comment">            pipefd[1] 对应的是管道的写端</span><br><span class="hljs-comment">        返回值：</span><br><span class="hljs-comment">            成功 0</span><br><span class="hljs-comment">            失败 -1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    管道默认是阻塞的：如果管道中没有数据，read阻塞，如果管道满了，write阻塞</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    注意：匿名管道只能用于具有关系的进程之间的通信（父子进程，兄弟进程）</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 子进程发送数据给父进程，父进程读取到数据输出</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 在fork之前创建管道</span><br>    <span class="hljs-type">int</span> pipefd[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">int</span> ret = pipe(pipefd);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;pipe&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-comment">// 创建子进程</span><br>    <span class="hljs-type">pid_t</span> pid = fork();<br>    <span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 父进程</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i am parent process, pid : %d\n&quot;</span>, getpid());<br>        <span class="hljs-comment">// 关闭写端</span><br>        close(pipefd[<span class="hljs-number">1</span>]);<br>        <span class="hljs-comment">// 从管道的读取端读取数据</span><br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-type">int</span> len = read(pipefd[<span class="hljs-number">0</span>], buf, <span class="hljs-keyword">sizeof</span>(buf));<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;parent recv : %s, pid : %d\n&quot;</span>, buf, getpid());<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">// 子进程</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i am child process, pid : %d\n&quot;</span>, getpid());<br>        <span class="hljs-comment">// 关闭读端</span><br>        close(pipefd[<span class="hljs-number">0</span>]);<br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">// 向管道中写入数据</span><br>            <span class="hljs-type">char</span> * str = <span class="hljs-string">&quot;hello,i am child&quot;</span>;<br>            write(pipefd[<span class="hljs-number">1</span>], str, <span class="hljs-built_in">strlen</span>(str));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果不加sleep()人为控制读写，则会出现子进程写数据后紧接着读数据，结果读到了自己发送的数据。</p><p>这是因为管道是一个文件，相当于在一个文件上又读又写。</p><p><img src="/2023/06/03/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/pipe-1135960.jpg" alt="pipe"></p><p><strong>所以在正常开发的情况下，管道的数据流向只有一个，不会又读又写！！</strong></p><p>所以在上面的代码中，会主动关闭不用的那一端！</p><hr><h4 id="fpathconf-获取管道大小"><a href="#fpathconf-获取管道大小" class="headerlink" title="fpathconf()获取管道大小"></a>fpathconf()获取管道大小</h4><p><code>ulimit -a</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> pipefd[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">int</span> ret = pipe(pipefd);<br>    <span class="hljs-comment">// 获取管道的大小</span><br>    <span class="hljs-type">long</span> size = fpathconf(pipefd[<span class="hljs-number">0</span>], _PC_PIPE_BUF);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pipe size : %ld\n&quot;</span>, size);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="匿名管道使用案例"><a href="#匿名管道使用案例" class="headerlink" title="匿名管道使用案例"></a>匿名管道使用案例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    实现 ps aux | grep xxx 父子进程间通信</span><br><span class="hljs-comment">    子进程： ps aux, 子进程结束后，将数据发送给父进程</span><br><span class="hljs-comment">    父进程：获取到数据，过滤</span><br><span class="hljs-comment">    pipe()</span><br><span class="hljs-comment">    execlp()</span><br><span class="hljs-comment">    子进程将标准输出 stdout_fileno 重定向到管道的写端。  dup2</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;wait.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 创建一个管道</span><br>    <span class="hljs-type">int</span> fd[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">int</span> ret = pipe(fd);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;pipe&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-comment">// 创建子进程</span><br>    <span class="hljs-type">pid_t</span> pid = fork();<br>    <span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 父进程</span><br>        <span class="hljs-comment">// 关闭写端</span><br>        close(fd[<span class="hljs-number">1</span>]);<br>        <span class="hljs-comment">// 从管道中读取</span><br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-type">int</span> len = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>((len = read(fd[<span class="hljs-number">0</span>], buf, <span class="hljs-keyword">sizeof</span>(buf) - <span class="hljs-number">1</span>)) &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 过滤数据输出</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, buf);<br>            <span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, <span class="hljs-number">1024</span>);<br>        &#125;<br>        wait(<span class="hljs-literal">NULL</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 子进程</span><br>        <span class="hljs-comment">// 关闭读端</span><br>        close(fd[<span class="hljs-number">0</span>]);<br>        <span class="hljs-comment">// 文件描述符的重定向 stdout_fileno -&gt; fd[1]</span><br>        dup2(fd[<span class="hljs-number">1</span>], STDOUT_FILENO);<br>        <span class="hljs-comment">// 执行 ps aux</span><br>        execlp(<span class="hljs-string">&quot;ps&quot;</span>, <span class="hljs-string">&quot;ps&quot;</span>, <span class="hljs-string">&quot;aux&quot;</span>, <span class="hljs-literal">NULL</span>);<br>        perror(<span class="hljs-string">&quot;execlp&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        perror(<span class="hljs-string">&quot;fork&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="匿名管道的读写特点："><a href="#匿名管道的读写特点：" class="headerlink" title="匿名管道的读写特点："></a>匿名管道的读写特点：</h3><p>使用管道时，需要注意以下几种特殊的情况（假设都是阻塞I&#x2F;O操作）<br>1.所有的指向管道写端的文件描述符都关闭了（管道写端引用计数为0），有进程从管道的读端<br>读数据，那么管道中剩余的数据被读取以后，再次read会返回0，就像读到文件末尾一样。</p><p>2.如果有指向管道写端的文件描述符没有关闭（管道的写端引用计数大于0），而持有管道写端的进程<br>也没有往管道中写数据，这个时候有进程从管道中读取数据，那么管道中剩余的数据被读取后，<br>再次read会阻塞，直到管道中有数据可以读了才读取数据并返回。</p><p>3.如果所有指向管道读端的文件描述符都关闭了（管道的读端引用计数为0），这个时候有进程<br>向管道中写数据，那么该进程会收到一个信号SIGPIPE, 通常会导致进程异常终止。</p><p>4.如果有指向管道读端的文件描述符没有关闭（管道的读端引用计数大于0），而持有管道读端的进程<br>也没有从管道中读数据，这时有进程向管道中写数据，那么在管道被写满的时候再次write会阻塞，<br>直到管道中有空位置才能再次写入数据并返回。</p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>​    读管道：<br>​        管道中有数据，read返回实际读到的字节数。<br>​        管道中无数据：<br>​            写端被全部关闭，read返回0（相当于读到文件的末尾）<br>​            写端没有完全关闭，read阻塞等待</p><p>​写管道：<br>​管道读端全部被关闭，进程异常终止（进程收到SIGPIPE信号）<br>​管道读端没有全部关闭：<br>​    管道已满，write阻塞<br>​    管道没有满，write将数据写入，并返回实际写入的字节数</p><h3 id="有名管道（FIFO）"><a href="#有名管道（FIFO）" class="headerlink" title="有名管道（FIFO）"></a>有名管道（FIFO）</h3><h4 id="创建FIFO—-mkfifo"><a href="#创建FIFO—-mkfifo" class="headerlink" title="创建FIFO—-mkfifo();"></a>创建FIFO—-mkfifo();</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    创建fifo文件</span><br><span class="hljs-comment">    1.通过命令： mkfifo 名字</span><br><span class="hljs-comment">    2.通过函数：int mkfifo(const char *pathname, mode_t mode);</span><br><span class="hljs-comment">    #include &lt;sys/types.h&gt;</span><br><span class="hljs-comment">    #include &lt;sys/stat.h&gt;</span><br><span class="hljs-comment">    int mkfifo(const char *pathname, mode_t mode);</span><br><span class="hljs-comment">        参数：</span><br><span class="hljs-comment">            - pathname: 管道名称的路径</span><br><span class="hljs-comment">            - mode: 文件的权限 和 open 的 mode 是一样的</span><br><span class="hljs-comment">                    是一个八进制的数</span><br><span class="hljs-comment">        返回值：成功返回0，失败返回-1，并设置错误号</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 判断文件是否存在</span><br>    <span class="hljs-type">int</span> ret = access(<span class="hljs-string">&quot;fifo1&quot;</span>, F_OK);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;管道不存在，创建管道\n&quot;</span>); <br>        ret = mkfifo(<span class="hljs-string">&quot;fifo1&quot;</span>, <span class="hljs-number">0664</span>);<br>        <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) &#123;<br>            perror(<span class="hljs-string">&quot;mkfifo&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        &#125;       <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="read"><a href="#read" class="headerlink" title="read()"></a>read()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-comment">// 从管道中读取数据</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 1.打开管道文件</span><br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;test&quot;</span>, O_RDONLY);<br>    <span class="hljs-keyword">if</span>(fd == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;open&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-comment">// 读数据</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-type">int</span> len = read(fd, buf, <span class="hljs-keyword">sizeof</span>(buf));<br>        <span class="hljs-keyword">if</span>(len == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;写端断开连接了...\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;recv buf : %s\n&quot;</span>, buf);<br>    &#125;<br>    close(fd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="write"><a href="#write" class="headerlink" title="write()"></a>write()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-comment">// 向管道中写数据</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    有名管道的注意事项：</span><br><span class="hljs-comment">        1.一个为只读而打开一个管道的进程会阻塞，直到另外一个进程为只写打开管道</span><br><span class="hljs-comment">        2.一个为只写而打开一个管道的进程会阻塞，直到另外一个进程为只读打开管道</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    读管道：</span><br><span class="hljs-comment">        管道中有数据，read返回实际读到的字节数</span><br><span class="hljs-comment">        管道中无数据：</span><br><span class="hljs-comment">            管道写端被全部关闭，read返回0，（相当于读到文件末尾）</span><br><span class="hljs-comment">            写端没有全部被关闭，read阻塞等待</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    写管道：</span><br><span class="hljs-comment">        管道读端被全部关闭，进行异常终止（收到一个SIGPIPE信号）</span><br><span class="hljs-comment">        管道读端没有全部关闭：</span><br><span class="hljs-comment">            管道已经满了，write会阻塞</span><br><span class="hljs-comment">            管道没有满，write将数据写入，并返回实际写入的字节数。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 1.判断文件是否存在</span><br>    <span class="hljs-type">int</span> ret = access(<span class="hljs-string">&quot;test&quot;</span>, F_OK);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;管道不存在，创建管道\n&quot;</span>);<br>        <br>        <span class="hljs-comment">// 2.创建管道文件</span><br>        ret = mkfifo(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-number">0664</span>);<br><br>        <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) &#123;<br>            perror(<span class="hljs-string">&quot;mkfifo&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        &#125;       <br>    &#125;<br>    <span class="hljs-comment">// 3.以只写的方式打开管道</span><br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;test&quot;</span>, O_WRONLY);<br>    <span class="hljs-keyword">if</span>(fd == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;open&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-comment">// 写数据</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>];<br>        <span class="hljs-built_in">sprintf</span>(buf, <span class="hljs-string">&quot;hello, %d\n&quot;</span>, i);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;write data : %s\n&quot;</span>, buf);<br>        write(fd, buf, <span class="hljs-built_in">strlen</span>(buf));<br>        sleep(<span class="hljs-number">1</span>);<br>    &#125;<br>    close(fd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="FIFO实现聊天"><a href="#FIFO实现聊天" class="headerlink" title="FIFO实现聊天"></a>FIFO实现聊天</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 判断写是否存在</span><br>    <span class="hljs-type">int</span> ret_A = access(<span class="hljs-string">&quot;fifoA&quot;</span>, F_OK);<br>    <span class="hljs-keyword">if</span> (ret_A == <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;文件不存在，创建文件\n&quot;</span>);<br>        ret_A = mkfifo(<span class="hljs-string">&quot;fifoA&quot;</span>, <span class="hljs-number">0664</span>);<br>        <span class="hljs-keyword">if</span> (ret_A == <span class="hljs-number">-1</span>)<br>        &#123;<br>            perror(<span class="hljs-string">&quot;mkfifo&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> fd_A = open(<span class="hljs-string">&quot;fifoA&quot;</span>, O_WRONLY);<br>    <span class="hljs-keyword">if</span> (fd_A == <span class="hljs-number">-1</span>)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;open&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-type">int</span> ret_B = access(<span class="hljs-string">&quot;fifoB&quot;</span>, F_OK);<br>    <span class="hljs-keyword">if</span> (ret_B == <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;文件不存在，创建文件\n&quot;</span>);<br>        ret_B = mkfifo(<span class="hljs-string">&quot;fifoB&quot;</span>, <span class="hljs-number">0664</span>);<br>        <span class="hljs-keyword">if</span> (ret_B == <span class="hljs-number">-1</span>)<br>        &#123;<br>            perror(<span class="hljs-string">&quot;mkfifo&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> fd_B = open(<span class="hljs-string">&quot;fifoB&quot;</span>, O_RDONLY);<br>    <span class="hljs-keyword">if</span> (fd_B == <span class="hljs-number">-1</span>)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;open&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">128</span>];<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, <span class="hljs-number">128</span>);<br>        fgets(buf, <span class="hljs-number">128</span>, <span class="hljs-built_in">stdin</span>);<br>        ret_A = write(fd_A, buf, <span class="hljs-built_in">strlen</span>(buf));<br>        <span class="hljs-keyword">if</span> (ret_A == <span class="hljs-number">-1</span>)<br>        &#123;<br>            perror(<span class="hljs-string">&quot;write&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, <span class="hljs-number">128</span>);<br>        ret_B = read(fd_B, buf, <span class="hljs-number">128</span>);<br>        <span class="hljs-keyword">if</span>(ret_B&lt;=<span class="hljs-number">0</span>)&#123;<br>            perror(<span class="hljs-string">&quot;read&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;A recv : %s\n&quot;</span>,buf);<br>    &#125;<br>    close(fd_A);<br>    close(fd_B);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    #include &lt;sys/mman.h&gt;</span><br><span class="hljs-comment">    void *mmap(void *addr, size_t length, int prot, int flags,int fd, off_t offset);</span><br><span class="hljs-comment">        - 功能：将一个文件或者设备的数据映射到内存中</span><br><span class="hljs-comment">        - 参数：</span><br><span class="hljs-comment">            - void *addr: NULL, 由内核指定</span><br><span class="hljs-comment">            - length : 要映射的数据的长度，这个值不能为0。建议使用文件的长度。</span><br><span class="hljs-comment">                    获取文件的长度：stat lseek</span><br><span class="hljs-comment">            - prot : 对申请的内存映射区的操作权限</span><br><span class="hljs-comment">                -PROT_EXEC ：可执行的权限</span><br><span class="hljs-comment">                -PROT_READ ：读权限</span><br><span class="hljs-comment">                -PROT_WRITE ：写权限</span><br><span class="hljs-comment">                -PROT_NONE ：没有权限</span><br><span class="hljs-comment">                要操作映射内存，必须要有读的权限。</span><br><span class="hljs-comment">                PROT_READ、PROT_READ|PROT_WRITE</span><br><span class="hljs-comment">            - flags :</span><br><span class="hljs-comment">                - MAP_SHARED : 映射区的数据会自动和磁盘文件进行同步，进程间通信，必须要设置这个选项</span><br><span class="hljs-comment">                - MAP_PRIVATE ：不同步，内存映射区的数据改变了，对原来的文件不会修改，会重新创建一个新的文件。（copy on write）</span><br><span class="hljs-comment">            - fd: 需要映射的那个文件的文件描述符</span><br><span class="hljs-comment">                - 通过open得到，open的是一个磁盘文件</span><br><span class="hljs-comment">                - 注意：文件的大小不能为0，open指定的权限不能和prot参数有冲突。</span><br><span class="hljs-comment">                    prot: PROT_READ                open:只读/读写 </span><br><span class="hljs-comment">                    prot: PROT_READ | PROT_WRITE   open:读写</span><br><span class="hljs-comment">            - offset：偏移量，一般不用。必须指定的是4k的整数倍，0表示不偏移。</span><br><span class="hljs-comment">        - 返回值：返回创建的内存的首地址</span><br><span class="hljs-comment">            失败返回MAP_FAILED，(void *) -1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    int munmap(void *addr, size_t length);</span><br><span class="hljs-comment">        - 功能：释放内存映射</span><br><span class="hljs-comment">        - 参数：</span><br><span class="hljs-comment">            - addr : 要释放的内存的首地址</span><br><span class="hljs-comment">            - length : 要释放的内存的大小，要和mmap函数中的length参数的值一样。</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    使用内存映射实现进程间通信：</span><br><span class="hljs-comment">    1.有关系的进程（父子进程）</span><br><span class="hljs-comment">        - 还没有子进程的时候</span><br><span class="hljs-comment">            - 通过唯一的父进程，先创建内存映射区</span><br><span class="hljs-comment">        - 有了内存映射区以后，创建子进程</span><br><span class="hljs-comment">        - 父子进程共享创建的内存映射区</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    2.没有关系的进程间通信</span><br><span class="hljs-comment">        - 准备一个大小不是0的磁盘文件</span><br><span class="hljs-comment">        - 进程1 通过磁盘文件创建内存映射区</span><br><span class="hljs-comment">            - 得到一个操作这块内存的指针</span><br><span class="hljs-comment">        - 进程2 通过磁盘文件创建内存映射区</span><br><span class="hljs-comment">            - 得到一个操作这块内存的指针</span><br><span class="hljs-comment">        - 使用内存映射区通信</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    注意：内存映射区通信，是非阻塞。</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;wait.h&gt;</span></span><br><br><span class="hljs-comment">// 作业:使用内存映射实现没有关系的进程间的通信。</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-comment">// 1.打开一个文件</span><br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;test.txt&quot;</span>, O_RDWR);<br>    <span class="hljs-type">int</span> size = lseek(fd, <span class="hljs-number">0</span>, SEEK_END);  <span class="hljs-comment">// 获取文件的大小</span><br><br>    <span class="hljs-comment">// 2.创建内存映射区</span><br>    <span class="hljs-type">void</span> *ptr = mmap(<span class="hljs-literal">NULL</span>, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span>(ptr == MAP_FAILED) &#123;<br>        perror(<span class="hljs-string">&quot;mmap&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 3.创建子进程</span><br>    <span class="hljs-type">pid_t</span> pid = fork();<br>    <span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>) &#123;<br>        wait(<span class="hljs-literal">NULL</span>);<br>        <span class="hljs-comment">// 父进程</span><br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">64</span>];<br>        <span class="hljs-built_in">strcpy</span>(buf, (<span class="hljs-type">char</span> *)ptr);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;read data : %s\n&quot;</span>, buf);<br>       <br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">// 子进程</span><br>        <span class="hljs-built_in">strcpy</span>((<span class="hljs-type">char</span> *)ptr, <span class="hljs-string">&quot;nihao a, son!!!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 关闭内存映射区</span><br>    munmap(ptr, size);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="内存映射注意事项"><a href="#内存映射注意事项" class="headerlink" title="内存映射注意事项"></a>内存映射注意事项</h4><ul><li>如果对mmap的返回值(ptr)做++操作(ptr++), munmap是否能够成功?</li></ul><p>void * ptr &#x3D; mmap(…);<br>ptr++;  可以对其进行++操作<br>munmap(ptr, len);   &#x2F;&#x2F; 错误,要保存地址</p><ul><li>如果open时O_RDONLY, mmap时prot参数指定PROT_READ | PROT_WRITE会怎样?</li></ul><p>错误，返回MAP_FAILED<br>open()函数中的权限建议和prot参数的权限保持一致。</p><p>3.如果文件偏移量为1000会怎样?</p><p>偏移量必须是4K的整数倍，返回MAP_FAILED</p><p>4.mmap什么情况下会调用失败?<br>    - 第二个参数：length &#x3D; 0<br>    - 第三个参数：prot<br>        - 只指定了写权限<br>        - prot PROT_READ | PROT_WRITE<br>          第5个参数fd 通过open函数时指定的 O_RDONLY &#x2F; O_WRONLY</p><p>5.可以open的时候O_CREAT一个新文件来创建映射区吗?<br>    - 可以的，但是创建的文件的大小如果为0的话，肯定不行<br>        - 可以对新的文件进行扩展<br>        - lseek()<br>        - truncate()</p><p>6.mmap后关闭文件描述符，对mmap映射有没有影响？<br>    int fd &#x3D; open(“XXX”);<br>    mmap(,,,,fd,0);<br>    close(fd);<br>    映射区还存在，创建映射区的fd被关闭，没有任何影响。</p><p>7.对ptr越界操作会怎样？<br>void * ptr &#x3D; mmap(NULL, 100,,,,,);<br>4K<br>越界操作操作的是非法的内存 -&gt; 段错误</p><h4 id="使用内存映射实现文件复制功能"><a href="#使用内存映射实现文件复制功能" class="headerlink" title="使用内存映射实现文件复制功能"></a>使用内存映射实现文件复制功能</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// 使用内存映射完成文件拷贝</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    1.对原始文件进行内存映射</span><br><span class="hljs-comment">    2.创建新文件，并将其扩展到原始文件的大小</span><br><span class="hljs-comment">    3.将新文件映射到内存中</span><br><span class="hljs-comment">    4.将原始文件的内容拷贝到新文件中</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 对原始文件进行映射,出现create mmap error: Permission denied的原因是大部分的硬件设计都不支持在没有读取权限的情况下执行写操作。(或者你可以理解为mmap把文件的内容读到内存时隐含了一次读取操作)</span><br>    <span class="hljs-comment">// s所以在open中应该使用O_RDWR代替</span><br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;english.txt&quot;</span>, O_RDWR);<br>    <span class="hljs-keyword">if</span> (fd == <span class="hljs-number">-1</span>)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;open&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-type">int</span> new_fd = open(<span class="hljs-string">&quot;cpy.txt&quot;</span>, O_RDWR | O_CREAT, <span class="hljs-number">0664</span>);<br>    <span class="hljs-keyword">if</span> (new_fd == <span class="hljs-number">-1</span>)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;open&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-comment">// 对新文件进行扩</span><br>    <span class="hljs-type">size_t</span> size = lseek(fd, <span class="hljs-number">0</span>, SEEK_END);<br>    truncate(<span class="hljs-string">&quot;cpy.txt&quot;</span>, size);<br>    write(new_fd, <span class="hljs-string">&quot; &quot;</span>, <span class="hljs-number">1</span>);<br>    <span class="hljs-type">void</span> *ptr = mmap(<span class="hljs-literal">NULL</span>, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="hljs-number">0</span>);<br>    <span class="hljs-type">void</span> *ptr1 = mmap(<span class="hljs-literal">NULL</span>, size, PROT_READ | PROT_WRITE, MAP_SHARED, new_fd, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (ptr == MAP_FAILED)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;mmap&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (ptr1 == MAP_FAILED)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;mapp&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-built_in">memcpy</span>(ptr1, ptr, size);<br>    munmap(ptr1, size);<br>    munmap(ptr, size);<br>    close(fd);<br>    close(new_fd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><h4 id="kill"><a href="#kill" class="headerlink" title="kill()"></a>kill()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*  </span><br><span class="hljs-comment">    #include &lt;sys/types.h&gt;</span><br><span class="hljs-comment">    #include &lt;signal.h&gt;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    int kill(pid_t pid, int sig);</span><br><span class="hljs-comment">        - 功能：给任何的进程或者进程组pid, 发送任何的信号 sig</span><br><span class="hljs-comment">        - 参数：</span><br><span class="hljs-comment">            - pid ：</span><br><span class="hljs-comment">                &gt; 0 : 将信号发送给指定的进程</span><br><span class="hljs-comment">                = 0 : 将信号发送给当前的进程组</span><br><span class="hljs-comment">                = -1 : 将信号发送给每一个有权限接收这个信号的进程</span><br><span class="hljs-comment">                &lt; -1 : 这个pid=某个进程组的ID取反 （-12345）</span><br><span class="hljs-comment">            - sig : 需要发送的信号的编号或者是宏值，0表示不发送任何信号</span><br><span class="hljs-comment">        kill(getppid(), 9);</span><br><span class="hljs-comment">        kill(getpid(), 9);</span><br><span class="hljs-comment">        </span><br><span class="hljs-comment">    int raise(int sig);</span><br><span class="hljs-comment">        - 功能：给当前进程发送信号</span><br><span class="hljs-comment">        - 参数：</span><br><span class="hljs-comment">            - sig : 要发送的信号</span><br><span class="hljs-comment">        - 返回值：</span><br><span class="hljs-comment">            - 成功 0</span><br><span class="hljs-comment">            - 失败 非0</span><br><span class="hljs-comment">        kill(getpid(), sig);   </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    void abort(void);</span><br><span class="hljs-comment">        - 功能： 发送SIGABRT信号给当前的进程，杀死当前进程</span><br><span class="hljs-comment">        kill(getpid(), SIGABRT);</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-type">pid_t</span> pid = fork();<br><br>    <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 子进程</span><br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child process\n&quot;</span>);<br>            sleep(<span class="hljs-number">1</span>);<br>        &#125;<br><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 父进程</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;parent process\n&quot;</span>);<br>        sleep(<span class="hljs-number">2</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;kill child process now\n&quot;</span>);<br>        kill(pid, SIGINT);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="要操作core文件"><a href="#要操作core文件" class="headerlink" title="要操作core文件"></a>要操作core文件</h4><p>需要使用ulimit 给它分配大小，同时在编译程序的时候➕上-g ，调试命令</p><h4 id="alarm-函数"><a href="#alarm-函数" class="headerlink" title="alarm()函数"></a>alarm()函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    #include &lt;unistd.h&gt;</span><br><span class="hljs-comment">    unsigned int alarm(unsigned int seconds);</span><br><span class="hljs-comment">        - 功能：设置定时器（闹钟）。函数调用，开始倒计时，当倒计时为0的时候，</span><br><span class="hljs-comment">                函数会给当前的进程发送一个信号：SIGALARM</span><br><span class="hljs-comment">        - 参数：</span><br><span class="hljs-comment">            seconds: 倒计时的时长，单位：秒。如果参数为0，定时器无效（不进行倒计时，不发信号）。</span><br><span class="hljs-comment">                    取消一个定时器，通过alarm(0)。</span><br><span class="hljs-comment">        - 返回值：</span><br><span class="hljs-comment">            - 之前没有定时器，返回0</span><br><span class="hljs-comment">            - 之前有定时器，返回之前的定时器剩余的时间</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    - SIGALARM ：默认终止当前的进程，每一个进程都有且只有唯一的一个定时器。</span><br><span class="hljs-comment">        alarm(10);  -&gt; 返回0</span><br><span class="hljs-comment">        过了1秒</span><br><span class="hljs-comment">        alarm(5);   -&gt; 返回9</span><br><span class="hljs-comment">  alarm(100) -&gt; 该函数是不阻塞的</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> seconds = alarm(<span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;seconds = %d\n&quot;</span>, seconds);  <span class="hljs-comment">// 0</span><br>    sleep(<span class="hljs-number">2</span>);<br>    seconds = alarm(<span class="hljs-number">2</span>);    <span class="hljs-comment">// 不阻塞</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;seconds = %d\n&quot;</span>, seconds);  <span class="hljs-comment">// 3</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际的时间 &#x3D; 内核时间 + 用户时间 + 消耗的时间<br>进行文件IO操作的时候比较浪费时间</p><p>定时器，与进程的状态无关（自然定时法）。无论进程处于什么状态，alarm都会计时。</p><h4 id="setitimer"><a href="#setitimer" class="headerlink" title="setitimer()"></a>setitimer()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    #include &lt;sys/time.h&gt;</span><br><span class="hljs-comment">    int setitimer(int which, const struct itimerval *new_value,</span><br><span class="hljs-comment">                        struct itimerval *old_value);</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">        - 功能：设置定时器（闹钟）。可以替代alarm函数。精度微妙us，可以实现周期性定时</span><br><span class="hljs-comment">        - 参数：</span><br><span class="hljs-comment">            - which : 定时器以什么时间计时</span><br><span class="hljs-comment">              ITIMER_REAL: 真实时间，时间到达，发送 SIGALRM   常用</span><br><span class="hljs-comment">              ITIMER_VIRTUAL: 用户时间，时间到达，发送 SIGVTALRM</span><br><span class="hljs-comment">              ITIMER_PROF: 以该进程在用户态和内核态下所消耗的时间来计算，时间到达，发送 SIGPROF</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">            - new_value: 设置定时器的属性</span><br><span class="hljs-comment">            </span><br><span class="hljs-comment">                struct itimerval &#123;      // 定时器的结构体</span><br><span class="hljs-comment">                struct timeval it_interval;  // 每个阶段的时间，间隔时间</span><br><span class="hljs-comment">                struct timeval it_value;     // 延迟多长时间执行定时器</span><br><span class="hljs-comment">                &#125;;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">                struct timeval &#123;        // 时间的结构体</span><br><span class="hljs-comment">                    time_t      tv_sec;     //  秒数     </span><br><span class="hljs-comment">                    suseconds_t tv_usec;    //  微秒    </span><br><span class="hljs-comment">                &#125;;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">            过10秒后，每个2秒定时一次</span><br><span class="hljs-comment">           </span><br><span class="hljs-comment">            - old_value ：记录上一次的定时的时间参数，一般不使用，指定NULL</span><br><span class="hljs-comment">        </span><br><span class="hljs-comment">        - 返回值：</span><br><span class="hljs-comment">            成功 0</span><br><span class="hljs-comment">            失败 -1 并设置错误号</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-comment">// 过3秒以后，每隔2秒钟定时一次</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">itimerval</span> <span class="hljs-title">new_value</span>;</span><br>    <span class="hljs-comment">// 设置间隔的时间</span><br>    new_value.it_interval.tv_sec = <span class="hljs-number">2</span>;<br>    new_value.it_interval.tv_usec = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 设置延迟的时间,3秒之后开始第一次定时</span><br>    new_value.it_value.tv_sec = <span class="hljs-number">3</span>;<br>    new_value.it_value.tv_usec = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> ret = setitimer(ITIMER_REAL, &amp;new_value, <span class="hljs-literal">NULL</span>); <span class="hljs-comment">// 非阻塞的</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;定时器开始了...\n&quot;</span>);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;setitimer&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    getchar();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="信号捕捉"><a href="#信号捕捉" class="headerlink" title="信号捕捉"></a>信号捕捉</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    #include &lt;signal.h&gt;</span><br><span class="hljs-comment">    typedef void (*sighandler_t)(int);</span><br><span class="hljs-comment">    sighandler_t signal(int signum, sighandler_t handler);</span><br><span class="hljs-comment">        - 功能：设置某个信号的捕捉行为</span><br><span class="hljs-comment">        - 参数：</span><br><span class="hljs-comment">            - signum: 要捕捉的信号</span><br><span class="hljs-comment">            - handler: 捕捉到信号要如何处理</span><br><span class="hljs-comment">                - SIG_IGN ： 忽略信号</span><br><span class="hljs-comment">                - SIG_DFL ： 使用信号默认的行为</span><br><span class="hljs-comment">                - 回调函数 :  这个函数是内核调用，程序员只负责写，捕捉到信号后如何去处理信号。</span><br><span class="hljs-comment">                回调函数：</span><br><span class="hljs-comment">                    - 需要程序员实现，提前准备好的，函数的类型根据实际需求，看函数指针的定义</span><br><span class="hljs-comment">                    - 不是程序员调用，而是当信号产生，由内核调用</span><br><span class="hljs-comment">                    - 函数指针是实现回调的手段，函数实现之后，将函数名放到函数指针的位置就可以了。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        - 返回值：</span><br><span class="hljs-comment">            成功，返回上一次注册的信号处理函数的地址。第一次调用返回NULL</span><br><span class="hljs-comment">            失败，返回SIG_ERR，设置错误号</span><br><span class="hljs-comment">            </span><br><span class="hljs-comment">    SIGKILL SIGSTOP不能被捕捉，不能被忽略。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">myalarm</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;捕捉到了信号的编号是：%d\n&quot;</span>, num);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;xxxxxxx\n&quot;</span>);<br>&#125;<br><span class="hljs-comment">// 过3秒以后，每隔2秒钟定时一次</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 注册信号捕捉</span><br>    <span class="hljs-comment">// signal(SIGALRM, SIG_IGN);</span><br>    <span class="hljs-comment">// signal(SIGALRM, SIG_DFL);</span><br>    <span class="hljs-comment">// void (*sighandler_t)(int); 函数指针，int类型的参数表示捕捉到的信号的值。</span><br>    signal(SIGALRM, myalarm);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">itimerval</span> <span class="hljs-title">new_value</span>;</span><br>   <span class="hljs-comment">// 设置间隔的时间</span><br>    new_value.it_interval.tv_sec = <span class="hljs-number">2</span>;<br>    new_value.it_interval.tv_usec = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 设置延迟的时间,3秒之后开始第一次定时</span><br>    new_value.it_value.tv_sec = <span class="hljs-number">3</span>;<br>    new_value.it_value.tv_usec = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> ret = setitimer(ITIMER_REAL, &amp;new_value, <span class="hljs-literal">NULL</span>); <span class="hljs-comment">// 非阻塞的</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;定时器开始了...\n&quot;</span>);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;setitimer&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    getchar();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="信号集及相关函数"><a href="#信号集及相关函数" class="headerlink" title="信号集及相关函数"></a>信号集及相关函数</h4><p>1.用户通过键盘  Ctrl + C, 产生2号信号SIGINT (信号被创建)</p><p>2.信号产生但是没有被处理 （未决）<br>    - 在内核中将所有的没有被处理的信号存储在一个集合中 （未决信号集）<br>        - SIGINT信号状态被存储在第二个标志位上<br>        - 这个标志位的值为0， 说明信号不是未决状态<br>        - 这个标志位的值为1， 说明信号处于未决状态</p><p>3.这个未决状态的信号，需要被处理，处理之前需要和另一个信号集（阻塞信号集），进行比较<br>    - 阻塞信号集默认不阻塞任何的信号<br>        - 如果想要阻塞某些信号需要用户调用系统的API</p><p>4.在处理的时候和阻塞信号集中的标志位进行查询，看是不是对该信号设置阻塞了<br>    - 如果没有阻塞，这个信号就被处理<br>        - 如果阻塞了，这个信号就继续处于未决状态，直到阻塞解除，这个信号就被处理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    以下信号集相关的函数都是对自定义的信号集进行操作。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    int sigemptyset(sigset_t *set);</span><br><span class="hljs-comment">        - 功能：清空信号集中的数据,将信号集中的所有的标志位置为0</span><br><span class="hljs-comment">        - 参数：set,传出参数，需要操作的信号集</span><br><span class="hljs-comment">        - 返回值：成功返回0， 失败返回-1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    int sigfillset(sigset_t *set);</span><br><span class="hljs-comment">        - 功能：将信号集中的所有的标志位置为1</span><br><span class="hljs-comment">        - 参数：set,传出参数，需要操作的信号集</span><br><span class="hljs-comment">        - 返回值：成功返回0， 失败返回-1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    int sigaddset(sigset_t *set, int signum);</span><br><span class="hljs-comment">        - 功能：设置信号集中的某一个信号对应的标志位为1，表示阻塞这个信号</span><br><span class="hljs-comment">        - 参数：</span><br><span class="hljs-comment">            - set：传出参数，需要操作的信号集</span><br><span class="hljs-comment">            - signum：需要设置阻塞的那个信号</span><br><span class="hljs-comment">        - 返回值：成功返回0， 失败返回-1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    int sigdelset(sigset_t *set, int signum);</span><br><span class="hljs-comment">        - 功能：设置信号集中的某一个信号对应的标志位为0，表示不阻塞这个信号</span><br><span class="hljs-comment">        - 参数：</span><br><span class="hljs-comment">            - set：传出参数，需要操作的信号集</span><br><span class="hljs-comment">            - signum：需要设置不阻塞的那个信号</span><br><span class="hljs-comment">        - 返回值：成功返回0， 失败返回-1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    int sigismember(const sigset_t *set, int signum);</span><br><span class="hljs-comment">        - 功能：判断某个信号是否阻塞</span><br><span class="hljs-comment">        - 参数：</span><br><span class="hljs-comment">            - set：需要操作的信号集</span><br><span class="hljs-comment">            - signum：需要判断的那个信号</span><br><span class="hljs-comment">        - 返回值：</span><br><span class="hljs-comment">            1 ： signum被阻塞</span><br><span class="hljs-comment">            0 ： signum不阻塞</span><br><span class="hljs-comment">            -1 ： 失败</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-comment">// 创建一个信号集</span><br>    <span class="hljs-type">sigset_t</span> <span class="hljs-built_in">set</span>;<br><br>    <span class="hljs-comment">// 清空信号集的内容</span><br>    sigemptyset(&amp;<span class="hljs-built_in">set</span>);<br><br>    <span class="hljs-comment">// 判断 SIGINT 是否在信号集 set 里</span><br>    <span class="hljs-type">int</span> ret = sigismember(&amp;<span class="hljs-built_in">set</span>, SIGINT);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SIGINT 不阻塞\n&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SIGINT 阻塞\n&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 添加几个信号到信号集中</span><br>    sigaddset(&amp;<span class="hljs-built_in">set</span>, SIGINT);<br>    sigaddset(&amp;<span class="hljs-built_in">set</span>, SIGQUIT);<br><br>    <span class="hljs-comment">// 判断SIGINT是否在信号集中</span><br>    ret = sigismember(&amp;<span class="hljs-built_in">set</span>, SIGINT);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SIGINT 不阻塞\n&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SIGINT 阻塞\n&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 判断SIGQUIT是否在信号集中</span><br>    ret = sigismember(&amp;<span class="hljs-built_in">set</span>, SIGQUIT);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SIGQUIT 不阻塞\n&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SIGQUIT 阻塞\n&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 从信号集中删除一个信号</span><br>    sigdelset(&amp;<span class="hljs-built_in">set</span>, SIGQUIT);<br><br>    <span class="hljs-comment">// 判断SIGQUIT是否在信号集中</span><br>    ret = sigismember(&amp;<span class="hljs-built_in">set</span>, SIGQUIT);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SIGQUIT 不阻塞\n&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SIGQUIT 阻塞\n&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="sigprocmask"><a href="#sigprocmask" class="headerlink" title="sigprocmask()"></a>sigprocmask()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);</span><br><span class="hljs-comment">        - 功能：将自定义信号集中的数据设置到内核中（设置阻塞，解除阻塞，替换）</span><br><span class="hljs-comment">        - 参数：</span><br><span class="hljs-comment">            - how : 如何对内核阻塞信号集进行处理</span><br><span class="hljs-comment">                SIG_BLOCK: 将用户设置的阻塞信号集添加到内核中，内核中原来的数据不变</span><br><span class="hljs-comment">                    假设内核中默认的阻塞信号集是mask， mask | set</span><br><span class="hljs-comment">                SIG_UNBLOCK: 根据用户设置的数据，对内核中的数据进行解除阻塞</span><br><span class="hljs-comment">                    mask &amp;= ~set</span><br><span class="hljs-comment">                SIG_SETMASK:覆盖内核中原来的值</span><br><span class="hljs-comment">            </span><br><span class="hljs-comment">            - set ：已经初始化好的用户自定义的信号集</span><br><span class="hljs-comment">            - oldset : 保存设置之前的内核中的阻塞信号集的状态，可以是 NULL</span><br><span class="hljs-comment">        - 返回值：</span><br><span class="hljs-comment">            成功：0</span><br><span class="hljs-comment">            失败：-1</span><br><span class="hljs-comment">                设置错误号：EFAULT、EINVAL</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    int sigpending(sigset_t *set);</span><br><span class="hljs-comment">        - 功能：获取内核中的未决信号集</span><br><span class="hljs-comment">        - 参数：set,传出参数，保存的是内核中的未决信号集中的信息。</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 编写一个程序，把所有的常规信号（1-31）的未决状态打印到屏幕</span><br><span class="hljs-comment">// 设置某些信号是阻塞的，通过键盘产生这些信号</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-comment">// 设置2、3号信号阻塞</span><br>    <span class="hljs-type">sigset_t</span> <span class="hljs-built_in">set</span>;<br>    sigemptyset(&amp;<span class="hljs-built_in">set</span>);<br>    <span class="hljs-comment">// 将2号和3号信号添加到信号集中</span><br>    sigaddset(&amp;<span class="hljs-built_in">set</span>, SIGINT);<br>    sigaddset(&amp;<span class="hljs-built_in">set</span>, SIGQUIT);<br><br>    <span class="hljs-comment">// 修改内核中的阻塞信号集</span><br>    sigprocmask(SIG_BLOCK, &amp;<span class="hljs-built_in">set</span>, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>        num++;<br>        <span class="hljs-comment">// 获取当前的未决信号集的数据</span><br>        <span class="hljs-type">sigset_t</span> pendingset;<br>        sigemptyset(&amp;pendingset);<br>        sigpending(&amp;pendingset);<br><br>        <span class="hljs-comment">// 遍历前32位</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">31</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span>(sigismember(&amp;pendingset, i) == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;1&quot;</span>);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sigismember(&amp;pendingset, i) == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0&quot;</span>);<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                perror(<span class="hljs-string">&quot;sigismember&quot;</span>);<br>                <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>        sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span>(num == <span class="hljs-number">10</span>) &#123;<br>            <span class="hljs-comment">// 解除阻塞</span><br>            sigprocmask(SIG_UNBLOCK, &amp;<span class="hljs-built_in">set</span>, <span class="hljs-literal">NULL</span>);<br>        &#125;<br><br>    &#125;<br><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="sigaction"><a href="#sigaction" class="headerlink" title="sigaction()"></a>sigaction()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    #include &lt;signal.h&gt;</span><br><span class="hljs-comment">    int sigaction(int signum, const struct sigaction *act,</span><br><span class="hljs-comment">                            struct sigaction *oldact);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        - 功能：检查或者改变信号的处理。信号捕捉</span><br><span class="hljs-comment">        - 参数：</span><br><span class="hljs-comment">            - signum : 需要捕捉的信号的编号或者宏值（信号的名称）</span><br><span class="hljs-comment">            - act ：捕捉到信号之后的处理动作</span><br><span class="hljs-comment">            - oldact : 上一次对信号捕捉相关的设置，一般不使用，传递NULL</span><br><span class="hljs-comment">        - 返回值：</span><br><span class="hljs-comment">            成功 0</span><br><span class="hljs-comment">            失败 -1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     struct sigaction &#123;</span><br><span class="hljs-comment">        // 函数指针，指向的函数就是信号捕捉到之后的处理函数</span><br><span class="hljs-comment">        void     (*sa_handler)(int);</span><br><span class="hljs-comment">        // 不常用</span><br><span class="hljs-comment">        void     (*sa_sigaction)(int, siginfo_t *, void *);</span><br><span class="hljs-comment">        // 临时阻塞信号集，在信号捕捉函数执行过程中，临时阻塞某些信号。</span><br><span class="hljs-comment">        sigset_t   sa_mask;</span><br><span class="hljs-comment">        // 使用哪一个信号处理对捕捉到的信号进行处理</span><br><span class="hljs-comment">        // 这个值可以是0，表示使用sa_handler,也可以是SA_SIGINFO表示使用sa_sigaction</span><br><span class="hljs-comment">        int        sa_flags;</span><br><span class="hljs-comment">        // 被废弃掉了</span><br><span class="hljs-comment">        void     (*sa_restorer)(void);</span><br><span class="hljs-comment">    &#125;;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">myalarm</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;捕捉到了信号的编号是：%d\n&quot;</span>, num);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;xxxxxxx\n&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 过3秒以后，每隔2秒钟定时一次</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigaction</span> <span class="hljs-title">act</span>;</span><br>    act.sa_flags = <span class="hljs-number">0</span>;<br>    act.sa_handler = myalarm;<br>    sigemptyset(&amp;act.sa_mask);  <span class="hljs-comment">// 清空临时阻塞信号集</span><br>   <br>    <span class="hljs-comment">// 注册信号捕捉</span><br>    sigaction(SIGALRM, &amp;act, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">itimerval</span> <span class="hljs-title">new_value</span>;</span><br><br>    <span class="hljs-comment">// 设置间隔的时间</span><br>    new_value.it_interval.tv_sec = <span class="hljs-number">2</span>;<br>    new_value.it_interval.tv_usec = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 设置延迟的时间,3秒之后开始第一次定时</span><br>    new_value.it_value.tv_sec = <span class="hljs-number">3</span>;<br>    new_value.it_value.tv_usec = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-type">int</span> ret = setitimer(ITIMER_REAL, &amp;new_value, <span class="hljs-literal">NULL</span>); <span class="hljs-comment">// 非阻塞的</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;定时器开始了...\n&quot;</span>);<br><br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;setitimer&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// getchar();</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="SIGCHLD信号"><a href="#SIGCHLD信号" class="headerlink" title="SIGCHLD信号"></a>SIGCHLD信号</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    SIGCHLD信号产生的3个条件：</span><br><span class="hljs-comment">        1.子进程结束</span><br><span class="hljs-comment">        2.子进程暂停了</span><br><span class="hljs-comment">        3.子进程继续运行</span><br><span class="hljs-comment">        都会给父进程发送该信号，父进程默认忽略该信号。</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    使用SIGCHLD信号解决僵尸进程的问题。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">myFun</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;捕捉到的信号 ：%d\n&quot;</span>, num);<br>    <span class="hljs-comment">// 回收子进程PCB的资源</span><br>    <span class="hljs-comment">// while(1) &#123;</span><br>    <span class="hljs-comment">//     wait(NULL); </span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>       <span class="hljs-type">int</span> ret = waitpid(<span class="hljs-number">-1</span>, <span class="hljs-literal">NULL</span>, WNOHANG);<br>       <span class="hljs-keyword">if</span>(ret &gt; <span class="hljs-number">0</span>) &#123;<br>           <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child die , pid = %d\n&quot;</span>, ret);<br>       &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">0</span>) &#123;<br>           <span class="hljs-comment">// 说明还有子进程或者</span><br>           <span class="hljs-keyword">break</span>;<br>       &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) &#123;<br>           <span class="hljs-comment">// 没有子进程</span><br>           <span class="hljs-keyword">break</span>;<br>       &#125;<br>    &#125;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 提前设置好阻塞信号集，阻塞SIGCHLD，因为有可能子进程很快结束，父进程还没有注册完信号捕捉</span><br>    <span class="hljs-type">sigset_t</span> <span class="hljs-built_in">set</span>;<br>    sigemptyset(&amp;<span class="hljs-built_in">set</span>);<br>    sigaddset(&amp;<span class="hljs-built_in">set</span>, SIGCHLD);<br>    sigprocmask(SIG_BLOCK, &amp;<span class="hljs-built_in">set</span>, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-comment">// 创建一些子进程</span><br>    <span class="hljs-type">pid_t</span> pid;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>        pid = fork();<br>        <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 父进程</span><br>        <span class="hljs-comment">// 捕捉子进程死亡时发送的SIGCHLD信号</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigaction</span> <span class="hljs-title">act</span>;</span><br>        act.sa_flags = <span class="hljs-number">0</span>;<br>        act.sa_handler = myFun;<br>        sigemptyset(&amp;act.sa_mask);<br>        sigaction(SIGCHLD, &amp;act, <span class="hljs-literal">NULL</span>);<br><br>        <span class="hljs-comment">// 注册完信号捕捉以后，解除阻塞</span><br>        sigprocmask(SIG_UNBLOCK, &amp;<span class="hljs-built_in">set</span>, <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;parent process pid : %d\n&quot;</span>, getpid());<br>            sleep(<span class="hljs-number">2</span>);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( pid == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 子进程</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child process pid : %d\n&quot;</span>, getpid());<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="共享内存（效率很高）"><a href="#共享内存（效率很高）" class="headerlink" title="共享内存（效率很高）"></a>共享内存（效率很高）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs C">共享内存相关的函数<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/shm.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">shmget</span><span class="hljs-params">(<span class="hljs-type">key_t</span> key, <span class="hljs-type">size_t</span> size, <span class="hljs-type">int</span> shmflg)</span>;<br>    - 功能：创建一个新的共享内存段，或者获取一个既有的共享内存段的标识。<br>        新创建的内存段中的数据都会被初始化为<span class="hljs-number">0</span><br>    - 参数：<br>        - key : <span class="hljs-type">key_t</span>类型是一个整形，通过这个找到或者创建一个共享内存。<br>                一般使用<span class="hljs-number">16</span>进制表示，非<span class="hljs-number">0</span>值<br>        - size: 共享内存的大小<br>        - shmflg: 属性<br>            - 访问权限<br>            - 附加属性：创建/判断共享内存是不是存在<br>                - 创建：IPC_CREAT<br>                - 判断共享内存是否存在： IPC_EXCL , 需要和IPC_CREAT一起使用<br>                    IPC_CREAT | IPC_EXCL | <span class="hljs-number">0664</span><br>        - 返回值：<br>            失败：<span class="hljs-number">-1</span> 并设置错误号<br>            成功：&gt;<span class="hljs-number">0</span> 返回共享内存的引用的ID，后面操作共享内存都是通过这个值。<br><br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">shmat</span><span class="hljs-params">(<span class="hljs-type">int</span> shmid, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *shmaddr, <span class="hljs-type">int</span> shmflg)</span>;<br>    - 功能：和当前的进程进行关联<br>    - 参数：<br>        - shmid : 共享内存的标识（ID）,由shmget返回值获取<br>        - shmaddr: 申请的共享内存的起始地址，指定<span class="hljs-literal">NULL</span>，内核指定<br>        - shmflg : 对共享内存的操作<br>            - 读 ： SHM_RDONLY, 必须要有读权限<br>            - 读写： <span class="hljs-number">0</span><br>    - 返回值：<br>        成功：返回共享内存的首（起始）地址。  失败(<span class="hljs-type">void</span> *) <span class="hljs-number">-1</span><br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">shmdt</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *shmaddr)</span>;<br>    - 功能：解除当前进程和共享内存的关联<br>    - 参数：<br>        shmaddr：共享内存的首地址<br>    - 返回值：成功 <span class="hljs-number">0</span>， 失败 <span class="hljs-number">-1</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">shmctl</span><span class="hljs-params">(<span class="hljs-type">int</span> shmid, <span class="hljs-type">int</span> cmd, <span class="hljs-keyword">struct</span> shmid_ds *buf)</span>;<br>    - 功能：对共享内存进行操作。删除共享内存，共享内存要删除才会消失，创建共享内存的进行被销毁了对共享内存是没有任何影响。<br>    - 参数：<br>        - shmid: 共享内存的ID<br>        - cmd : 要做的操作<br>            - IPC_STAT : 获取共享内存的当前的状态<br>            - IPC_SET : 设置共享内存的状态<br>            - IPC_RMID: 标记共享内存被销毁<br>        - buf：需要设置或者获取的共享内存的属性信息<br>            - IPC_STAT : buf存储数据<br>            - IPC_SET : buf中需要初始化数据，设置到内核中<br>            - IPC_RMID : 没有用，<span class="hljs-literal">NULL</span><br><br><span class="hljs-type">key_t</span> <span class="hljs-title function_">ftok</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> proj_id)</span>;<br>    - 功能：根据指定的路径名，和<span class="hljs-type">int</span>值，生成一个共享内存的key<br>    - 参数：<br>        - pathname:指定一个存在的路径<br>            /home/nowcoder/Linux/a.txt<br>            / <br>        - proj_id: <span class="hljs-type">int</span>类型的值，但是这系统调用只会使用其中的<span class="hljs-number">1</span>个字节<br>                   范围 ： <span class="hljs-number">0</span><span class="hljs-number">-255</span>  一般指定一个字符 <span class="hljs-string">&#x27;a&#x27;</span><br><br><br>问题<span class="hljs-number">1</span>：操作系统如何知道一块共享内存被多少个进程关联？<br>    - 共享内存维护了一个结构体<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">shmid_ds</span> 这个结构体中有一个成员 <span class="hljs-title">shm_nattch</span></span><br><span class="hljs-class">    - <span class="hljs-title">shm_nattach</span> 记录了关联的进程个数</span><br><span class="hljs-class"></span><br><span class="hljs-class">问题2：可不可以对共享内存进行多次删除 <span class="hljs-title">shmctl</span></span><br><span class="hljs-class">    - 可以的</span><br><span class="hljs-class">    - 因为<span class="hljs-title">shmctl</span> 标记删除共享内存，不是直接删除</span><br><span class="hljs-class">    - 什么时候真正删除呢?</span><br><span class="hljs-class">        当和共享内存关联的进程数为0的时候，就真正被删除</span><br><span class="hljs-class">    - 当共享内存的<span class="hljs-title">key</span>为0的时候，表示共享内存被标记删除了</span><br><span class="hljs-class">        如果一个进程和共享内存取消关联，那么这个进程就不能继续操作这个共享内存。也不能进行关联。</span><br><span class="hljs-class"></span><br><span class="hljs-class">    共享内存和内存映射的区别</span><br><span class="hljs-class">    1.共享内存可以直接创建，内存映射需要磁盘文件（匿名映射除外）</span><br><span class="hljs-class">    2.共享内存效果更高</span><br><span class="hljs-class">    3.内存</span><br><span class="hljs-class">        所有的进程操作的是同一块共享内存。</span><br><span class="hljs-class">        内存映射，每个进程在自己的虚拟地址空间中有一个独立的内存。</span><br><span class="hljs-class">    4.数据安全</span><br><span class="hljs-class">        - 进程突然退出</span><br><span class="hljs-class">            共享内存还存在</span><br><span class="hljs-class">            内存映射区消失</span><br><span class="hljs-class">        - 运行进程的电脑死机，宕机了</span><br><span class="hljs-class">            数据存在在共享内存中，没有了</span><br><span class="hljs-class">            内存映射区的数据 ，由于磁盘文件中的数据还在，所以内存映射区的数据还存在。</span><br><span class="hljs-class"></span><br><span class="hljs-class">    5.生命周期</span><br><span class="hljs-class">        - 内存映射区：进程退出，内存映射区销毁</span><br><span class="hljs-class">        - 共享内存：进程退出，共享内存还在，标记删除（所有的关联的进程数为0），或者关机</span><br><span class="hljs-class">            如果一个进程退出，会自动和共享内存进行取消关联。</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/shm.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;    <br><br>    <span class="hljs-comment">// 1.创建一个共享内存</span><br>    <span class="hljs-type">int</span> shmid = shmget(<span class="hljs-number">100</span>, <span class="hljs-number">4096</span>, IPC_CREAT|<span class="hljs-number">0664</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;shmid : %d\n&quot;</span>, shmid);<br>    <br>    <span class="hljs-comment">// 2.和当前进程进行关联</span><br>    <span class="hljs-type">void</span> * ptr = shmat(shmid, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-type">char</span> * str = <span class="hljs-string">&quot;helloworld&quot;</span>;<br><br>    <span class="hljs-comment">// 3.写数据</span><br>    <span class="hljs-built_in">memcpy</span>(ptr, str, <span class="hljs-built_in">strlen</span>(str) + <span class="hljs-number">1</span>);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;按任意键继续\n&quot;</span>);<br>    getchar();<br><br>    <span class="hljs-comment">// 4.解除关联</span><br>    shmdt(ptr);<br><br>    <span class="hljs-comment">// 5.删除共享内存</span><br>    shmctl(shmid, IPC_RMID, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    写一个守护进程，每隔2s获取一下系统时间，将这个时间写入到磁盘文件中。</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">work</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>    <span class="hljs-comment">// 捕捉到信号之后，获取系统时间，写入磁盘文件</span><br>    <span class="hljs-type">time_t</span> tm = time(<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tm</span> * <span class="hljs-title">loc</span> =</span> localtime(&amp;tm);<br>    <span class="hljs-comment">// char buf[1024];</span><br><br>    <span class="hljs-comment">// sprintf(buf, &quot;%d-%d-%d %d:%d:%d\n&quot;,loc-&gt;tm_year,loc-&gt;tm_mon</span><br>    <span class="hljs-comment">// ,loc-&gt;tm_mday, loc-&gt;tm_hour, loc-&gt;tm_min, loc-&gt;tm_sec);</span><br><br>    <span class="hljs-comment">// printf(&quot;%s\n&quot;, buf);</span><br><br>    <span class="hljs-type">char</span> * str = asctime(loc);<br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;time.txt&quot;</span>, O_RDWR | O_CREAT | O_APPEND, <span class="hljs-number">0664</span>);<br>    write(fd ,str, <span class="hljs-built_in">strlen</span>(str));<br>    close(fd);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-comment">// 1.创建子进程，退出父进程</span><br>    <span class="hljs-type">pid_t</span> pid = fork();<br><br>    <span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 2.将子进程重新创建一个会话</span><br>    setsid();<br><br>    <span class="hljs-comment">// 3.设置掩码</span><br>    umask(<span class="hljs-number">022</span>);<br><br>    <span class="hljs-comment">// 4.更改工作目录</span><br>    chdir(<span class="hljs-string">&quot;/home/nowcoder/&quot;</span>);<br><br>    <span class="hljs-comment">// 5. 关闭、重定向文件描述符</span><br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;/dev/null&quot;</span>, O_RDWR);<br>    dup2(fd, STDIN_FILENO);<br>    dup2(fd, STDOUT_FILENO);<br>    dup2(fd, STDERR_FILENO);<br><br>    <span class="hljs-comment">// 6.业务逻辑</span><br><br>    <span class="hljs-comment">// 捕捉定时信号</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigaction</span> <span class="hljs-title">act</span>;</span><br>    act.sa_flags = <span class="hljs-number">0</span>;<br>    act.sa_handler = work;<br>    sigemptyset(&amp;act.sa_mask);<br>    sigaction(SIGALRM, &amp;act, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">itimerval</span> <span class="hljs-title">val</span>;</span><br>    val.it_value.tv_sec = <span class="hljs-number">2</span>;<br>    val.it_value.tv_usec = <span class="hljs-number">0</span>;<br>    val.it_interval.tv_sec = <span class="hljs-number">2</span>;<br>    val.it_interval.tv_usec = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 创建定时器</span><br>    setitimer(ITIMER_REAL, &amp;val, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// 不让进程结束</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>        sleep(<span class="hljs-number">10</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
    
    
    <categories>
      
      <category>Linux编程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux系统编程</title>
    <link href="/2023/06/03/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    <url>/2023/06/03/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux系统编程"><a href="#Linux系统编程" class="headerlink" title="Linux系统编程"></a>Linux系统编程</h1><h2 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h2><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><ol><li><p>源代码</p></li><li><p>预处理器    -E    <code>gcc  main.c -E -o main.i</code></p><p>预处理后的源代码</p></li><li><p>编译器    -S    <code>gcc  main.i -S -o main.s</code></p><p>汇编代码</p></li><li><p>汇编器    -c    <code>gcc  main.s -c -o main.o</code></p><p>目标代码</p></li><li><p>链接器</p><p>启动代码、目标代码、库代码、其他目标代码</p></li><li><p>可执行程序</p></li></ol><h3 id="G"><a href="#G" class="headerlink" title="G++"></a>G++</h3><ol><li>gcc 和 g++都可以编译C 和 C++，gcc不能自动的链接C++的库，所以就统一使用g++了</li><li>gcc 链接C++的命令  <code>gcc -lstdc++</code></li></ol><h3 id="GCC常用命令"><a href="#GCC常用命令" class="headerlink" title="GCC常用命令"></a>GCC常用命令</h3><img src="截屏2023-03-11 13.12.50.png" alt="截屏2023-03-11 13.12.50" style="zoom: 67%;" /><img src="截屏2023-03-11 13.21.38.png" alt="截屏2023-03-11 13.21.38" style="zoom: 67%;" /><p>-D 可以指定代码里定义的 #ifdefine FUCK 的宏，可以在debug时用</p><hr><h2 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h2><h3 id="什么是库"><a href="#什么是库" class="headerlink" title="什么是库"></a>什么是库</h3><p>库是计算机上的一类文件，可以将其简单的看作代码仓库。库不能单独运行。</p><p><strong>静态库：</strong>在程序链接阶段被复制到程序中</p><p><strong>动态库：</strong>在程序运行阶段由系统动态加载到内存中，供程序使用</p><h3 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h3><p><code>libxxx.a</code>,xxx写库的名称</p><h3 id="静态库制作"><a href="#静态库制作" class="headerlink" title="静态库制作"></a>静态库制作</h3><ol><li>gcc获取.o文件，<code>gcc -c add.c sub.c mult.c div.c </code></li><li>使用ar工具将.o文件打包<code>ar rcs libcalc.a add.o sub.o div.o mult.o</code><ol><li>参数：r 将.o文件插入到库中</li><li>参数：c 创建库文件</li><li>参数：s 创建索引</li></ol></li></ol><h3 id="静态库使用"><a href="#静态库使用" class="headerlink" title="静态库使用"></a>静态库使用</h3><p>库文件要和对应的头文件一起使用</p><p><code>gcc main.c -o app -I ./include/ -l calc -L ./lib</code></p><p>-l 后面是库的名字而不是库文件的名字，-I添加头文件搜索路径，-L添加库文件搜索路径</p><h2 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h2><h3 id="命名规则-1"><a href="#命名规则-1" class="headerlink" title="命名规则"></a>命名规则</h3><p><code>libxxx.so</code>，后缀不一样，在Linux中是个可执行文件</p><h3 id="制作过程"><a href="#制作过程" class="headerlink" title="制作过程"></a>制作过程</h3><h4 id="得到-o文件，和文件位置无关-fpic"><a href="#得到-o文件，和文件位置无关-fpic" class="headerlink" title="得到.o文件，和文件位置无关 -fpic"></a>得到.o文件，和文件位置无关 -fpic</h4><p><code>gcc -c -fpic add.c sub.c</code></p><h4 id="得到动态库"><a href="#得到动态库" class="headerlink" title="得到动态库"></a>得到动态库</h4><p><code>gcc -shared add.o sub.o -o libcalc.so</code></p><h3 id="动态库使用原理"><a href="#动态库使用原理" class="headerlink" title="动态库使用原理"></a>动态库使用原理</h3><p>动态库不会被打包到可执行文件中，只会放里一些库的信息，在程序运行时会加载到内存中。</p><p>使用 <code>ldd 程序名</code>  命令查询程序动态库依赖信息</p><p> 程序需要获取动态库的绝对路径，这就要使用系统的动态载入器了。会查询系统的 <strong>环境变量LD_LIBRARY_PATH</strong>，&#x2F;etc&#x2F;ld.so.cache，&#x2F;lib&#x2F;，&#x2F;usr&#x2F;lib</p><p><strong>所以使用动态库的时候要选上面的一个文件，将动态库绝对路径添加进去</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#终端级别</span><br><span class="hljs-built_in">export</span> LD_LIBRARY_PATH=<span class="hljs-variable">$LD_LIBRARY_PATH</span>:/home/webserver/test/lib  <span class="hljs-comment">#这个方法只在当前终端生效，关掉终端就没了</span><br><span class="hljs-comment">#用户级别 </span><br>vim .bashrc <span class="hljs-comment">#在用户文件夹下的.bashrc文件中添加上面的代码</span><br><span class="hljs-built_in">source</span> .bashrc<br><span class="hljs-comment">#系统级别,有的时候如果提前配置了用户或者终端的，最好重开一下终端</span><br>sudo vim /etc/profile<span class="hljs-comment">#在这个文件中加上面的代码</span><br><span class="hljs-built_in">source</span> /etc/profile<br><span class="hljs-comment">#ld.so.config级别</span><br>sodu vim /etc/ld.so.conf<br>ldconfig<br><br>gcc main.c -o APP -I ./include/ -l calc -L ./lib<br>./APP<br></code></pre></td></tr></table></figure><h2 id="静态库和动态库的对比"><a href="#静态库和动态库的对比" class="headerlink" title="静态库和动态库的对比"></a>静态库和动态库的对比</h2><h3 id="静态库优缺点"><a href="#静态库优缺点" class="headerlink" title="静态库优缺点"></a>静态库优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li>静态库被打包到应用程序中加载速度快。</li><li>发布程序不需要提供静态库，移植方便。</li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li>消耗系统资源，浪费内存。</li><li>更新部署发布麻烦。</li></ol><h3 id="动态库优缺点"><a href="#动态库优缺点" class="headerlink" title="动态库优缺点"></a>动态库优缺点</h3><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ol><li>可以实现进程间资源共享</li><li>更新发布简单</li><li>可以控制何时加载库</li></ol><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ol><li>加载速度慢</li><li>发布程序的时候需要提供以来的动态库</li></ol><h2 id="Makefile-—》CMake"><a href="#Makefile-—》CMake" class="headerlink" title="Makefile —》CMake"></a>Makefile —》CMake</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 将文件夹内的所有源文件保存到指定变量名中</span><br><span class="hljs-keyword">aux_source_directory</span>(&lt;dir&gt; &lt;variable&gt;) <br><span class="hljs-keyword">aux_source_directory</span>(. DIR_SRC)<br><span class="hljs-keyword">add_executable</span>(Demo,<span class="hljs-variable">$&#123;DIR_SRC&#125;</span>)<br><br><br><span class="hljs-comment"># 多目录多文件的情况下，每个目录都要有自己的CMakeLists</span><br><span class="hljs-keyword">add_subdirectory</span>(<span class="hljs-keyword">math</span>)<br><span class="hljs-keyword">add_executable</span>(Demo,<span class="hljs-variable">$&#123;DIR_SRC&#125;</span>)<br>target_link_library(Demo MathFunction)<br><span class="hljs-comment"># 子目录的CMakeList</span><br><span class="hljs-comment"># 查找当前目录下的所有源文件</span><br><span class="hljs-comment"># 并将名称保存到 DIR_LIB_SRCS 变量</span><br><span class="hljs-keyword">aux_source_directory</span>(. DIR_LIB_SRCS)<br><span class="hljs-comment"># 生成链接库</span><br><span class="hljs-keyword">add_library</span> (MathFunctions <span class="hljs-variable">$&#123;DIR_LIB_SRCS&#125;</span>)<br></code></pre></td></tr></table></figure><h2 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>为调试而编译的时，打开调试选项-g  -Wall </p><p>-g是在可执行程序中加入源代码信息</p><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p><code>gdb xxx</code> 开启</p><p><code>set args xxx1 xxx2</code> 设置参数</p><p><code>show args</code> 获取参数</p><p><code>list</code>  显示代码，后面可以跟行号、函数名  </p><p><code>break</code> 设置断点。 <code>info break</code> 查看断点。<code>del break</code>  删除</p><img src="截屏2023-03-16 21.20.40.png" alt="截屏2023-03-16 21.20.40" style="zoom:25%;" /><p><code>quit</code> 退出</p><img src="截屏2023-03-16 21.21.21.png" alt="截屏2023-03-16 21.21.21" style="zoom: 25%;" /><hr><h2 id="标准C库IO函数和Linux系统IO函数对比"><a href="#标准C库IO函数和Linux系统IO函数对比" class="headerlink" title="标准C库IO函数和Linux系统IO函数对比"></a>标准C库IO函数和Linux系统IO函数对比</h2> <img src="截屏2023-03-16 22.03.14.png" alt="截屏2023-03-16 22.03.14" style="zoom:50%;" /><p>缓冲区提高了效率，降低了写磁盘的次数。因为缓冲区是在内存中的，写它速度快。默认大约8kb。</p><img src="截屏2023-03-16 22.13.11.png" alt="截屏2023-03-16 22.13.11" style="zoom:50%;" /><h2 id="虚拟地址空间"><a href="#虚拟地址空间" class="headerlink" title="虚拟地址空间"></a>虚拟地址空间</h2><img src="截屏2023-03-16 22.25.36.png" alt="截屏2023-03-16 22.25.36" style="zoom:50%;" /><h2 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h2><img src="截屏2023-03-21 22.40.31.png" alt="截屏2023-03-21 22.40.31" style="zoom:50%;" /><h2 id="Linux系统IO函数"><a href="#Linux系统IO函数" class="headerlink" title="Linux系统IO函数"></a>Linux系统IO函数</h2><p>![截屏2023-03-21 22.48.14](截屏2023-03-21 22.48.14.png)</p><h3 id="open函数"><a href="#open函数" class="headerlink" title="open函数"></a>open函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    #include &lt;sys/types.h&gt;</span><br><span class="hljs-comment">    #include &lt;sys/stat.h&gt;</span><br><span class="hljs-comment">    #include &lt;fcntl.h&gt;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    // 打开一个已经存在的文件</span><br><span class="hljs-comment">    int open(const char *pathname, int flags);</span><br><span class="hljs-comment">        参数：</span><br><span class="hljs-comment">            - pathname：要打开的文件路径</span><br><span class="hljs-comment">            - flags：对文件的操作权限设置还有其他的设置</span><br><span class="hljs-comment">              O_RDONLY,  O_WRONLY,  O_RDWR  这三个设置是互斥的</span><br><span class="hljs-comment">        返回值：返回一个新的文件描述符，如果调用失败，返回-1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    errno：属于Linux系统函数库，库里面的一个全局变量，记录的是最近的错误号。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    #include &lt;stdio.h&gt;</span><br><span class="hljs-comment">    void perror(const char *s);作用：打印errno对应的错误描述</span><br><span class="hljs-comment">        s参数：用户描述，比如hello,最终输出的内容是  hello:xxx(实际的错误描述)</span><br><span class="hljs-comment">    // 创建一个新的文件</span><br><span class="hljs-comment">    int open(const char *pathname, int flags, mode_t mode);</span><br><span class="hljs-comment">    flags = O_CREAT 文件不存在将会创建</span><br><span class="hljs-comment">    mode 必须是8进制的数，表示创建出的文件的操作权限 比如0775</span><br><span class="hljs-comment">    最终权限是：mode &amp; ~umask</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-comment">// 打开一个文件</span><br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;a.txt&quot;</span>, O_RDONLY);<br><br>    <span class="hljs-keyword">if</span>(fd == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;open&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 读写操作</span><br><br>    <span class="hljs-comment">// 关闭</span><br>    close(fd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过open创建文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> fd=open(<span class="hljs-string">&quot;create.txt&quot;</span>, O_RDWR | O_CREAT,<span class="hljs-number">0777</span>);<br>    <span class="hljs-keyword">if</span>(fd == <span class="hljs-number">-1</span>)&#123;<br>        perror(<span class="hljs-string">&quot;open&quot;</span>);<br>    &#125;<br>    close(fd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>flag是一个int类型的数字。占4个字节，32位。所以flag32个bit，每个位就是一个标志位。用按位或，可以增加多个权限。</p><h3 id="read和write函数"><a href="#read和write函数" class="headerlink" title="read和write函数"></a>read和write函数</h3><p>read从文件中读取数据到内存中，write反过来。</p><p><code>ssize_t read(int fd,void* buf,size_t count);</code></p><p>fd ：是文件描述符</p><p>buf ：要读取数据存放的地方，数组的地址</p><p>count ：指定数组的大小</p><p>返回值为：成功，&gt;0返回读取的比特数，&#x3D;0说明文件读完了</p><p>​   失败返回-1，并将errno设置为合适的值</p><p>write函数参数的含义和read类似</p><h3 id="lseek函数"><a href="#lseek函数" class="headerlink" title="lseek函数"></a>lseek函数</h3><p>对文件指针进行操作。</p><p><code>off_t lseek(int fd, off_t offset, int whence)</code></p><p>offset：偏移量</p><p>whence：</p><ul><li>SEEK_SET：设置文件指针偏移量</li><li>SEEK_END：设置偏移量，当前位置+第二个参数offset</li><li>SEEK_CUR：设置偏移量，文件结尾+第二个参数offset</li></ul><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ol><li>移动文件指针到头文件，<code>lseek(fd, 0 , SEEK_SET)</code></li><li>用来获取当前文件指针的位置 , <code>lseek(fd,0 , SEEK_CUR)</code></li><li>用来获取文件长度 <code>lseek(fd,0,SEEK_END)</code></li><li>拓展文件的长度 <code>lseek(fd,1000,SEEK_END)</code>将文件扩展1000个字节</li></ol><h3 id="stat，lstat函数"><a href="#stat，lstat函数" class="headerlink" title="stat，lstat函数"></a>stat，lstat函数</h3><h4 id="stat作用"><a href="#stat作用" class="headerlink" title="stat作用"></a>stat作用</h4><p>获取一个文件相关的信息  </p><p><code>int stat(const char* pathname, struct stat* bufstat)</code></p><ul><li>pathname : 文件路径</li><li>statbuf：结构体，传出参数，用与保存获取到的文件的信息 </li><li>返回值：0 -1 errno</li></ul><p><img src="../../../../../../../WebServer.assets/截屏2023-03-24 22.33.04.png" alt="截屏2023-03-24 22.33.04" style="zoom:50%;" /><img src="截屏2023-03-24 22.34.19.png" alt="截屏2023-03-24 22.34.19" style="zoom:50%;" /></p><p>判断文件权限，将st_mode和权限的宏进行按位与，判断是否为1  </p><p>判断文件类型，将st_mode和掩码进行按位与，然后和宏进行相等的比较</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">statbuf</span>;</span><br>   <span class="hljs-type">int</span> ret = stat(<span class="hljs-string">&quot;a.txt&quot;</span>,&amp;statbuf);<br>   <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)&#123;<br>       perror(<span class="hljs-string">&quot;stat&quot;</span>);<br>       <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>   &#125;<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;size: %ld\n&quot;</span>,statbuf.st_size);<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="lstat"><a href="#lstat" class="headerlink" title="lstat"></a>lstat</h4><p>获取软连接文件的信息</p><h3 id="模拟实现ls-l命令"><a href="#模拟实现ls-l命令" class="headerlink" title="模拟实现ls -l命令"></a>模拟实现ls -l命令</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 模拟实现ls -l指令</span><br><span class="hljs-comment">// -rw-r--r-- 1 root root 0 Mar 24 14:43 a.txt</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pwd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;grp.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s 文件名称\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 通过stat函数获取用户传入文件的信息</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">st</span>;</span><br>    <span class="hljs-type">int</span> ret = stat(argv[<span class="hljs-number">1</span>], &amp;st);<br>    <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;stat&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 获取文件类型和文件权限</span><br>    <span class="hljs-type">char</span> perms[<span class="hljs-number">11</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">switch</span> (st.st_mode &amp; __S_IFMT)<br>    &#123;<br>    <span class="hljs-keyword">case</span> __S_IFLNK:<br>        perms[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;l&#x27;</span>;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> __S_IFDIR:<br>        perms[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;d&#x27;</span>;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> __S_IFREG:<br>        perms[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;-&#x27;</span>;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> __S_IFBLK:<br>        perms[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;b&#x27;</span>;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> __S_IFCHR:<br>        perms[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;c&#x27;</span>;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> __S_IFSOCK:<br>        perms[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;s&#x27;</span>;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> __S_IFIFO:<br>        perms[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;p&#x27;</span>;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>        perms[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;?&#x27;</span>;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">// 判断文件访问权限</span><br>    <span class="hljs-comment">// 文件所有者</span><br>    perms[<span class="hljs-number">1</span>] = (st.st_mode &amp; S_IRUSR) ? <span class="hljs-string">&#x27;r&#x27;</span> : <span class="hljs-string">&#x27;-&#x27;</span>;<br>    perms[<span class="hljs-number">2</span>] = (st.st_mode &amp; S_IWUSR) ? <span class="hljs-string">&#x27;w&#x27;</span> : <span class="hljs-string">&#x27;-&#x27;</span>;<br>    perms[<span class="hljs-number">3</span>] = (st.st_mode &amp; S_IXUSR) ? <span class="hljs-string">&#x27;x&#x27;</span> : <span class="hljs-string">&#x27;-&#x27;</span>;<br>    <span class="hljs-comment">// 文件所在组</span><br>    perms[<span class="hljs-number">4</span>] = (st.st_mode &amp; S_IRGRP) ? <span class="hljs-string">&#x27;r&#x27;</span> : <span class="hljs-string">&#x27;-&#x27;</span>;<br>    perms[<span class="hljs-number">5</span>] = (st.st_mode &amp; S_IWGRP) ? <span class="hljs-string">&#x27;w&#x27;</span> : <span class="hljs-string">&#x27;-&#x27;</span>;<br>    perms[<span class="hljs-number">6</span>] = (st.st_mode &amp; S_IXGRP) ? <span class="hljs-string">&#x27;x&#x27;</span> : <span class="hljs-string">&#x27;-&#x27;</span>;<br>    <span class="hljs-comment">// 其他人</span><br>    perms[<span class="hljs-number">7</span>] = (st.st_mode &amp; S_IROTH) ? <span class="hljs-string">&#x27;r&#x27;</span> : <span class="hljs-string">&#x27;-&#x27;</span>;<br>    perms[<span class="hljs-number">8</span>] = (st.st_mode &amp; S_IWOTH) ? <span class="hljs-string">&#x27;w&#x27;</span> : <span class="hljs-string">&#x27;-&#x27;</span>;<br>    perms[<span class="hljs-number">9</span>] = (st.st_mode &amp; S_IXOTH) ? <span class="hljs-string">&#x27;x&#x27;</span> : <span class="hljs-string">&#x27;-&#x27;</span>;<br><br>    <span class="hljs-comment">// 硬连接数</span><br>    <span class="hljs-type">int</span> link_num = st.st_nlink;<br><br>    <span class="hljs-comment">// 获取文件所有者名称</span><br>    <span class="hljs-type">char</span> *file_user = getpwuid(st.st_uid)-&gt;pw_name;<br><br>    <span class="hljs-comment">// 获取文件所在组</span><br>    <span class="hljs-type">char</span> *file_group = getgrgid(st.st_gid)-&gt;gr_name;<br><br>    <span class="hljs-comment">// 获取文件大小</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">int</span> file_size = st.st_size;<br><br>    <span class="hljs-comment">// 获取修改时间</span><br>    <span class="hljs-type">char</span> *time = ctime(&amp;st.st_mtim);<br><br>    <span class="hljs-type">char</span> mtime[<span class="hljs-number">512</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-built_in">strncpy</span>(mtime, time, <span class="hljs-built_in">strlen</span>(time) - <span class="hljs-number">1</span>);<br><br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>];<br>    <span class="hljs-built_in">sprintf</span>(buf, <span class="hljs-string">&quot;%s %d %s %s %ld %s %s&quot;</span>, perms, link_num, file_user, file_group, file_size, mtime, argv[<span class="hljs-number">1</span>]);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, buf);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="access"><a href="#access" class="headerlink" title="access()"></a>access()</h3><p><code> #include &lt;unistd.h&gt;</code></p><p><code>int access(const char* pathname, int mode)</code>判断文件是否具有某种权限，或者判断文件是否存在。</p><ul><li>pathname:文件路径</li><li>mode：R_OK W_OK X_OK F_OK(判断是否存在)</li><li>成功返回0 失败返回-1</li></ul><h3 id="chmod"><a href="#chmod" class="headerlink" title="chmod()"></a>chmod()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">chmod</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">mode_t</span> mode)</span>;<br></code></pre></td></tr></table></figure><p>修改文件的权限。</p><ul><li>mode_t:需要修改的权限值。八进制的数。 man手册里有</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> ret = chmod(<span class="hljs-string">&quot;fake_ls.c&quot;</span>,<span class="hljs-number">0777</span>);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)&#123;<br>        perror(<span class="hljs-string">&quot;chmod&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="truncate（）"><a href="#truncate（）" class="headerlink" title="truncate（）"></a>truncate（）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">truncate</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">off_t</span> length)</span>;<br><span class="hljs-comment">// length是需要最终文件变成的大小</span><br></code></pre></td></tr></table></figure><p>缩减或者扩展文件的尺寸到指定的大小。如果缩小尺寸，超出部分数据会丢失。</p><h3 id="和目录操作相关的函数"><a href="#和目录操作相关的函数" class="headerlink" title="和目录操作相关的函数"></a>和目录操作相关的函数</h3><img src="截屏2023-03-27 21.50.40.png" alt="截屏2023-03-27 21.50.40" style="zoom:50%;" /><p>DIR* 可以理解为目录流</p><p><code>#include &lt;dirent.h&gt;</code></p><p><code>DIR* opendir(char const *name)</code></p><p><code>struct dirent *readdir(DIR* dirp)</code>每次调用，dirp都会执向下一个目录。</p><p>读取到末尾返回NULL，但是不设置errno。读取错误就返回NULL并设置errno。</p><p><code>int closedir(DIR* dirp)</code></p><p>![截屏2023-03-31 16.04.26](截屏2023-03-31 16.04.26.png)</p><p>实现一个统计目录下所有普通文件个数的功能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dirent.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">getFileNum</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* path)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(argc&lt;<span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入路径: %s \n&quot;</span>,argv[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> nums = getFileNum(argv[<span class="hljs-number">1</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;普通文件个数 : %d\n&quot;</span>,nums);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">getFileNum</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* path)</span>&#123;<br>    DIR* dir = opendir(path);<br>    <span class="hljs-keyword">if</span>(dir==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;opendir failed&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 记录普通文件的个数</span><br>    <span class="hljs-type">int</span> total = <span class="hljs-number">0</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span>* <span class="hljs-title">dirp</span> =</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">while</span>((dirp = readdir(dir)) != <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-comment">// 获取名称</span><br>        <span class="hljs-type">char</span>* dname = dirp-&gt;d_name;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(dname,<span class="hljs-string">&quot;.&quot;</span>)==<span class="hljs-number">0</span> || <span class="hljs-built_in">strcmp</span>(dname,<span class="hljs-string">&quot;..&quot;</span>)==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-comment">// 为目录</span><br>        <span class="hljs-keyword">if</span>(dirp-&gt;d_type==DT_DIR)&#123;<br>            <span class="hljs-type">char</span> newpath[<span class="hljs-number">256</span>];<br>            <span class="hljs-built_in">sprintf</span>(newpath,<span class="hljs-string">&quot;%s/%s&quot;</span>,path,dname);<br>            total += getFileNum(newpath);    <br>        &#125;<br>        <span class="hljs-comment">// 为普通文件</span><br>        <span class="hljs-keyword">if</span>(dirp-&gt;d_type == DT_REG)&#123;<br>            total++;<br>        &#125;<br>    &#125;<br>    closedir(dir);<br>    <span class="hljs-keyword">return</span> total;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="和文件操作符相关的函数"><a href="#和文件操作符相关的函数" class="headerlink" title="和文件操作符相关的函数"></a>和文件操作符相关的函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">dup</span><span class="hljs-params">(<span class="hljs-type">int</span> oldfd)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">dup2</span><span class="hljs-params">(<span class="hljs-type">int</span> oldfd, <span class="hljs-type">int</span> newfd)</span>;<br></code></pre></td></tr></table></figure><h4 id="dup-int-oldfd-复制文件描述符"><a href="#dup-int-oldfd-复制文件描述符" class="headerlink" title="dup(int oldfd)复制文件描述符"></a>dup(int oldfd)复制文件描述符</h4><p>创建一个传入文件描述符的复制品，复制品从文件描述符表中挑目前可用的、最小的文件描述符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;dum.txt&quot;</span>, O_RDWR | O_CREAT, <span class="hljs-number">0664</span>);<br>    <span class="hljs-type">int</span> fd1 = dup(fd);<br>    <span class="hljs-keyword">if</span> (fd1 == <span class="hljs-number">-1</span>)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;dup&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fd : %d , fd1 :%d&quot;</span>, fd, fd1);<br>    close(fd);<br><br>    <span class="hljs-type">char</span>* str = <span class="hljs-string">&quot;Hello World&quot;</span>;<br>    <span class="hljs-type">int</span> ret = write(fd1,str,<span class="hljs-built_in">strlen</span>(str));<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)&#123;<br>        perror(<span class="hljs-string">&quot;write&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    close(fd1);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//TERMINAL</span><br><span class="hljs-comment">//fd : 3 , fd1 :4</span><br></code></pre></td></tr></table></figure><h4 id="dup2-int-oldfd-int-newfd-重定向文件描述符"><a href="#dup2-int-oldfd-int-newfd-重定向文件描述符" class="headerlink" title="dup2(int oldfd, int newfd)重定向文件描述符"></a>dup2(int oldfd, int newfd)重定向文件描述符</h4><p>和dup执行的功能差不多，但是用我们指定的newfd文件描述符去指向oldfd指向的文件。</p><p>newfd之前指向的文件就不算数了。oldfd必须是一个有效的文件描述符。</p><p>old和new的值相同时，什么都不会发生。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;1.txt&quot;</span>, O_RDWR | O_CREAT, <span class="hljs-number">0664</span>);<br>    <span class="hljs-keyword">if</span> (fd == <span class="hljs-number">-1</span>)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;open&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> fd1 = open(<span class="hljs-string">&quot;2.txt&quot;</span>, O_RDWR | O_CREAT, <span class="hljs-number">0664</span>);<br>    <span class="hljs-keyword">if</span> (fd1 == <span class="hljs-number">-1</span>)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;open&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fd : %d , fd1 :%d \n&quot;</span>, fd, fd1);<br>    <span class="hljs-type">int</span> fd2 = dup2(fd, fd1);<br>    <span class="hljs-keyword">if</span> (fd2 == <span class="hljs-number">-1</span>)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;dup2&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 通过fd1去写数据，实际操作的1.txt</span><br>    <span class="hljs-type">char</span> *str = <span class="hljs-string">&quot;Hello World&quot;</span>;<br>    <span class="hljs-type">int</span> ret = write(fd1, str, <span class="hljs-built_in">strlen</span>(str));<br>    <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;write&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fd : %d , fd1 :%d , fd2:%d \n&quot;</span>, fd, fd1, fd2);<br>    close(fd1);<br>    close(fd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//fd : 3 , fd1 :4 </span><br><span class="hljs-comment">//fd : 3 , fd1 :4 , fd2:4 </span><br><span class="hljs-comment">//2.txt中有HELLO WORLD</span><br></code></pre></td></tr></table></figure><h3 id="fcntl"><a href="#fcntl" class="headerlink" title="fcntl()"></a>fcntl()</h3><p>去查chatgpt吧</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fcntl</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> cmd, ... <span class="hljs-comment">/* arg */</span> )</span>;<br><span class="hljs-comment">// cmd：命令宏</span><br><span class="hljs-comment">// ...：可变参数</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    #include &lt;unistd.h&gt;</span><br><span class="hljs-comment">    #include &lt;fcntl.h&gt;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    int fcntl(int fd, int cmd, ...);</span><br><span class="hljs-comment">    参数：</span><br><span class="hljs-comment">        fd : 表示需要操作的文件描述符</span><br><span class="hljs-comment">        cmd: 表示对文件描述符进行如何操作</span><br><span class="hljs-comment">            - F_DUPFD : 复制文件描述符,复制的是第一个参数fd，得到一个新的文件描述符（返回值）</span><br><span class="hljs-comment">                int ret = fcntl(fd, F_DUPFD);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">            - F_GETFL : 获取指定的文件描述符文件状态flag</span><br><span class="hljs-comment">              获取的flag和我们通过open函数传递的flag是一个东西。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">            - F_SETFL : 设置文件描述符文件状态flag</span><br><span class="hljs-comment">              必选项：O_RDONLY, O_WRONLY, O_RDWR 不可以被修改</span><br><span class="hljs-comment">              可选性：O_APPEND, O)NONBLOCK</span><br><span class="hljs-comment">                O_APPEND 表示追加数据</span><br><span class="hljs-comment">                NONBLOK 设置成非阻塞</span><br><span class="hljs-comment">        </span><br><span class="hljs-comment">        阻塞和非阻塞：描述的是函数调用的行为。</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-comment">// 1.复制文件描述符</span><br>    <span class="hljs-comment">// int fd = open(&quot;1.txt&quot;, O_RDONLY);</span><br>    <span class="hljs-comment">// int ret = fcntl(fd, F_DUPFD);</span><br><br>    <span class="hljs-comment">// 2.修改或者获取文件状态flag</span><br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;1.txt&quot;</span>, O_RDWR);<br>    <span class="hljs-keyword">if</span>(fd == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;open&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取文件描述符状态flag</span><br>    <span class="hljs-type">int</span> flag = fcntl(fd, F_GETFL);<br>    <span class="hljs-keyword">if</span>(flag == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;fcntl&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    flag |= O_APPEND;   <span class="hljs-comment">// flag = flag | O_APPEND</span><br><br>    <span class="hljs-comment">// 修改文件描述符状态的flag，给flag加入O_APPEND这个标记。不能直接设置，不然会将原先的权限抹除。需要按位或。</span><br>    <span class="hljs-type">int</span> ret = fcntl(fd, F_SETFL, flag);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;fcntl&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-type">char</span> * str = <span class="hljs-string">&quot;nihao&quot;</span>;<br>    write(fd, str, <span class="hljs-built_in">strlen</span>(str));<br><br>    close(fd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="fcntl取代其他接口了吗"><a href="#fcntl取代其他接口了吗" class="headerlink" title="fcntl取代其他接口了吗"></a>fcntl取代其他接口了吗</h4><p>fcntl 函数并没有完全取代 dup 和 chmod 接口，它们之间的功能有所重叠，但仍然各有所长，可以根据需要选择使用。</p><p>对于 dup 接口，fcntl 提供了类似的功能，可以通过 F_DUPFD 命令来实现文件描述符的复制。与 dup 不同的是，fcntl 的 F_DUPFD 命令可以指定新的文件描述符的最小值。</p><p>对于 chmod 接口，fcntl 可以通过 F_SETFL 命令来修改文件描述符的访问模式。但是，fcntl 无法直接修改文件的权限，仍然需要使用 chmod 接口。</p><p>总的来说，fcntl 函数提供了更加细粒度的文件描述符和文件锁控制功能，可以实现一些比较复杂的操作，但对于一些简单的操作，如文件描述符的复制和文件权限的修改，还是可以使用 dup 和 chmod 接口</p>]]></content>
    
    
    <categories>
      
      <category>Linux编程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
