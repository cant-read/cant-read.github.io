<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Linux网络编程</title>
    <link href="/2023/06/03/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <url>/2023/06/03/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux网络编程"><a href="#Linux网络编程" class="headerlink" title="Linux网络编程"></a>Linux网络编程</h1><h2 id="基础API"><a href="#基础API" class="headerlink" title="基础API"></a>基础API</h2><h3 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h3><p>字节序就是字节在内存中排列方式，现代PC中大多小端序，<strong>主机字节序</strong>。</p><p>网络中，以大端序作为基准，因此被称为 <strong>网络字节序</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜netinet/in.h＞ </span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-title function_">htonl</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> hostlong)</span>; <br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> <span class="hljs-title function_">htons</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> hostshort)</span>; <br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ntohl</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> netlong)</span>; <br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ntohs</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> netshort)</span>;<br></code></pre></td></tr></table></figure><p>host to network long，用于转换IP地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">192</span>,<span class="hljs-number">168</span>,<span class="hljs-number">100</span>,<span class="hljs-number">1</span>&#125;;<br>    <span class="hljs-type">int</span> num = *(<span class="hljs-type">int</span>*)buf;<br>    <span class="hljs-type">int</span> ret = htonl(num);<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *p = (<span class="hljs-type">char</span>*) &amp;ret;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d,%d,%d,%d\n&quot;</span>,*p,*(p+<span class="hljs-number">1</span>),*(p+<span class="hljs-number">2</span>),*(p+<span class="hljs-number">3</span>));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="通用socket地址（不用）"><a href="#通用socket地址（不用）" class="headerlink" title="通用socket地址（不用）"></a>通用socket地址（不用）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/socket.h&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr</span> &#123;</span><br>    <span class="hljs-type">sa_family_t</span> sa_family; <span class="hljs-comment">//地址族类型 AF_INET ipv4 AF_UNIX</span><br>    <span class="hljs-type">char</span> sa_data[<span class="hljs-number">14</span>];<br>&#125;<br><span class="hljs-comment">// 新定义的</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_storage</span></span><br><span class="hljs-class">  &#123;</span><br>    __SOCKADDR_COMMON (ss_);<span class="hljs-comment">/* Address family, etc.  */</span><br>    <span class="hljs-type">char</span> __ss_padding[_SS_PADSIZE];<br>    __ss_aligntype __ss_align;<span class="hljs-comment">/* Force desired alignment.  */</span><br>  &#125;;<br></code></pre></td></tr></table></figure><p><strong>编程中基本上不用这个，会用专用的socket地址</strong></p><h3 id="专用scoket地址"><a href="#专用scoket地址" class="headerlink" title="专用scoket地址"></a>专用scoket地址</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> &#123;</span><br>  <span class="hljs-type">sa_family_t</span> sin_family;<span class="hljs-comment">/*地址族：AF_INET*/</span><br>  <span class="hljs-type">in_port_t</span> sin_port;<span class="hljs-comment">/*端口号，要用网络字节序表示*/</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span> <span class="hljs-title">sin_addr</span>;</span><span class="hljs-comment">/*IPv4地址结构体，见下面*/</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span> &#123;</span> <span class="hljs-type">u_int32_t</span> s_addr;<span class="hljs-comment">/*IPv4地址，要用网络字节序表示*/</span> &#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">uint16_t</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-type">uint32_t</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">uint16_t</span> <span class="hljs-type">in_port_t</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">uint32_t</span> <span class="hljs-type">in_addr_t</span>;<br></code></pre></td></tr></table></figure><p>所有专用 socket 地址（以及 sockaddr_storage）类型的变量在实际使用时都需要转化为通用socket地址类型 sockaddr（强制转化即可），因为所有 socket 编程接口使用的地址参数类型都是sockaddr。</p><h3 id="IP地址转换"><a href="#IP地址转换" class="headerlink" title="IP地址转换"></a>IP地址转换</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span> </span><br><span class="hljs-comment">// p:点分十进制的IP字符串，n:表示network，网络字节序的整数 </span><br> <span class="hljs-type">int</span> <span class="hljs-title function_">inet_pton</span><span class="hljs-params">(<span class="hljs-type">int</span> af, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *src, <span class="hljs-type">void</span> *dst)</span>;<br>af:地址族： AF_INET AF_INET6 <br>src:需要转换的点分十进制的IP字符串 <br>dst:转换后的结果保存在这个里面<br><br><span class="hljs-comment">// 将网络字节序的整数，转换成点分十进制的IP地址字符串 </span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title function_">inet_ntop</span><span class="hljs-params">(<span class="hljs-type">int</span> af, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *src, <span class="hljs-type">char</span> *dst, <span class="hljs-type">socklen_t</span> size)</span>; <br>af:地址族： AF_INET AF_INET6 <br>src: 要转换的ip的整数的地址 <br>dst: 转换成IP地址字符串保存的地方 <br>size：第三个参数的大小（数组的大小） <br>返回值：返回转换后的数据的地址（字符串），和 dst 是一样的<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">//创建一个ipv4的socket</span><br>    <span class="hljs-type">char</span> buf[] = <span class="hljs-string">&quot;192.168.1.1&quot;</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> num=<span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//将点分十进制的IP字符串转换为网络字节序的整数</span><br>    inet_pton(AF_INET,buf,&amp;num);<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>* p = (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*)&amp;num;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d.%d.%d.%d\n&quot;</span>,p[<span class="hljs-number">0</span>],p[<span class="hljs-number">1</span>],p[<span class="hljs-number">2</span>],p[<span class="hljs-number">3</span>]);<br>  <span class="hljs-comment">//将一个整数转换成点分十进制的ip地址</span><br>    <span class="hljs-type">char</span> ip[<span class="hljs-number">16</span>]=<span class="hljs-string">&quot;&quot;</span>;<br>    inet_ntop(AF_INET,&amp;num,ip,<span class="hljs-keyword">sizeof</span>(ip));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,ip);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br></code></pre></td></tr></table></figure><h3 id="TCP通信流程"><a href="#TCP通信流程" class="headerlink" title="TCP通信流程"></a>TCP通信流程</h3><h4 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h4><ol><li>创建监听的套接字（fd文件描述符）</li><li>将监听的fd和本地的IP和端口绑定</li><li>设置监听</li><li>阻塞等待，当有客户端发起连接时，接触阻塞，接受连接，得到一个和客户端通信的套接字<ul><li>accept()函数是阻塞的</li><li>这里的文件描述符是新建的，不是用于监听的那个fd</li></ul></li><li>通信，收发数据</li><li>通信结束，断开连接</li></ol><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><ol><li>创建用于通信的套接字</li><li>连接服务器，需要指定IP和port</li><li>通信</li><li>断开连接</li></ol><h3 id="scoket函数"><a href="#scoket函数" class="headerlink" title="scoket函数"></a>scoket函数</h3><p>看书和PPT</p><h3 id="TCP通信实现"><a href="#TCP通信实现" class="headerlink" title="TCP通信实现"></a>TCP通信实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">// 创建一个ipv4的socket</span><br>    <span class="hljs-type">int</span> cfd = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 连接服务器</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">serv</span>;</span><br>    <span class="hljs-built_in">memset</span>(&amp;serv.sin_addr.s_addr, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(serv.sin_addr.s_addr));<br>    serv.sin_family = AF_INET;<br>    inet_pton(AF_INET, <span class="hljs-string">&quot;127.0.0.101&quot;</span>, &amp;serv.sin_addr.s_addr);<br>    serv.sin_port = htons(<span class="hljs-number">8686</span>);<br>    <span class="hljs-type">int</span> ret = connect(cfd,(<span class="hljs-keyword">struct</span> sockaddr*)&amp;serv,<span class="hljs-keyword">sizeof</span>(serv));<br>    <span class="hljs-keyword">if</span>(ret==<span class="hljs-number">-1</span>)&#123;<br>        perror(<span class="hljs-string">&quot;connect error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br>    <span class="hljs-comment">// 通信</span><br>    <span class="hljs-type">char</span> *sendbuf=<span class="hljs-string">&quot;fuck you&quot;</span>;<br>    <span class="hljs-type">char</span> recvbuf[<span class="hljs-number">1024</span>] =&#123;<span class="hljs-number">0</span>&#125;;<br>    write(cfd,sendbuf,<span class="hljs-built_in">strlen</span>(sendbuf));<br>    <span class="hljs-type">int</span> len = read(cfd,recvbuf,<span class="hljs-keyword">sizeof</span>(recvbuf));<br>    <span class="hljs-keyword">if</span>(len==<span class="hljs-number">-1</span>)&#123;<br>        perror(<span class="hljs-string">&quot;read&quot;</span>);<br>        close(cfd);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(len&gt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;recv %s&quot;</span>,recvbuf);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(len==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;close&quot;</span>);<br>    &#125;<br>    close(cfd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 创建一个ipv4的socket</span><br>    <span class="hljs-type">int</span> lfd = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 绑定</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">serv</span>;</span><br>    <span class="hljs-built_in">memset</span>(&amp;serv.sin_addr.s_addr, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(serv.sin_addr.s_addr));<br>    serv.sin_family = AF_INET;<br>    inet_pton(AF_INET, <span class="hljs-string">&quot;127.0.0.101&quot;</span>, &amp;serv.sin_addr.s_addr);<br>    serv.sin_port = htons(<span class="hljs-number">8686</span>);<br>    <span class="hljs-type">int</span> ret = bind(lfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;serv, <span class="hljs-keyword">sizeof</span>(serv));<br>    assert(ret != <span class="hljs-number">-1</span>);<br>    <span class="hljs-comment">// 监听</span><br>    ret = listen(lfd, <span class="hljs-number">5</span>);<br>    assert(ret != <span class="hljs-number">-1</span>);<br>    <span class="hljs-comment">// 接受client</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">client</span>;</span><br>    <span class="hljs-type">socklen_t</span> len = <span class="hljs-keyword">sizeof</span>(client);<br>    <span class="hljs-type">int</span> cfd = accept(lfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;client, &amp;len);<br>    assert(cfd != <span class="hljs-number">-1</span>);<br>    <span class="hljs-comment">// 打印客户端信息</span><br>    <span class="hljs-type">char</span> client_addr[<span class="hljs-number">16</span>];<br>    inet_ntop(AF_INET, &amp;client.sin_addr.s_addr, client_addr, <span class="hljs-keyword">sizeof</span>(client_addr));<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> client_port = ntohs(client.sin_port);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;client ip %s , port %d&quot;</span>, client_addr, client_port);<br>    <span class="hljs-comment">// 通信</span><br>    <span class="hljs-type">char</span> recvbuf[<span class="hljs-number">1024</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span> length = read(cfd,recvbuf,<span class="hljs-keyword">sizeof</span>(recvbuf));<br>    <span class="hljs-keyword">if</span>(length==<span class="hljs-number">-1</span>)&#123;<br>        perror(<span class="hljs-string">&quot;read error&quot;</span>);<br>        close(cfd);<br>        close(lfd);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(length&gt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;recv buf:%s\n&quot;</span>,recvbuf);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(length==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;client close\n&quot;</span>);<br>        close(cfd);<br>        close(lfd);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-type">char</span>* data = <span class="hljs-string">&quot;hello world&quot;</span>;<br>    write(cfd,data,<span class="hljs-built_in">strlen</span>(data));<br>    <span class="hljs-comment">// 关闭</span><br>    close(cfd);<br>    close(lfd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="多进程实现并发服务器"><a href="#多进程实现并发服务器" class="headerlink" title="多进程实现并发服务器"></a>多进程实现并发服务器</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>一个父进程，多个子进程</li><li>父进程负责等待并接受客户端的连接</li><li>子进程：完成通信，接受到一个客户端连接，就创建一个子进程用于通信</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-comment">// 回收资源的回调，相当于一个软中断</span><br><span class="hljs-comment">// accpet阻塞的时候，如果有子进程退出，会触发回调函数，相当于一个软中断。回调函数执行完毕后，会返回到accpet的位置，继续向下执行，不再阻塞。那么就会导致accept返回-1，父进程退出，没办法处理新接入的客户端</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">recyleChild</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span><br>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-type">int</span> ret = waitpid(<span class="hljs-number">-1</span>, <span class="hljs-literal">NULL</span>, WNOHANG);<br>        <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>)<br>        &#123;<br>            <span class="hljs-comment">// 所有子进程都回收完毕</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-comment">// 还有子进程未回收完毕</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ret &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child died pid=%d\n&quot;</span>, ret);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 子进程退出信号</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigaction</span> <span class="hljs-title">act</span>;</span><br>    act.sa_flags = <span class="hljs-number">0</span>;<br>    sigemptyset(&amp;act.sa_mask);<br>    act.sa_handler = recyleChild;<br>    sigaction(SIGCHLD, &amp;act, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-comment">// 创建scoket</span><br>    <span class="hljs-type">int</span> lfd = socket(PF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (lfd == <span class="hljs-number">-1</span>)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;socket error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br>    <span class="hljs-comment">// 绑定</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">serv</span>;</span><br>    <span class="hljs-built_in">memset</span>(&amp;serv, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(serv));<br>    serv.sin_family = AF_INET;<br>    inet_pton(AF_INET, <span class="hljs-string">&quot;127.0.0.101&quot;</span>, &amp;serv.sin_addr.s_addr);<br>    serv.sin_port = htons(<span class="hljs-number">8686</span>);<br>    <span class="hljs-type">int</span> ret = bind(lfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;serv, <span class="hljs-keyword">sizeof</span>(serv));<br>    <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;bind error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br>    <span class="hljs-comment">// 监听</span><br>    ret = listen(lfd, <span class="hljs-number">5</span>);<br>    <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;listen error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br>    <span class="hljs-comment">// 循环</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-comment">// 接收连接</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">cliaddr</span>;</span><br>        <span class="hljs-type">socklen_t</span> len = <span class="hljs-keyword">sizeof</span>(cliaddr);<br>        <span class="hljs-type">int</span> cfd = accept(lfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;cliaddr, &amp;len);<br>        <span class="hljs-keyword">if</span> (cfd == <span class="hljs-number">-1</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (errno == EINTR)<br>            &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            perror(<span class="hljs-string">&quot;accept error&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>        &#125;<br>        <span class="hljs-type">pid_t</span> pid = fork();<br>        <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-type">char</span> cliIP[<span class="hljs-number">16</span>];<br>            inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr, cliIP, <span class="hljs-keyword">sizeof</span>(cliIP));<br>            <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> port = ntohs(cliaddr.sin_port);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;client IP:%s,port:%d\n&quot;</span>, cliIP, port);<br>            <span class="hljs-comment">// 通信</span><br>            <span class="hljs-type">char</span> recvBuf[<span class="hljs-number">1024</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>            &#123;<br>                <span class="hljs-type">int</span> len = read(cfd, recvBuf, <span class="hljs-keyword">sizeof</span>(recvBuf));<br>                <span class="hljs-keyword">if</span> (len == <span class="hljs-number">-1</span>)<br>                &#123;<br>                    perror(<span class="hljs-string">&quot;read error&quot;</span>);<br>                    <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (len &gt; <span class="hljs-number">0</span>)<br>                &#123;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;recv buf:%s\n&quot;</span>, recvBuf);<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;客户端已经断开连接\n&quot;</span>);<br>                    <span class="hljs-comment">// 当客户端关闭的时候，跳出循环，不进行下面的写数据操作</span><br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                write(cfd, recvBuf, <span class="hljs-built_in">strlen</span>(recvBuf) + <span class="hljs-number">1</span>);<br>            &#125;<br>            close(cfd);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;<br>    close(lfd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="多线程实现服务器"><a href="#多线程实现服务器" class="headerlink" title="多线程实现服务器"></a>多线程实现服务器</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sock_info_s</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> fd;<br>    <span class="hljs-type">pthread_t</span> tid;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">sockaddr</span>;</span><br>&#125;;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sock_info_s</span> <span class="hljs-title">sock_info_t</span>;</span><br><br><span class="hljs-type">sock_info_t</span> infos[<span class="hljs-number">128</span>];<br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">working</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-comment">// 子线程和客户端进行通信,可能需要cfd、客户端的信息、线程号</span><br>    <span class="hljs-type">char</span> client_ip[<span class="hljs-number">16</span>];<br>    <span class="hljs-type">sock_info_t</span> *client = (<span class="hljs-type">sock_info_t</span> *)arg;<br>    inet_ntop(AF_INET, &amp;(client-&gt;sockaddr.sin_addr.s_addr), client_ip, <span class="hljs-keyword">sizeof</span>(client_ip));<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> port = ntohs(client-&gt;sockaddr.sin_port);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;client IP:%s,port:%d\n&quot;</span>, client_ip, port);<br>    <span class="hljs-type">char</span> recv_buf[<span class="hljs-number">1024</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-type">int</span> len = read(client-&gt;fd, recv_buf, <span class="hljs-keyword">sizeof</span>(recv_buf));<br>        <span class="hljs-keyword">if</span> (len == <span class="hljs-number">-1</span>)<br>        &#123;<br>            perror(<span class="hljs-string">&quot;read error&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (len &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;recv buf:%s\n&quot;</span>, recv_buf);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;客户端已经断开连接\n&quot;</span>);<br>            <span class="hljs-comment">// 当客户端关闭的时候，跳出循环，不进行下面的写数据操作</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        write(client-&gt;fd, recv_buf, <span class="hljs-built_in">strlen</span>(recv_buf) + <span class="hljs-number">1</span>);<br>    &#125;<br>    close(client-&gt;fd);<br>    pthread_exit(<span class="hljs-literal">NULL</span>);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> lfd = socket(PF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (lfd == <span class="hljs-number">-1</span>)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;socket error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">serv</span>;</span><br>    <span class="hljs-built_in">memset</span>(&amp;serv, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(serv));<br>    serv.sin_family = AF_INET;<br>    inet_pton(AF_INET, <span class="hljs-string">&quot;0.0.0.0&quot;</span>, &amp;serv.sin_addr.s_addr);<br>    serv.sin_port = htons(<span class="hljs-number">8686</span>);<br>    <span class="hljs-type">int</span> ret = bind(lfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;serv, <span class="hljs-keyword">sizeof</span>(serv));<br>    <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;bind error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br>    ret = listen(lfd, <span class="hljs-number">5</span>);<br>    <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;listen error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br>    <span class="hljs-type">char</span> recv_buf[<span class="hljs-number">1024</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-comment">// 初始化infos</span><br>    <span class="hljs-type">int</span> max = <span class="hljs-keyword">sizeof</span>(infos) / <span class="hljs-keyword">sizeof</span>(infos[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; max; i++)<br>    &#123;<br>        <span class="hljs-built_in">memset</span>(&amp;infos[i], <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(infos[i]));<br>        <span class="hljs-comment">// -1表示该文件描述符待用</span><br>        infos[i].fd = <span class="hljs-number">-1</span>;<br>        infos[i].tid = <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    whil<br>    &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">client_addr</span>;</span><br>        <span class="hljs-type">socklen_t</span> client_addr_len = <span class="hljs-keyword">sizeof</span>(client_addr);<br>        <span class="hljs-type">int</span> cfd = accept(lfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;client_addr, &amp;client_addr_len);<br>        <span class="hljs-comment">// 创建子线程</span><br>        <span class="hljs-comment">// 这里非常重要，需要向子线程中传递参数，使用结构体进行了封装。</span><br>        <span class="hljs-comment">// 但是后续就会出现一系列的问题，参数需要构建在堆上、需要对申请的内存进行释放、当线程很多时内存的分配消耗很大</span><br>        <span class="hljs-type">sock_info_t</span> *ptr_info;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; max; i++)<br>        &#123;<br>            <span class="hljs-comment">// 从数组中找到一个可用的sockinfo的元素,这里使用线性遍历</span><br>            <span class="hljs-keyword">if</span> (infos[i].fd == <span class="hljs-number">-1</span>)<br>            &#123;<br>                ptr_info = &amp;infos[i];<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (i == max - <span class="hljs-number">1</span>)<br>            &#123;<br>                sleep(<span class="hljs-number">1</span>);<br>                i = <span class="hljs-number">-1</span>;<br>            &#125;<br>        &#125;<br>        ptr_info-&gt;fd = cfd;<br>        <span class="hljs-built_in">memcpy</span>(&amp;ptr_info-&gt;sockaddr, &amp;client_addr, client_addr_len);<br>        pthread_create(&amp;ptr_info-&gt;tid, <span class="hljs-literal">NULL</span>, working, ptr_info);<br>        <span class="hljs-comment">// 不能用pthread_join，会一直阻塞</span><br>        pthread_detach(ptr_info-&gt;tid);<br>    &#125;<br>    close(lfd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="端口复用"><a href="#端口复用" class="headerlink" title="端口复用"></a>端口复用</h2><p>setsockopt(lfd, SOL_SOKCET, &amp;optval, sizeof(optval))</p><p>在bind()函数之前调用才会生效</p><h2 id="I-x2F-O多路复用技术"><a href="#I-x2F-O多路复用技术" class="headerlink" title="I&#x2F;O多路复用技术"></a>I&#x2F;O多路复用技术</h2><h3 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h3><p><a href="https://zhuanlan.zhihu.com/p/115220699">https://zhuanlan.zhihu.com/p/115220699</a> 一文看懂IO多路复用</p><p><a href="https://zhuanlan.zhihu.com/p/367591714">https://zhuanlan.zhihu.com/p/367591714</a> 深入浅出理解select、poll、epoll的实现</p><h3 id="B站视频笔记"><a href="#B站视频笔记" class="headerlink" title="B站视频笔记"></a>B站视频笔记</h3><p><a href="https://www.bilibili.com/video/BV1qJ411w7du/?spm_id_from=333.337.search-card.all.click&vd_source=341953e3cc61103cce8a3b9bf2c71374">https://www.bilibili.com/video/BV1qJ411w7du/?spm_id_from=333.337.search-card.all.click&amp;vd_source=341953e3cc61103cce8a3b9bf2c71374</a></p><h4 id="出现场景"><a href="#出现场景" class="headerlink" title="出现场景"></a>出现场景</h4><p>设计高性能网络服务器，对应并发请求。可以选择多线程，但是多线程需要CPU上下文切换，切换带来的代价比较高。</p><p>所以将目光转到单线程。单线程怎么出来大量的连接呢？当A发送消息时，B发送消息，会不会丢失呢？不会的。有DMA控制器。</p><p>在Linux系统中，每个网络连接都被视为文件。</p><p>一般人：遍历网络连接的文件描述符。判断里面有没有新的数据。</p><img src="截屏2023-03-27 16.23.25.png" alt="截屏2023-03-27 16.23.25" style="zoom: 33%;" /><h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>SELECT函数会将要监听的<strong>文件bitmap拷贝到内核态</strong>。如果没有数据到来，程序会一直阻塞到select这一行。</p><h5 id="当有数据到来的时候："><a href="#当有数据到来的时候：" class="headerlink" title="当有数据到来的时候："></a>当有数据到来的时候：</h5><ol><li>select函数会将rset中对应的fd置位，标识为有数据到来。</li><li>select函数返回，程序继续向下执行。返回后要遍历所有的文件描述符，因为可能会同时有多个数据到来。</li></ol><h5 id="select函数提高效率："><a href="#select函数提高效率：" class="headerlink" title="select函数提高效率："></a>select函数提高效率：</h5><p>将fdset放到了内核态，由内核去判断。</p><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ol><li>bitmap -》 rset的大小有限制</li><li>每次的rset是不能重用的。每次循环的开头，都要有<code>FD_ZERO(&amp;rset)</code>函数对其进行重制。</li><li>用户态到内核态仍然有开销</li><li>select返回后，并不知道是哪一个文件有了新数据。需要遍历一遍，有一个O(N)的开销。</li></ol><h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><img src="截屏2023-03-27 16.47.30.png" alt="截屏2023-03-27 16.47.30" style="zoom:50%;" /><p>poll方法在库中自己定义了一个结构体polldf，包含了文件描述符、可执行的事件、要返回的事件。</p><p>poll方法将结构体数组拷贝到内核态，当有数据到来的时候，将revents置位，poll返回。</p><p>程序进行对文件的处理，但是在处理之前要将revent置为0。这样就保证了对该pollfd数组的重用。</p><h5 id="poll的改进之处"><a href="#poll的改进之处" class="headerlink" title="poll的改进之处"></a>poll的改进之处</h5><ol><li>改进了select的前两个缺点。没有文件描述符的限制</li><li>可以重用fd数组</li></ol><p>但是用户内核态切换的开销没有变，每次返回需要遍历的缺点也没有变</p><h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><ol><li>先用<code>epoll_create()</code>创建epfd。epfd可以理解为一个白板。</li><li>然后用<code>epoll_ctl()</code>，对epfd进行配置。增加文件描述符、对应的事件。这些变量用epoll_event结构体储存。</li><li>epfd是在内核态和用户态中共享的，不再进行拷贝了。这样就解决了第3个缺点。</li><li>最后是<code>epoll_wait()</code>，没数据就阻塞。</li><li>有数据时：<ol><li>置位，通过重排。eg：将有数据的fd放到最前面的位置。有多个就将其都往前放。</li><li>返回值为触发事件的fd总数 &#x3D;nfd。</li></ol></li><li>程序向下运行，只需要遍历前nfd个文件描述符就好</li></ol><img src="截屏2023-03-27 17.10.11.png" alt="截屏2023-03-27 17.10.11" style="zoom:33%;" /><p>redis 和 nginx都用的epoll</p><p>java的NIO 底层也是epoll</p><h2 id="IO多路复用《手册》"><a href="#IO多路复用《手册》" class="headerlink" title="IO多路复用《手册》"></a>IO多路复用《手册》</h2><h3 id="整体概览"><a href="#整体概览" class="headerlink" title="整体概览"></a>整体概览</h3><p>IO多路复用的目的是同时检查多个文件，看他们是否做好执行IO操作的准备。</p><h4 id="为什么不用非阻塞和多进-x2F-线程？"><a href="#为什么不用非阻塞和多进-x2F-线程？" class="headerlink" title="为什么不用非阻塞和多进&#x2F;线程？"></a>为什么不用非阻塞和多进&#x2F;线程？</h4><p>非阻塞IO需要我们不断的轮询，如果轮询的频率不高，就会导致相应IO的事件延迟很高。而在一个循环中不断的轮询，是浪费CPU的操作。</p><p>多进程和线程都存在着开销昂贵且复杂的问题，同时父子之间需要通信机制去通知IO事件。</p><h4 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h4><h5 id="select和poll的优缺点"><a href="#select和poll的优缺点" class="headerlink" title="select和poll的优缺点"></a>select和poll的优缺点</h5><p>优点：方便移植，缺点：同时检查大量的文件性能低</p><h5 id="epoll优缺点"><a href="#epoll优缺点" class="headerlink" title="epoll优缺点"></a>epoll优缺点</h5><p>优点：性能高，缺点：linux专属</p><h5 id="解决移植性"><a href="#解决移植性" class="headerlink" title="解决移植性"></a>解决移植性</h5><p>需要编写软件抽象层去检查底层的文件描述符，进行机制的选用。</p><h4 id="水平触发和边缘触发"><a href="#水平触发和边缘触发" class="headerlink" title="水平触发和边缘触发"></a>水平触发和边缘触发</h4><ul><li>水平触发：文件描述符可以进行操作了（select、poll、epoll），可以任意时刻检查文件描述符</li><li>边缘触发：和上次比有了新的变化（epoll）尽可能在通知来了以后的某一时刻尽可能多的读写</li></ul><h4 id="非阻塞IO"><a href="#非阻塞IO" class="headerlink" title="非阻塞IO"></a>非阻塞IO</h4><p>在IO多路复用中应该将要监听的文件设置为非阻塞的</p><h3 id="I-x2F-O多路复用（select和poll）"><a href="#I-x2F-O多路复用（select和poll）" class="headerlink" title="I&#x2F;O多路复用（select和poll）"></a>I&#x2F;O多路复用（select和poll）</h3><h4 id="select-1"><a href="#select-1" class="headerlink" title="select()"></a>select()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/select.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> lfd = socket(PF_INET,SOCK_STREAM,<span class="hljs-number">0</span>);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">saddr</span>;</span><br>    saddr.sin_port=htons(<span class="hljs-number">9999</span>);<br>    saddr.sin_family = AF_INET;<br>    saddr.sin_addr.s_addr = INADDR_ANY;<br>    bind(lfd,(<span class="hljs-keyword">struct</span> sockaddr*)&amp;saddr,<span class="hljs-keyword">sizeof</span>(saddr));<br>    listen(lfd,<span class="hljs-number">8</span>);<br>    <span class="hljs-comment">// 创建一个fd_set的集合，存放需要检测的文件描述符</span><br>    fd_set rdset,tempset;<br>    FD_ZERO(&amp;rdset);<br>    FD_SET(lfd,&amp;rdset);<br>    <span class="hljs-type">int</span> max_fd = lfd;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        tempset = rdset;<br>        <span class="hljs-comment">// 调用select系统函数，让内核帮忙检测哪些文件描述符有数据</span><br>        <span class="hljs-type">int</span> ret = select(max_fd+<span class="hljs-number">1</span>,&amp;tempset,<span class="hljs-literal">NULL</span>,<span class="hljs-literal">NULL</span>,<span class="hljs-literal">NULL</span>);<br>        <span class="hljs-keyword">if</span>(ret==<span class="hljs-number">-1</span>)&#123;<br>            perror(<span class="hljs-string">&quot;select&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">// 说明监测到了文件描述符对应的缓冲区数据发生了改变</span><br>            <span class="hljs-keyword">if</span>(FD_ISSET(lfd,&amp;tempset))&#123;<br>                <span class="hljs-comment">// 表示有新的客户端连接进来了</span><br>                <span class="hljs-keyword">struct</span> sockaddr_in cliaddr;<br>                <span class="hljs-type">int</span> len = <span class="hljs-keyword">sizeof</span>(cliaddr);<br>                <span class="hljs-type">int</span> cfd = accept(lfd,(<span class="hljs-keyword">struct</span> sockaddr*)&amp;cliaddr,&amp;len);<br>                <span class="hljs-comment">// 将新的文件描述符加入到集合中</span><br>                FD_SET(cfd,&amp;rdset);<br>                max_fd = max_fd&gt;cfd?max_fd:cfd;<br>            &#125;<br>            <span class="hljs-comment">// 遍历集合，找到有数据的文件描述符</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=lfd+<span class="hljs-number">1</span>;i&lt;max_fd+<span class="hljs-number">1</span>;i++)&#123;<br>                <span class="hljs-keyword">if</span>(FD_ISSET(i,&amp;rdset))&#123;<br>                    <span class="hljs-comment">// 说明文件描述符i有数据</span><br>                    <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br>                    <span class="hljs-type">int</span> len = recv(i,buf,<span class="hljs-keyword">sizeof</span>(buf),<span class="hljs-number">0</span>);<br>                    <span class="hljs-keyword">if</span>(len==<span class="hljs-number">-1</span>)&#123;<br>                        perror(<span class="hljs-string">&quot;recv&quot;</span>);<br>                        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>                    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(len==<span class="hljs-number">0</span>)&#123;<br>                        <span class="hljs-comment">// 客户端关闭了连接</span><br>                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;客户端关闭了连接\n&quot;</span>);<br>                        close(i);<br>                        FD_CLR(i,&amp;rdset);<br>                    &#125;<span class="hljs-keyword">else</span>&#123;<br>                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;recv buf:%s\n&quot;</span>,buf);<br>                        <span class="hljs-comment">// send(i,&quot;ok&quot;,2,0);</span><br>                        write(i,buf,<span class="hljs-built_in">strlen</span>(buf)+<span class="hljs-number">1</span>);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    close(lfd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="poll-1"><a href="#poll-1" class="headerlink" title="poll()"></a>poll()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/poll.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> lfd = socket(PF_INET,SOCK_STREAM,<span class="hljs-number">0</span>);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">saddr</span>;</span><br>    saddr.sin_port=htons(<span class="hljs-number">9999</span>);<br>    saddr.sin_family = AF_INET;<br>    saddr.sin_addr.s_addr = INADDR_ANY;<br>    bind(lfd,(<span class="hljs-keyword">struct</span> sockaddr*)&amp;saddr,<span class="hljs-keyword">sizeof</span>(saddr));<br>    listen(lfd,<span class="hljs-number">8</span>);<br>    <span class="hljs-comment">// 初始化pollfd结构体数组，fds[1]-fds[1023]存放需要监测的文件描述符,初始化为-1</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pollfd</span> <span class="hljs-title">fds</span>[1024];</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">1024</span>;i++)&#123;<br>        fds[i].fd = <span class="hljs-number">-1</span>;<br>        fds[i].events = POLLIN;<br>    &#125;<br>    fds[<span class="hljs-number">0</span>].fd = lfd;<br>    <span class="hljs-type">int</span> nfds = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-comment">// nfd 是需要监测的文件描述符的个数，个数，个数</span><br>        <span class="hljs-type">int</span> ret = poll(fds,nfds,<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">if</span>(ret==<span class="hljs-number">-1</span>)&#123;<br>            perror(<span class="hljs-string">&quot;poll&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">// 说明监测到了文件描述符对应的缓冲区数据发生了改变</span><br>            <span class="hljs-comment">// revents的值可能是多个状态的或，所以不能用==去判断</span><br>            <span class="hljs-keyword">if</span>(fds[<span class="hljs-number">0</span>].revents&amp;POLLIN)&#123;<br>                <span class="hljs-comment">// 表示有新的客户端连接进来了</span><br>                <span class="hljs-keyword">struct</span> sockaddr_in cliaddr;<br>                <span class="hljs-type">int</span> len = <span class="hljs-keyword">sizeof</span>(cliaddr);<br>                <span class="hljs-type">int</span> cfd = accept(lfd,(<span class="hljs-keyword">struct</span> sockaddr*)&amp;cliaddr,&amp;len);<br>                <span class="hljs-comment">// 将新的文件描述符加入到集合中</span><br>                <span class="hljs-type">int</span> new_nfd = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;<span class="hljs-number">1024</span>;i++)&#123;<br>                    <span class="hljs-keyword">if</span>(fds[i].fd==<span class="hljs-number">-1</span>)&#123;<br>                        fds[i].fd = cfd;<br>                        fds[i].events = POLLIN;<br>                        <span class="hljs-comment">// 比如说nfd是1，现在加了一个，就变成2了，需要在序号的基础上加1</span><br>                        new_nfd = i+<span class="hljs-number">1</span>;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>                nfds = nfds&gt;new_nfd?nfds:new_nfd;<br>            &#125;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;nfd:%d\n&quot;</span>,nfds);<br>            <span class="hljs-comment">// 遍历集合，找到有数据的文件描述符</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;nfds+<span class="hljs-number">1</span>;i++)&#123;<br>                <span class="hljs-keyword">if</span>(fds[i].revents&amp;POLLIN)&#123;<br>                    <span class="hljs-comment">// 说明文件描述符i有数据</span><br>                    <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br>                    <span class="hljs-type">int</span> len = recv(fds[i].fd,buf,<span class="hljs-keyword">sizeof</span>(buf),<span class="hljs-number">0</span>);<br>                    <span class="hljs-keyword">if</span>(len==<span class="hljs-number">-1</span>)&#123;<br>                        perror(<span class="hljs-string">&quot;recv&quot;</span>);<br>                        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>                    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(len==<span class="hljs-number">0</span>)&#123;<br>                        <span class="hljs-comment">// 客户端关闭了连接</span><br>                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;客户端关闭了连接\n&quot;</span>);<br>                        close(fds[i].fd);<br>                        fds[i].fd = <span class="hljs-number">-1</span>;<br>                    &#125;<span class="hljs-keyword">else</span>&#123;<br>                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;recv buf:%s\n&quot;</span>,buf);<br>                        write(fds[i].fd,buf,<span class="hljs-built_in">strlen</span>(buf)+<span class="hljs-number">1</span>);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    close(lfd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="epoll的两种工作模式"><a href="#epoll的两种工作模式" class="headerlink" title="epoll的两种工作模式"></a>epoll的两种工作模式</h3><h4 id="ET模式"><a href="#ET模式" class="headerlink" title="ET模式"></a>ET模式</h4><p>文件描述符变化后，会通知，然后就不会再进行通知了。所以这个模式下，需要在通知到来以后，尽可能将缓冲区的数据读进来。</p><p>ET模式的效率高，因为减少了epoll事件被重复触发的次数。</p><p>epoll使用ET模式的时候，必须使用非阻塞套接口，避免由于一个文件句柄的堵塞IO操作将处理多个文件描述符的任务饿死。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 创建socket</span><br>    <span class="hljs-type">int</span> lfd = socket(PF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">saddr</span>;</span><br>    saddr.sin_port = htons(<span class="hljs-number">9999</span>);<br>    saddr.sin_family = AF_INET;<br>    saddr.sin_addr.s_addr = INADDR_ANY;<br>    <span class="hljs-comment">// 绑定</span><br>    bind(lfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;saddr, <span class="hljs-keyword">sizeof</span>(saddr));<br>    <span class="hljs-comment">// 监听</span><br>    listen(lfd, <span class="hljs-number">8</span>);<br>    <span class="hljs-comment">// 调用epoll_create()创建一个epoll实例</span><br>    <span class="hljs-type">int</span> epfd = epoll_create(<span class="hljs-number">100</span>);<br>    <span class="hljs-comment">// 将监听的文件描述符相关的检测信息添加到epoll实例中</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> <span class="hljs-title">epev</span>;</span><br>    epev.events = EPOLLIN;<br>    epev.data.fd = lfd;<br>    epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &amp;epev);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">epoll_event</span> <span class="hljs-title">epevs</span>[1024];</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-type">int</span> ret = epoll_wait(epfd, epevs, <span class="hljs-number">1024</span>, <span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>)<br>        &#123;<br>            perror(<span class="hljs-string">&quot;epoll_wait&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ret = %d\n&quot;</span>, ret);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ret; i++)<br>        &#123;<br>            <span class="hljs-type">int</span> curfd = epevs[i].data.fd;<br>            <span class="hljs-keyword">if</span> (curfd == lfd)<br>            &#123;<br>                <span class="hljs-comment">// 监听的文件描述符有数据达到，有客户端连接</span><br>                <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> <span class="hljs-title">cliaddr</span>;</span><br>                <span class="hljs-type">int</span> len = <span class="hljs-keyword">sizeof</span>(cliaddr);<br>                <span class="hljs-type">int</span> cfd = accept(lfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;cliaddr, &amp;len);<br><br>                <span class="hljs-comment">// 设置cfd属性非阻塞</span><br>                <span class="hljs-type">int</span> flag = fcntl(cfd, F_GETFL);<br>                flag |= O_NONBLOCK;<br>                fcntl(cfd, F_SETFL, flag);<br><br>                epev.events = EPOLLIN | EPOLLET; <span class="hljs-comment">// 设置边沿触发</span><br>                epev.data.fd = cfd;<br>                epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &amp;epev);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">if</span> (epevs[i].events &amp; EPOLLOUT)<br>                &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-comment">// 循环读取出所有数据</span><br>                <span class="hljs-type">char</span> buf[<span class="hljs-number">5</span>];<br>                <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">while</span> ((len = read(curfd, buf, <span class="hljs-keyword">sizeof</span>(buf))) &gt; <span class="hljs-number">0</span>)<br>                &#123;<br>                    <span class="hljs-comment">// 打印数据</span><br>                    write(STDOUT_FILENO, buf, len);<br>                    write(curfd, buf, len);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>)<br>                &#123;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;client closed....\n&quot;</span>);<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (len == <span class="hljs-number">-1</span>)<br>                &#123;<br>                    <span class="hljs-comment">// 非阻塞IO，重复读数据，此时程序不会阻塞起来等待数据准备就绪返回，read函数会返回一个错误EAGAIN，提示你的应用程序现在没有数据可读请稍后再试。</span><br>                    <span class="hljs-keyword">if</span> (errno == EAGAIN)<br>                    &#123;<br>                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;data over.....\n&quot;</span>);<br>                    &#125;<br>                   <span class="hljs-comment">// 解决 read: Connection reset by peer</span><br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (errno == ECONNRESET)<br>                    &#123;<br>                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;client reset....\n&quot;</span>);<br>                    &#125;<br>                    <span class="hljs-keyword">else</span><br>                    &#123;<br>                        perror(<span class="hljs-string">&quot;read&quot;</span>);<br>                        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    close(lfd);<br>    close(epfd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="问题1-在关闭客户端的时候，可能会报错read-Connection-reset-by-peer"><a href="#问题1-在关闭客户端的时候，可能会报错read-Connection-reset-by-peer" class="headerlink" title="问题1:在关闭客户端的时候，可能会报错read: Connection reset by peer"></a>问题1:在关闭客户端的时候，可能会报错read: Connection reset by peer</h5><p>这个是正常现象，即客户端关闭后，服务器向客户端通信，会产生该错误。可以针对该错误进行catch，也可以在客户端关闭前sleep(1)，让其能接收到服务端的消息。</p><h4 id="LT模式"><a href="#LT模式" class="headerlink" title="LT模式"></a>LT模式</h4><p>缓冲区有数据-》epoll会进行通知</p><ol><li>不读数据，一直通知</li><li>读了一部分，一直通知</li><li>读完了，不通知</li></ol>]]></content>
    
    
    <categories>
      
      <category>Linux编程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux多线程</title>
    <link href="/2023/06/03/Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <url>/2023/06/03/Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux多线程"><a href="#Linux多线程" class="headerlink" title="Linux多线程"></a>Linux多线程</h1><h2 id="线程概述（PPT）"><a href="#线程概述（PPT）" class="headerlink" title="线程概述（PPT）"></a>线程概述（PPT）</h2><p>线程和进程是类似的，也是去完成并发任务，一般线程会处理相同的任务。</p><p>线程是轻量级的进程，线程之间共享数据很方便。</p><p>进程的代价是比较高的，尽管使用了写时复制的技术，但是仍然需要复制多种表。</p><h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C">一般情况下,main函数所在的线程我们称之为主线程（main线程），其余创建的线程<br>称之为子线程。<br>程序中默认只有一个进程，fork()函数调用，<span class="hljs-number">2</span>进行<br>程序中默认只有一个线程，pthread_create()函数调用，<span class="hljs-number">2</span>个线程。<br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_create</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> *thread, <span class="hljs-type">const</span> <span class="hljs-type">pthread_attr_t</span> *attr, <span class="hljs-type">void</span> *(*start_routine) (<span class="hljs-type">void</span> *), <span class="hljs-type">void</span> *arg)</span>;<br>    - 功能：创建一个子线程<br>    - 参数：<br>        - thread：传出参数，线程创建成功后，子线程的线程ID被写到该变量中。<br>        - attr : 设置线程的属性，一般使用默认值，<span class="hljs-literal">NULL</span><br>        - start_routine : 函数指针，这个函数是子线程需要处理的逻辑代码<br>        - arg : 给第三个参数使用，传参<br>    - 返回值：<br>        成功：<span class="hljs-number">0</span><br>        失败：返回错误号。这个错误号和之前errno不太一样。<br>        获取错误号的信息：  <span class="hljs-type">char</span> * <span class="hljs-title function_">strerror</span><span class="hljs-params">(<span class="hljs-type">int</span> errnum)</span>;<br></code></pre></td></tr></table></figure><h3 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">callback</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World!\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;arg: %s\n&quot;</span>, (<span class="hljs-type">char</span>*)arg);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">pthread_t</span> tid;<br>    <span class="hljs-type">char</span>* arg = <span class="hljs-string">&quot;i am arg!&quot;</span>;<br>    <span class="hljs-type">int</span> ret = pthread_create(&amp;tid, <span class="hljs-literal">NULL</span>, callback, arg);<br>    <span class="hljs-keyword">if</span> (ret != <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-type">char</span> *errstr = strerror(ret);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pthread_create error: %s\n&quot;</span>, errstr);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;main thread: %d\n&quot;</span>, i);<br>        sleep(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在编译这个代码的时候，需要加 -l pthread</p><p>如果不将主线程sleep，子线程可能抢占不到CPU，就直接结束了。</p><h2 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h2><p><code>void pthread_exit(void *retval);</code></p><ul><li>功能：终止一个线程，在哪个线程中调用，就表示终止哪个线程</li><li>参数：<ul><li>retval ：需要传递一个指针，作为一个返回值，可以在pthread_join()中获取到。</li></ul></li></ul><p> <code>pthread_t pthread_self(void);</code></p><ul><li>功能：获取当前的线程的线程ID</li></ul><p><code>int pthread_equal(pthread_t t1, pthread_t t2);</code></p><ul><li>功能：比较两个线程ID是否相等</li><li>不同的操作系统，pthread_t类型的实现不一样，有的是无符号的长整型，有的是使用结构体去实现的。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-type">void</span> * <span class="hljs-title function_">callback</span><span class="hljs-params">(<span class="hljs-type">void</span> * arg)</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child thread id : %ld\n&quot;</span>, pthread_self());<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;    <span class="hljs-comment">// pthread_exit(NULL);</span><br>&#125; <br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 创建一个子线程</span><br>    <span class="hljs-type">pthread_t</span> tid;<br>    <span class="hljs-type">int</span> ret = pthread_create(&amp;tid, <span class="hljs-literal">NULL</span>, callback, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span>(ret != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">char</span> * errstr = strerror(ret);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error : %s\n&quot;</span>, errstr);<br>    &#125;<br>    <span class="hljs-comment">// 主线程</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, i);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;tid : %ld, main thread id : %ld\n&quot;</span>, tid ,pthread_self());<br>    <span class="hljs-comment">// 让主线程退出,当主线程退出时，不会影响其他正常运行的线程。</span><br>    pthread_exit(<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;main thread exit\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   <span class="hljs-comment">// exit(0);</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="连接已经终止的线程"><a href="#连接已经终止的线程" class="headerlink" title="连接已经终止的线程"></a>连接已经终止的线程</h2><p><code>int pthread_join(pthread_t thread, void **retval);</code></p><ul><li><p>功能：和一个已经终止的线程进行连接</p><ul><li><p>回收子线程的资源</p></li><li><p>这个函数是阻塞函数，调用一次只能回收一个子线程</p></li><li><p>一般在主线程中使用</p></li></ul></li><li><p>参数：</p><ul><li>thread：需要回收的子线程的ID</li><li>retval: 接收子线程退出时的返回值</li></ul></li><li><p>返回值：</p><ul><li>0 : 成功</li><li>非0 : 失败，返回的错误号</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> value = <span class="hljs-number">10</span>;<br><span class="hljs-type">void</span> * <span class="hljs-title function_">callback</span><span class="hljs-params">(<span class="hljs-type">void</span> * arg)</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child thread id : %ld\n&quot;</span>, pthread_self());<br>    <span class="hljs-comment">// sleep(3);</span><br>    <span class="hljs-comment">// return NULL; </span><br>    <span class="hljs-comment">// int value = 10; // 局部变量</span><br>    pthread_exit((<span class="hljs-type">void</span> *)&amp;value);   <span class="hljs-comment">// return (void *)&amp;value;</span><br>&#125; <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 创建一个子线程</span><br>    <span class="hljs-type">pthread_t</span> tid;<br>    <span class="hljs-type">int</span> ret = pthread_create(&amp;tid, <span class="hljs-literal">NULL</span>, callback, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span>(ret != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">char</span> * errstr = strerror(ret);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error : %s\n&quot;</span>, errstr);<br>    &#125;<br>    <span class="hljs-comment">// 主线程</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, i);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;tid : %ld, main thread id : %ld\n&quot;</span>, tid ,pthread_self());<br>    <span class="hljs-comment">// 主线程调用pthread_join()回收子线程的资源</span><br>    <span class="hljs-type">int</span> * thread_retval;<br>    ret = pthread_join(tid, (<span class="hljs-type">void</span> **)&amp;thread_retval);<br>    <span class="hljs-keyword">if</span>(ret != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">char</span> * errstr = strerror(ret);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error : %s\n&quot;</span>, errstr);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;exit data : %d\n&quot;</span>, *thread_retval);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;回收子线程资源成功！\n&quot;</span>);<br>    <span class="hljs-comment">// 让主线程退出,当主线程退出时，不会影响其他正常运行的线程。</span><br>    pthread_exit(<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br></code></pre></td></tr></table></figure><p>当子线程的局部变量通过pthread_exit传出的时候，在主线程中接收到的是错误的值。因为子线程推出后，局部变量的<strong>栈空间</strong>会被编译器清空。所以不能使用这样的方式进行传参。应该传全局变量。</p><h2 id="线程分离"><a href="#线程分离" class="headerlink" title="线程分离"></a>线程分离</h2><p><code>int pthread_detach(pthread_t thread);</code></p><ul><li>功能：分离一个线程。<ul><li><p>被分离的线程在终止的时候，会自动释放资源返回给系统。</p></li><li><p>不能多次分离，会产生不可预料的行为。</p></li><li><p>不能去连接一个已经分离的线程，会报错。</p></li><li><p>参数：需要分离的线程的ID</p></li><li><p>返回值：</p><ul><li>成功：0</li><li>失败：返回错误号</li></ul></li></ul></li></ul><h2 id="线程取消"><a href="#线程取消" class="headerlink" title="线程取消"></a>线程取消</h2><p><code>int pthread_cancel(pthread_t thread);</code></p><ul><li>功能：取消线程（让线程终止）<ul><li>取消某个线程，可以终止某个线程的运行，</li><li>但是并不是立马终止，而是当子线程执行到一个取消点，线程才会终止。</li><li>取消点：系统规定好的一些系统调用，我们可以粗略的理解为从用户区到内核区的切换，这个位置称之为取消点。</li></ul></li></ul><h2 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    int pthread_attr_init(pthread_attr_t *attr);</span><br><span class="hljs-comment">        - 初始化线程属性变量</span><br><span class="hljs-comment">    int pthread_attr_destroy(pthread_attr_t *attr);</span><br><span class="hljs-comment">        - 释放线程属性的资源</span><br><span class="hljs-comment">    int pthread_attr_getdetachstate(const pthread_attr_t *attr, int *detachstate);</span><br><span class="hljs-comment">        - 获取线程分离的状态属性</span><br><span class="hljs-comment">    int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);</span><br><span class="hljs-comment">        - 设置线程分离的状态属性</span><br><span class="hljs-comment">*/</span>     <br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">void</span> * <span class="hljs-title function_">callback</span><span class="hljs-params">(<span class="hljs-type">void</span> * arg)</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;chid thread id : %ld\n&quot;</span>, pthread_self());<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 创建一个线程属性变量</span><br>    <span class="hljs-type">pthread_attr_t</span> attr;<br>    <span class="hljs-comment">// 初始化属性变量</span><br>    pthread_attr_init(&amp;attr);<br>    <span class="hljs-comment">// 设置属性</span><br>    pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);<br>    <span class="hljs-comment">// 创建一个子线程</span><br>    <span class="hljs-type">pthread_t</span> tid;<br>    <span class="hljs-type">int</span> ret = pthread_create(&amp;tid, &amp;attr, callback, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span>(ret != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">char</span> * errstr = strerror(ret);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error1 : %s\n&quot;</span>, errstr);<br>    &#125;<br>    <span class="hljs-comment">// 获取线程的栈的大小</span><br>    <span class="hljs-type">size_t</span> size;<br>    pthread_attr_getstacksize(&amp;attr, &amp;size);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;thread stack size : %ld\n&quot;</span>, size);<br>    <span class="hljs-comment">// 输出主线程和子线程的id</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;tid : %ld, main thread id : %ld\n&quot;</span>, tid, pthread_self());<br>    <span class="hljs-comment">// 释放线程属性资源</span><br>    pthread_attr_destroy(&amp;attr);<br>    pthread_exit(<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="线程同步（PPT）"><a href="#线程同步（PPT）" class="headerlink" title="线程同步（PPT）"></a>线程同步（PPT）</h2><h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><p>互斥量的类型 pthread_mutex_t</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_mutex_init</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *<span class="hljs-keyword">restrict</span> mutex, <span class="hljs-type">const</span> <span class="hljs-type">pthread_mutexattr_t</span> *<span class="hljs-keyword">restrict</span> attr)</span>;<br></code></pre></td></tr></table></figure><p>初始化互斥量</p><ul><li><p>参数</p><ul><li><p>mutex ： 需要初始化的互斥量变量</p></li><li><p>attr ： 互斥量相关的属性，NULL<br>- restrict : C语言的修饰符，被修饰的指针，不能由另外的一个指针进行操作。<br>pthread_mutex_t *restrict mutex &#x3D; xxx;<br>pthread_mutex_t * mutex1 &#x3D; mutex;</p></li></ul></li></ul><p><code>int pthread_mutex_destroy(pthread_mutex_t *mutex);</code></p><p>释放互斥量的资源</p><p><code>int pthread_mutex_lock(pthread_mutex_t *mutex);</code></p><p>加锁，阻塞的，如果有一个线程加锁了，那么其他的线程只能阻塞等待</p><p><code>int pthread_mutex_trylock(pthread_mutex_t *mutex);</code></p><p>尝试加锁，如果加锁失败，不会阻塞，会直接返回。</p><p><code>int pthread_mutex_unlock(pthread_mutex_t *mutex);</code></p><p>解锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-comment">// 全局变量，所有的线程都共享这一份资源。</span><br><span class="hljs-type">int</span> tickets = <span class="hljs-number">1000</span>;<br><span class="hljs-comment">// 创建一个互斥量</span><br><span class="hljs-type">pthread_mutex_t</span> mutex;<br><span class="hljs-type">void</span> * <span class="hljs-title function_">sellticket</span><span class="hljs-params">(<span class="hljs-type">void</span> * arg)</span> &#123;<br>    <span class="hljs-comment">// 卖票</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 加锁</span><br>        pthread_mutex_lock(&amp;mutex);<br>        <span class="hljs-keyword">if</span>(tickets &gt; <span class="hljs-number">0</span>) &#123;<br>            usleep(<span class="hljs-number">6000</span>);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%ld 正在卖第 %d 张门票\n&quot;</span>, pthread_self(), tickets);<br>            tickets--;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 解锁</span><br>            pthread_mutex_unlock(&amp;mutex);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">// 解锁</span><br>        pthread_mutex_unlock(&amp;mutex);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 初始化互斥量</span><br>    pthread_mutex_init(&amp;mutex, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-comment">// 创建3个子线程</span><br>    <span class="hljs-type">pthread_t</span> tid1, tid2, tid3;<br>    pthread_create(&amp;tid1, <span class="hljs-literal">NULL</span>, sellticket, <span class="hljs-literal">NULL</span>);<br>    pthread_create(&amp;tid2, <span class="hljs-literal">NULL</span>, sellticket, <span class="hljs-literal">NULL</span>);<br>    pthread_create(&amp;tid3, <span class="hljs-literal">NULL</span>, sellticket, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-comment">// 回收子线程的资源,阻塞</span><br>    pthread_join(tid1, <span class="hljs-literal">NULL</span>);<br>    pthread_join(tid2, <span class="hljs-literal">NULL</span>);<br>    pthread_join(tid3, <span class="hljs-literal">NULL</span>);<br>    pthread_exit(<span class="hljs-literal">NULL</span>); <span class="hljs-comment">// 退出主线程</span><br>    <span class="hljs-comment">// 释放互斥量资源</span><br>    pthread_mutex_destroy(&amp;mutex);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br></code></pre></td></tr></table></figure><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>有的时候，一个线程需要同时访问多个不同的共享资源，而每个资源又由不同的互斥量进行管理。当超过一个线程对这组互斥量进行加锁的时候，就可能出现死锁的现象。</p><p>两个或两个以上的进程在执行过程中，因为抢占资源而造成的一种互相等待的现象，若无外力作用，它们都无法推进下去，此时称系统产生了死锁。</p><p>死锁的几种场景：</p><ol><li>忘记释放锁</li><li>给一个变量多次加锁</li><li>多线程多锁，抢占锁资源</li></ol><h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p>死锁现象一般发生在对数据的写，而不是读。所以就来了读写锁。</p><ol><li>读写锁允许多个线程同时读。</li><li>如果有一个线程在写数据，那么其他线程都不可以读写操作。</li><li>写锁的优先级高于读。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-comment">// 全局变量，所有的线程都共享这一份资源。</span><br><span class="hljs-type">int</span> num = <span class="hljs-number">1</span>;<br><span class="hljs-type">pthread_rwlock_t</span> rwlock;<br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">writeNum</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        pthread_rwlock_wrlock(&amp;rwlock);<br>        num++;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;writeNum tid = %ld, num=%d\n&quot;</span>,pthread_self(), num);<br>        pthread_rwlock_unlock(&amp;rwlock);<br>        usleep(<span class="hljs-number">100</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-type">void</span> *<span class="hljs-title function_">readNum</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        pthread_rwlock_rdlock(&amp;rwlock);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;readNum tid = %ld, num=%d\n&quot;</span>,pthread_self(), num);<br>        pthread_rwlock_unlock(&amp;rwlock);<br>        usleep(<span class="hljs-number">100</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    pthread_rwlock_init(&amp;rwlock, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-type">pthread_t</span> wtid[<span class="hljs-number">3</span>], rtid[<span class="hljs-number">5</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)<br>    &#123;<br>        pthread_create(&amp;wtid[i], <span class="hljs-literal">NULL</span>, writeNum, <span class="hljs-literal">NULL</span>);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>    &#123;<br>        pthread_create(&amp;rtid[i], <span class="hljs-literal">NULL</span>, readNum, <span class="hljs-literal">NULL</span>);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)<br>    &#123;<br>        pthread_detach(wtid[i]);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>    &#123;<br>        pthread_detach(rtid[i]);<br>    &#125;<br>    pthread_exit(<span class="hljs-literal">NULL</span>);<br>    pthread_rwlock_destroy(&amp;rwlock);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h2><ol><li>多个生产者、多个消费者</li><li>线程同步问题</li><li>容器满了或者空了，对消费者生产者的通知和阻塞问题。</li></ol><p>初始版本代码，会出现报错。段错误。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// 生产者消费者模型</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> num;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">next</span>;</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">head</span> =</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br><span class="hljs-type">void</span> *<span class="hljs-title function_">producer</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-comment">// 生产者生产一个产品</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">newNode</span> =</span> (<span class="hljs-keyword">struct</span> Node *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Node));<br>        newNode-&gt;num = rand() % <span class="hljs-number">1000</span> + <span class="hljs-number">1</span>;<br>        newNode-&gt;next = head;<br>        head = newNode;<br>        sum ++;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;++++++ num = %d, tid = %lu, sum = %d\n&quot;</span>, newNode-&gt;num,pthread_self(),sum);<br>        usleep(<span class="hljs-number">100</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-type">void</span> *<span class="hljs-title function_">consumer</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-comment">// 消费者消费一个产品</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">temp</span> =</span> head;<br>        head = head-&gt;next;<br>        sum--;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-------: num = %d, tid = %ld, sum=%d\n&quot;</span>,temp-&gt;num,pthread_self(),sum);<br>        <span class="hljs-built_in">free</span>(temp);<br>        temp = <span class="hljs-literal">NULL</span>;<br>        usleep(<span class="hljs-number">100</span>);<br>    &#125;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 创健5个生产者线程，5个消费者线程</span><br>    <span class="hljs-type">pthread_t</span> ptid[<span class="hljs-number">5</span>], ctid[<span class="hljs-number">5</span>];<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>    &#123;<br>        pthread_create(&amp;ptid[i], <span class="hljs-literal">NULL</span>, producer, <span class="hljs-literal">NULL</span>);<br>        pthread_create(&amp;ctid[i], <span class="hljs-literal">NULL</span>, consumer, <span class="hljs-literal">NULL</span>);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>    &#123;<br>        pthread_detach(ptid[i]);<br>        pthread_detach(ctid[i]);<br>    &#125;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        sleep(<span class="hljs-number">10</span>);<br>    &#125;<br>    pthread_exit(<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><p>条件变量不是锁，是用于阻塞线程的。</p><p>条件变量的类型 <code>pthread_cond_t</code></p><p><code>int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr);</code></p><p>初始化</p><p><code>int pthread_cond_destroy(pthread_cond_t *cond);</code></p><p>销毁</p><p><code>int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex);</code></p><p>等待，调用了该函数，线程会阻塞。但是会对里面的锁先进行解锁，当不阻塞的时候，继续向下执行，会重新加锁</p><p><code>int pthread_cond_timedwait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex, const struct timespec *restrict abstime);</code></p><p>等待多长时间，调用了这个函数，线程会阻塞，直到指定的时间结束。</p><p><code>int pthread_cond_signal(pthread_cond_t *cond);</code></p><p>唤醒一个或者多个等待的线程，通知！</p><p><code>int pthread_cond_broadcast(pthread_cond_t *cond);</code></p><p>唤醒所有的等待的线程</p><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    信号量的类型 sem_t</span><br><span class="hljs-comment">    int sem_init(sem_t *sem, int pshared, unsigned int value);</span><br><span class="hljs-comment">        - 初始化信号量</span><br><span class="hljs-comment">        - 参数：</span><br><span class="hljs-comment">            - sem : 信号量变量的地址</span><br><span class="hljs-comment">            - pshared : 0 用在线程间 ，非0 用在进程间</span><br><span class="hljs-comment">            - value : 信号量中的值</span><br><span class="hljs-comment">    int sem_destroy(sem_t *sem);</span><br><span class="hljs-comment">        - 释放资源</span><br><span class="hljs-comment">    int sem_wait(sem_t *sem);</span><br><span class="hljs-comment">        - 对信号量加锁，调用一次对信号量的值-1，如果值为0，就阻塞</span><br><span class="hljs-comment">    int sem_trywait(sem_t *sem);</span><br><span class="hljs-comment">    int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);</span><br><span class="hljs-comment">    int sem_post(sem_t *sem);</span><br><span class="hljs-comment">        - 对信号量解锁，调用一次对信号量的值+1</span><br><span class="hljs-comment">    int sem_getvalue(sem_t *sem, int *sval);</span><br><span class="hljs-comment">    sem_t psem;</span><br><span class="hljs-comment">    sem_t csem;</span><br><span class="hljs-comment">    init(psem, 0, 8);</span><br><span class="hljs-comment">    init(csem, 0, 0);</span><br><span class="hljs-comment">    producer() &#123;</span><br><span class="hljs-comment">        sem_wait(&amp;psem);</span><br><span class="hljs-comment">        sem_post(&amp;csem)</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    customer() &#123;</span><br><span class="hljs-comment">        sem_wait(&amp;csem);</span><br><span class="hljs-comment">        sem_post(&amp;psem)</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// 生产者消费者模型</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;semaphore.h&gt;</span></span><br><span class="hljs-type">pthread_mutex_t</span> mutex;<br><span class="hljs-type">sem_t</span> csem;<br><span class="hljs-type">sem_t</span> psem;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> num;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">next</span>;</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">head</span> =</span> <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br><span class="hljs-type">void</span> *<span class="hljs-title function_">producer</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-comment">// 生产者生产一个产品</span><br>        sem_wait(&amp;psem);<br>        pthread_mutex_lock(&amp;mutex);<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">newNode</span> =</span> (<span class="hljs-keyword">struct</span> Node *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Node));<br>        newNode-&gt;num = rand() % <span class="hljs-number">1000</span> + <span class="hljs-number">1</span>;<br>        newNode-&gt;next = head;<br>        head = newNode;<br>        sum++;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;++++++ num = %d, tid = %lu, sum = %d\n&quot;</span>, newNode-&gt;num, pthread_self(), sum);<br>        <span class="hljs-comment">// 只要sum&gt;0，就唤醒消费者</span><br>        pthread_mutex_unlock(&amp;mutex);<br>        sem_post(&amp;csem);<br>        usleep(<span class="hljs-number">100</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-type">void</span> *<span class="hljs-title function_">consumer</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-comment">// 消费者消费一个产品</span><br>        sem_wait(&amp;csem);<br>        pthread_mutex_lock(&amp;mutex);<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">temp</span> =</span> head;<br>        head = head-&gt;next;<br>        sum--;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-------: num = %d, tid = %ld, sum=%d\n&quot;</span>, temp-&gt;num, pthread_self(), sum);<br>        <span class="hljs-built_in">free</span>(temp);<br>        temp = <span class="hljs-literal">NULL</span>;<br>        pthread_mutex_unlock(&amp;mutex);<br>        sem_post(&amp;psem);<br>        usleep(<span class="hljs-number">100</span>);<br>    &#125;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 创健5个生产者线程，5个消费者线程</span><br>    <span class="hljs-type">pthread_t</span> ptid[<span class="hljs-number">5</span>], ctid[<span class="hljs-number">5</span>];<br>    sem_init(&amp;psem, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>);<br>    sem_init(&amp;csem, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>    &#123;<br>        pthread_create(&amp;ptid[i], <span class="hljs-literal">NULL</span>, producer, <span class="hljs-literal">NULL</span>);<br>        pthread_create(&amp;ctid[i], <span class="hljs-literal">NULL</span>, consumer, <span class="hljs-literal">NULL</span>);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>    &#123;<br>        pthread_join(ptid[i], <span class="hljs-literal">NULL</span>);<br>        pthread_join(ctid[i], <span class="hljs-literal">NULL</span>);<br>    &#125;<br>    pthread_mutex_destroy(&amp;mutex);<br>    pthread_exit(<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux编程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux多进程</title>
    <link href="/2023/06/03/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
    <url>/2023/06/03/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux多进程"><a href="#Linux多进程" class="headerlink" title="Linux多进程"></a>Linux多进程</h1><h2 id="程序和进程"><a href="#程序和进程" class="headerlink" title="程序和进程"></a>程序和进程</h2><p><strong>程序描述如何在运行时创建一个进程。</strong><img src="截屏2023-03-31 18.12.09-1135960.png" alt="截屏2023-03-31 18.12.09" style="zoom:50%;" /></p><p>![截屏2023-03-31 18.15.17](截屏2023-03-31 18.15.17-1135960.png)</p><h3 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h3><img src="截屏2023-04-01 17.55.50-1135960.png" alt="截屏2023-04-01 17.55.50" style="zoom: 25%;" /><h3 id="进程控制块PCB"><a href="#进程控制块PCB" class="headerlink" title="进程控制块PCB"></a>进程控制块PCB</h3><img src="截屏2023-04-01 17.58.35-1135960.png" alt="截屏2023-04-01 17.58.35" style="zoom: 33%;" /><img src="截屏2023-04-01 18.07.51-1135960.png" alt="截屏2023-04-01 18.07.51" style="zoom: 33%;" /><h2 id="进程的状态转换"><a href="#进程的状态转换" class="headerlink" title="进程的状态转换"></a>进程的状态转换</h2><img src="截屏2023-04-01 18.11.13-1135960.png" alt="截屏2023-04-01 18.11.13" style="zoom:50%;" /><img src="截屏2023-04-01 18.39.52-1135960.png" alt="截屏2023-04-01 18.39.52" style="zoom:50%;" /><h2 id="进程相关的命令"><a href="#进程相关的命令" class="headerlink" title="进程相关的命令"></a>进程相关的命令</h2><h3 id="查看进程的指令-ps"><a href="#查看进程的指令-ps" class="headerlink" title="查看进程的指令 ps"></a>查看进程的指令 ps</h3><p>![截屏2023-04-01 18.42.45](截屏2023-04-01 18.42.45-1135960.png)</p><h4 id="STAT参数（不用记）"><a href="#STAT参数（不用记）" class="headerlink" title="STAT参数（不用记）"></a>STAT参数（不用记）</h4><p>在Linux中，<code>ps</code>命令输出的进程状态中有一个<code>STAT</code>参数，它表示进程的状态。以下是常见的<code>STAT</code>参数及其含义：</p><ul><li><code>R</code>（Running）：进程正在运行或在运行队列中等待。</li><li><code>S</code>（Sleeping）：进程正在睡眠中，即进程正在等待某个事件的发生，如等待IO完成或等待信号。</li><li><code>D</code>（Disk sleep）：进程正在等待磁盘IO完成，即进程处于阻塞状态。</li><li><code>Z</code>（Zombie）：进程已经完成执行，但是其父进程尚未将其状态清除，导致其状态变为僵尸状态。</li><li><code>T</code>（Stopped）：进程已经被暂停，例如收到了SIGSTOP信号。</li><li><code>t</code>（Tracing stop）：进程已经被暂停，以等待跟踪器进程的指示，例如收到了SIGTRAP信号。</li><li><code>W</code>（Paging）：进程正在进行页面交换。</li><li><code>X</code>（Dead）：进程已经退出或被杀死。</li><li><code>&lt;</code>（High-priority）：进程具有高优先级。</li><li><code>N</code>（Low-priority）：进程具有低优先级。</li><li><code>s</code>（Session leader）：进程是一个会话的领导者。</li><li><code>+</code>（Foreground）：进程正在前台运行。</li></ul><p>其中，<code>R</code>、<code>S</code>和<code>D</code>是进程状态的主要状态，表示进程正在运行、睡眠或阻塞状态。<code>Z</code>状态表示僵尸进程，<code>T</code>状态表示停止状态，<code>t</code>状态表示正在跟踪进程，<code>W</code>状态表示页面交换状态，<code>X</code>状态表示进程已经退出或被杀死，<code>&lt;</code>和<code>N</code>状态表示进程的优先级，<code>s</code>状态表示会话的领导者，<code>+</code>状态表示进程正在前台运行。</p><h3 id="top命令"><a href="#top命令" class="headerlink" title="top命令"></a>top命令</h3><p><code>top</code>是一个常用的命令行工具，用于实时显示系统中运行的进程信息。它可以按照CPU使用率、内存使用率等多种指标对进程进行排序，还可以查看系统的负载、内存使用情况等系统性能指标。以下是一些常用的<code>top</code>命令选项：</p><ol><li><code>top</code>：默认情况下，<code>top</code>会显示当前系统中所有进程的信息，按照CPU使用率进行排序。</li><li><code>top -u username</code>：只显示指定用户的进程。</li><li><code>top -p pid</code>：只显示指定进程ID的进程。</li><li><code>top -b</code>：以批处理模式运行，输出结果到文件中。</li><li><code>top -n</code>：指定要显示的次数后退出。</li><li><code>top -d</code>：指定两次更新之间的时间间隔。</li><li><code>top -o</code>：指定排序方式，如<code>top -o %CPU</code>按照CPU使用率进行排序。</li></ol><p>在<code>top</code>的交互界面中，可以使用一些快捷键来进行操作，例如：</p><ol><li><code>k</code>：杀死一个进程。</li><li><code>r</code>：重新调度一个进程。</li><li><code>1</code>：切换到单CPU模式，只显示一个CPU的信息。</li><li><code>f</code>：切换显示不同的进程信息字段。</li><li><code>q</code>：退出<code>top</code>命令。</li></ol><p>通过<code>top</code>命令，我们可以实时了解系统中正在运行的进程的状态和资源占用情况，以及系统的性能指标，有助于及时发现和解决系统性能问题。</p><h3 id="kill命令"><a href="#kill命令" class="headerlink" title="kill命令"></a>kill命令</h3><p><code>kill</code>命令是Linux中一个常用的命令，用于向指定的进程发送信号，以控制进程的行为。通常情况下，<code>kill</code>命令用于停止或终止运行中的进程。以下是一些常用的<code>kill</code>命令选项：</p><ol><li><code>kill PID</code>：向指定PID的进程发送<code>SIGTERM</code>信号，以请求进程终止。</li><li><code>kill -9 PID</code>：向指定PID的进程发送<code>SIGKILL</code>信号，以强制进程立即终止。</li><li><code>killall process_name</code>：向所有同名进程发送<code>SIGTERM</code>信号，以请求进程终止。</li><li><code>killall -9 process_name</code>：向所有同名进程发送<code>SIGKILL</code>信号，以强制进程立即终止。</li></ol><p>除了上述常用的选项之外，<code>kill</code>命令还可以向进程发送其他类型的信号，例如：</p><ol><li><code>SIGINT</code>：向进程发送中断信号，通常由<code>Ctrl+C</code>产生。</li><li><code>SIGHUP</code>：向进程发送终端挂起信号，通常用于重新读取配置文件。</li><li><code>SIGUSR1</code>和<code>SIGUSR2</code>：向进程发送用户定义信号。</li></ol><p>需要注意的是，使用<code>kill</code>命令终止进程可能会导致数据丢失或系统不稳定，因此在终止进程之前最好先尝试通过其他方式结束进程，例如发送<code>SIGTERM</code>信号等待进程自行退出。</p><h2 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h2><img src="截屏2023-04-01 21.37.38-1135960.png" alt="截屏2023-04-01 21.37.38" style="zoom:50%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment">#include &lt;sys/types.h&gt;</span><br><span class="hljs-comment">#include &lt;unistd.h&gt;</span><br><span class="hljs-comment">    pid_t fork(void);</span><br><span class="hljs-comment">        函数的作用：创建一个新的进程，新的进程是原进程的一个副本</span><br><span class="hljs-comment">        返回值：新进程的进程号，一次是在父进程中返回，一次是在子进程中返回</span><br><span class="hljs-comment">        在父进程中返回子进程的进程号，在子进程中返回0</span><br><span class="hljs-comment">        如何判断是父进程还是子进程：通过返回值来判断</span><br><span class="hljs-comment">        在父进程中返回-1，表示创建子进程失败，并且设置errno</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-comment">//创建子进程</span><br>    <span class="hljs-type">pid_t</span> pid = fork();<br>    <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">-1</span>)&#123;<br>        perror(<span class="hljs-string">&quot;fork&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> num = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">//子进程</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child pid = %d,parent pid = %d\n&quot;</span>,getpid(),getppid());<br>        num = <span class="hljs-number">100</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child num = %d\n&quot;</span>,num);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-comment">//父进程</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;parent pid = %d\n&quot;</span>,getpid());<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;parent num = %d\n&quot;</span>,num);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="父子进程"><a href="#父子进程" class="headerlink" title="父子进程"></a>父子进程</h2><h3 id="父子进程虚拟地址空间情况"><a href="#父子进程虚拟地址空间情况" class="headerlink" title="父子进程虚拟地址空间情况"></a>父子进程虚拟地址空间情况</h3><img src="截屏2023-04-01 22.16.23-1135960.png" alt="截屏2023-04-01 22.16.23" style="zoom:50%;" /><p>子进程会把父进程的变量全部拷贝下来，但是会把用户区的pid设置为0。子进程对变量的操作不会影响父进程。</p><h3 id="fork的写时拷贝"><a href="#fork的写时拷贝" class="headerlink" title="fork的写时拷贝"></a>fork的写时拷贝</h3><p>写时拷贝是一种内存管理技术，它通过在创建进程时共享原始进程的内存页来提高性能。当子进程需要修改共享的内存页时，操作系统会在这个内存页被修改前，将其复制到子进程的地址空间中。这样可以避免复制整个进程的地址空间，而只复制必要的部分。</p><p>在<code>fork()</code>中，父进程和子进程最初共享同一份内存。当父进程或子进程尝试修改共享的内存时，操作系统会使用写时拷贝技术来复制这个内存页，并且将这个内存页的副本分配给修改进程。这样，父进程和子进程的内存空间就被分开了，互不干扰，避免了不必要的内存复制。</p><p>使用写时拷贝技术可以减少内存使用，提高系统性能。在多个进程需要共享同一份内存时，这种技术可以避免复制整个内存区域，从而减少了开销。在<code>fork()</code>中，写时拷贝技术也可以避免复制整个进程的地址空间，从而提高了<code>fork()</code>的效率。</p><h3 id="父子进程关系总结"><a href="#父子进程关系总结" class="headerlink" title="父子进程关系总结"></a>父子进程关系总结</h3><h4 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h4><ol><li>fork()返回值不同，父进程为子进程pid，子进程为0</li><li>PCB(进程控制块)，当前进程的id，pid，信号集</li></ol><h4 id="相同："><a href="#相同：" class="headerlink" title="相同："></a>相同：</h4><ol><li>子进程在创建的时候，变量和父进程是一样。用户区数据，文件描述表</li><li>读时共享，写时拷贝</li></ol><h2 id="GDB多进程调试"><a href="#GDB多进程调试" class="headerlink" title="GDB多进程调试"></a>GDB多进程调试</h2><p>![截屏2023-04-01 22.39.24](截屏2023-04-01 22.39.24-1135960.png)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">(gdb) show follow-fork-mode <br>Debugger response to a program call of fork or vfork is &quot;parent&quot;.<br>(gdb) set follow-fork-mode child <br>(gdb) show follow-fork-mode <br>Debugger response to a program call of fork or vfork is &quot;child&quot;.<br></code></pre></td></tr></table></figure><p>奶奶滴，gdb8x的版本多进程调试会出问题。</p><ol><li>先设置调试模式，让子进程挂起。</li><li>使用info inferior，查看现在的调试进程。使用inferior + id ，进行切换</li><li>切换到子进程，摁c让其运行至断点</li></ol><p>使用detach命令可以让选定的进程脱离GDB，自己继续运行。</p><h2 id="exec函数族"><a href="#exec函数族" class="headerlink" title="exec函数族"></a>exec函数族</h2><p>![截屏2023-04-02 15.35.23](截屏2023-04-02 15.35.23-1135960.png)</p><p>![截屏2023-04-02 15.43.08](截屏2023-04-02 15.43.08-1135960.png)</p><h3 id="execl"><a href="#execl" class="headerlink" title="execl"></a>execl</h3><p><code>execl()</code>是UNIX系统中用于在当前进程中执行另一个程序的函数。该函数在当前进程中用新的程序替换当前程序，因此原有的程序代码不再执行。<code>execl()</code>函数使用指定的参数列表调用一个新的程序，并将新程序的控制权传递给新程序。<code>execl()</code>函数是<code>exec()</code>函数族中的一个成员，它在<code>&lt;unistd.h&gt;</code>头文件中声明。</p><p><code>execl()</code>函数的声明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">execl</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *arg, ...)</span>;<br></code></pre></td></tr></table></figure><p>其中，<code>path</code>参数是要执行的程序的路径和名称（推荐使用绝对路径），<code>arg</code>参数指定新程序的命令行参数。<code>arg</code>参数以可变参数列表的形式表示，最后一个参数必须为NULL（哨兵）。</p><p>例如，以下代码片段演示了如何使用<code>execl()</code>函数在UNIX系统中执行<code>/bin/ls</code>命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    execl(<span class="hljs-string">&quot;/bin/ls&quot;</span>, <span class="hljs-string">&quot;ls&quot;</span>, <span class="hljs-string">&quot;-l&quot;</span>, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>execl()</code>函数调用将执行<code>/bin/ls</code>命令，并传递两个参数：<code>ls</code>和<code>-l</code>。由于最后一个参数必须为NULL，因此使用了<code>NULL</code>表示可变参数列表的结尾。</p><p>需要注意的是，<code>execl()</code>函数<strong>只有在调用失败时才会返回</strong>，否则它将在新程序中执行，并将控制权转移给新程序。因此，在调用<code>execl()</code>函数时，应该确保当前程序执行的任何代码都不会继续执行，以免出现未定义的行为。</p><h3 id="execlp"><a href="#execlp" class="headerlink" title="execlp"></a>execlp</h3><p><code>execlp()</code>函数是UNIX系统中用于在当前进程中执行另一个程序的函数之一。与<code>execl()</code>函数和<code>execvp()</code>函数不同，<code>execlp()</code>函数不需要在参数中指定程序的完整路径，而是从系统的环境变量<code>PATH</code>中查找可执行文件。</p><p><code>execlp()</code>函数的声明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">execlp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *file, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *arg, ...)</span>;<br></code></pre></td></tr></table></figure><p>其中，<code>file</code>参数是要执行的程序的名称（不带路径），<code>arg</code>参数是传递给新程序的第一个参数，后跟可变数量的参数。参数列表必须以一个空指针结束。</p><p>以下是使用<code>execlp()</code>函数执行<code>ls</code>命令的示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    execlp(<span class="hljs-string">&quot;ls&quot;</span>, <span class="hljs-string">&quot;ls&quot;</span>, <span class="hljs-string">&quot;-l&quot;</span>, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>execlp()</code>函数将在环境变量<code>PATH</code>指定的目录中搜索<code>ls</code>命令，并传递<code>-l</code>参数给<code>ls</code>。因为<code>execlp()</code>函数不需要指定程序的路径，所以调用非常简单。</p><h3 id="execv"><a href="#execv" class="headerlink" title="execv"></a>execv</h3><p><code>execv()</code>是UNIX系统中用于在当前进程中执行另一个程序的函数。该函数在当前进程中用新的程序替换当前程序，因此原有的程序代码不再执行。<code>execv()</code>函数使用指定的参数数组调用一个新的程序，并将新程序的控制权传递给新程序。<code>execv()</code>函数是<code>exec()</code>函数族中的一个成员，它在<code>&lt;unistd.h&gt;</code>头文件中声明。</p><p><code>execv()</code>函数的声明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">execv</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">char</span> *<span class="hljs-type">const</span> argv[])</span>;<br></code></pre></td></tr></table></figure><p>其中，<code>path</code>参数是要执行的程序的路径和名称，<code>argv</code>参数是指向指针数组的指针，其中每个指针都指向一个新程序的命令行参数。数组的最后一个元素必须为NULL。</p><p>例如，以下代码片段演示了如何使用<code>execv()</code>函数在UNIX系统中执行<code>/bin/ls</code>命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> *<span class="hljs-type">const</span> args[] = &#123;<span class="hljs-string">&quot;ls&quot;</span>, <span class="hljs-string">&quot;-l&quot;</span>, <span class="hljs-literal">NULL</span>&#125;;<br>    execv(<span class="hljs-string">&quot;/bin/ls&quot;</span>, args);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>execv()</code>函数调用将执行<code>/bin/ls</code>命令，并传递两个参数：<code>ls</code>和<code>-l</code>。由于<code>args</code>数组的最后一个元素必须为NULL，因此使用了<code>NULL</code>表示数组的结尾。</p><h3 id="execve"><a href="#execve" class="headerlink" title="execve"></a>execve</h3><p>增加了一个envp数组，这个数组里保存可执行程序搜索的路径，可以有多个，依次搜索。</p><h2 id="exit退出进程"><a href="#exit退出进程" class="headerlink" title="exit退出进程"></a>exit退出进程</h2><img src="截屏2023-04-02 16.40.11-1135960.png" alt="截屏2023-04-02 16.40.11" style="zoom:50%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">exit</span><span class="hljs-params">(<span class="hljs-type">int</span> status)</span>;<br><span class="hljs-comment">// status是进程退出时的状态信息，父进程回收子进程资源的时候可以获取</span><br></code></pre></td></tr></table></figure><h3 id="exit和-exit"><a href="#exit和-exit" class="headerlink" title="exit和_exit"></a>exit和_exit</h3><p>在C语言中，<code>exit()</code>函数是一个库函数，用于终止当前进程的执行，并返回一个退出状态码。同时，它还会自动调用所有已注册的<code>atexit()</code>函数，以确保程序的资源得到正确释放。</p><p>在C语言中，<code>_exit()</code>函数是一个系统调用函数，用于终止当前进程的执行，不返回任何值，也不自动调用<code>atexit()</code>函数。与<code>exit()</code>函数不同，<code>_exit()</code>函数不会将缓冲区中的数据写回到文件中，也不会关闭已打开的文件和流。</p><p>另外，在C语言中，还有一个与<code>_exit()</code>函数类似的函数，名为<code>_Exit()</code>，它也是一个系统调用函数，用于立即终止当前进程的执行，但不会执行清理处理。</p><h2 id="孤儿进程和僵尸进程"><a href="#孤儿进程和僵尸进程" class="headerlink" title="孤儿进程和僵尸进程"></a>孤儿进程和僵尸进程</h2><h3 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h3><p>父进程运行结束，但是子进程还在运行，这样的子进程称为孤儿进程。</p><p>每当孤儿进程出现的时候，内核会把其父进程设置为init，而init会循环的wait它的已退出的子进程。这样当一个孤儿进程死掉的时候，init会出面处理其善后工作。因此孤儿进程不会有危害。</p><h3 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h3><p>在Unix&#x2F;Linux操作系统中，僵尸进程（Zombie Process）是指已经完成执行（即进程已经退出），但其在进程表中仍然保留了一个记录（PCB）的进程。</p><p>产生僵尸进程的原因通常是<strong>父进程没有及时地对其子进程进行处理</strong>，也就是没有使用<code>wait()</code>或<code>waitpid()</code>等函数来等待子进程的结束，从而导致子进程成为僵尸进程。在这种情况下，子进程的进程表记录仍然存在，但是它已经不再占用系统资源，也无法进行任何操作。</p><p><strong>僵尸进程不会占用系统资源，但是如果僵尸进程太多，可能会占用大量的进程表项，导致进程表溢出。</strong>因此，应该尽量避免出现僵尸进程，方法是在父进程中及时调用<code>wait()</code>或<code>waitpid()</code>等函数，处理已经完成执行的子进程，释放相关的系统资源，从而避免僵尸进程的产生。</p><p><strong>另外，如果父进程不处理子进程的结束，而子进程的父进程又已经退出，那么子进程就会变成孤儿进程，</strong>这种情况下，操作系统会把子进程的父进程设置为进程1（init进程），从而避免出现僵尸进程。</p><h2 id="wait和waitpid进程回收"><a href="#wait和waitpid进程回收" class="headerlink" title="wait和waitpid进程回收"></a>wait和waitpid进程回收</h2><h3 id="wait函数"><a href="#wait函数" class="headerlink" title="wait函数"></a>wait函数</h3><p>![截屏2023-04-02 17.08.26](截屏2023-04-02 17.08.26-1135960.png)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    #include &lt;sys/types.h&gt;</span><br><span class="hljs-comment">    #include &lt;sys/wait.h&gt;</span><br><span class="hljs-comment">    pid_t wait(int *wstatus);</span><br><span class="hljs-comment">        功能：等待任意一个子进程结束，如果任意一个子进程结束了，次函数会回收子进程的资源。</span><br><span class="hljs-comment">        参数：int *wstatus</span><br><span class="hljs-comment">            进程退出时的状态信息，传入的是一个int类型的地址，传出参数。</span><br><span class="hljs-comment">        返回值：</span><br><span class="hljs-comment">            - 成功：返回被回收的子进程的id</span><br><span class="hljs-comment">            - 失败：-1 (所有的子进程都结束，调用函数失败)</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    调用wait函数的进程会被挂起（阻塞），直到它的一个子进程退出或者收到一个不能被忽略的信号时才被唤醒（相当于继续往下执行）</span><br><span class="hljs-comment">    如果没有子进程了，函数立刻返回，返回-1；如果子进程都已经结束了，也会立即返回，返回-1.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 父进程创建5个子进程</span><br>    <span class="hljs-type">pid_t</span> pid;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++)<br>    &#123;<br>        pid = fork();<br>        <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (pid &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> st = <span class="hljs-number">0</span>;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am parent, pid = %d\n&quot;</span>, getpid());<br>            <span class="hljs-comment">// int ret = wait(NULL);</span><br>            <span class="hljs-type">int</span> ret = wait(&amp;st);<br>            <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>)<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-comment">// 是不是正常退出</span><br>            <span class="hljs-keyword">if</span> (WIFEXITED(st))<br>                <span class="hljs-comment">// 获取退出码</span><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child exit = %d\n&quot;</span>, WEXITSTATUS(st));<br>            <span class="hljs-comment">// 是不是异常退出</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (WIFSIGNALED(st))<br>                <span class="hljs-comment">// 获取信号值</span><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child signal = %d\n&quot;</span>, WTERMSIG(st));<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child die = %d\n&quot;</span>, ret);<br>            sleep(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">// while (1)</span><br>        <span class="hljs-comment">// &#123;</span><br>        <span class="hljs-comment">//     printf(&quot;I am child, pid = %d\n&quot;, getpid());</span><br>        <span class="hljs-comment">//     sleep(1);</span><br>        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am child, pid = %d\n&quot;</span>, getpid());<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p> ![截屏2023-04-02 17.33.32](截屏2023-04-02 17.33.32-1135960.png)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">root@iZ2zec9iqw5wve79bry35gZ:/home/clion/webserver/part_2# ./wait <br>I am parent, pid = 10117<br>I am child, pid = 10118<br>I am child, pid = 10119<br>child exit = 0<br>child die = 10118<br>I am parent, pid = 10117<br>child exit = 0<br>child die = 10119<br>I am parent, pid = 10117<br></code></pre></td></tr></table></figure><h3 id="waitpid函数"><a href="#waitpid函数" class="headerlink" title="waitpid函数"></a>waitpid函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-type">pid_t</span> <span class="hljs-title function_">waitpid</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid, <span class="hljs-type">int</span> *wstatus, <span class="hljs-type">int</span> options)</span>;<br></code></pre></td></tr></table></figure><p>回收指定进程号的子进程，可以设置为是否阻塞。</p><p>参数：</p><ul><li>pid：<ul><li>pid&gt;0，某个子进程；</li><li>&#x3D;0，回收当前进程组的所有子进程：由同一个父进程创建的（也会用到）</li><li>pid&#x3D;-1, 回收所有的子进程，和wait一样（最常用）</li><li>pid&lt;-1，某个子进程组的组id的绝对值，回收指定进程组的子进程</li></ul></li><li>options：设置阻塞或者非阻塞<ul><li>0：阻塞</li><li>WNOHANG：非阻塞</li></ul></li><li>返回值：<ul><li>大于0，返回子进程ID</li><li>等于0，options&#x3D;WNOHANG，表示还有子进程</li><li>等于-1，错误或者没有子进程了</li></ul></li></ul><h2 id="进程间通信（PPT-2-10）"><a href="#进程间通信（PPT-2-10）" class="headerlink" title="进程间通信（PPT-2.10）"></a>进程间通信（PPT-2.10）</h2><p>异步访问数据的时候容易产生数据安全的问题。</p><h3 id="匿名管道的使用"><a href="#匿名管道的使用" class="headerlink" title="匿名管道的使用"></a>匿名管道的使用</h3><h4 id="pipe-创建匿名管道"><a href="#pipe-创建匿名管道" class="headerlink" title="pipe()创建匿名管道"></a>pipe()创建匿名管道</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    #include &lt;unistd.h&gt;</span><br><span class="hljs-comment">    int pipe(int pipefd[2]);</span><br><span class="hljs-comment">        功能：创建一个匿名管道，用来进程间通信。</span><br><span class="hljs-comment">        参数：int pipefd[2] 这个数组是一个传出参数。</span><br><span class="hljs-comment">            pipefd[0] 对应的是管道的读端</span><br><span class="hljs-comment">            pipefd[1] 对应的是管道的写端</span><br><span class="hljs-comment">        返回值：</span><br><span class="hljs-comment">            成功 0</span><br><span class="hljs-comment">            失败 -1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    管道默认是阻塞的：如果管道中没有数据，read阻塞，如果管道满了，write阻塞</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    注意：匿名管道只能用于具有关系的进程之间的通信（父子进程，兄弟进程）</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 子进程发送数据给父进程，父进程读取到数据输出</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 在fork之前创建管道</span><br>    <span class="hljs-type">int</span> pipefd[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">int</span> ret = pipe(pipefd);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;pipe&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-comment">// 创建子进程</span><br>    <span class="hljs-type">pid_t</span> pid = fork();<br>    <span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 父进程</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i am parent process, pid : %d\n&quot;</span>, getpid());<br>        <span class="hljs-comment">// 关闭写端</span><br>        close(pipefd[<span class="hljs-number">1</span>]);<br>        <span class="hljs-comment">// 从管道的读取端读取数据</span><br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-type">int</span> len = read(pipefd[<span class="hljs-number">0</span>], buf, <span class="hljs-keyword">sizeof</span>(buf));<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;parent recv : %s, pid : %d\n&quot;</span>, buf, getpid());<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">// 子进程</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;i am child process, pid : %d\n&quot;</span>, getpid());<br>        <span class="hljs-comment">// 关闭读端</span><br>        close(pipefd[<span class="hljs-number">0</span>]);<br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">// 向管道中写入数据</span><br>            <span class="hljs-type">char</span> * str = <span class="hljs-string">&quot;hello,i am child&quot;</span>;<br>            write(pipefd[<span class="hljs-number">1</span>], str, <span class="hljs-built_in">strlen</span>(str));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果不加sleep()人为控制读写，则会出现子进程写数据后紧接着读数据，结果读到了自己发送的数据。</p><p>这是因为管道是一个文件，相当于在一个文件上又读又写。</p><p><img src="/2023/06/03/Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/pipe-1135960.jpg" alt="pipe"></p><p><strong>所以在正常开发的情况下，管道的数据流向只有一个，不会又读又写！！</strong></p><p>所以在上面的代码中，会主动关闭不用的那一端！</p><hr><h4 id="fpathconf-获取管道大小"><a href="#fpathconf-获取管道大小" class="headerlink" title="fpathconf()获取管道大小"></a>fpathconf()获取管道大小</h4><p><code>ulimit -a</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> pipefd[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">int</span> ret = pipe(pipefd);<br>    <span class="hljs-comment">// 获取管道的大小</span><br>    <span class="hljs-type">long</span> size = fpathconf(pipefd[<span class="hljs-number">0</span>], _PC_PIPE_BUF);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pipe size : %ld\n&quot;</span>, size);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="匿名管道使用案例"><a href="#匿名管道使用案例" class="headerlink" title="匿名管道使用案例"></a>匿名管道使用案例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    实现 ps aux | grep xxx 父子进程间通信</span><br><span class="hljs-comment">    子进程： ps aux, 子进程结束后，将数据发送给父进程</span><br><span class="hljs-comment">    父进程：获取到数据，过滤</span><br><span class="hljs-comment">    pipe()</span><br><span class="hljs-comment">    execlp()</span><br><span class="hljs-comment">    子进程将标准输出 stdout_fileno 重定向到管道的写端。  dup2</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;wait.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 创建一个管道</span><br>    <span class="hljs-type">int</span> fd[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">int</span> ret = pipe(fd);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;pipe&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-comment">// 创建子进程</span><br>    <span class="hljs-type">pid_t</span> pid = fork();<br>    <span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 父进程</span><br>        <span class="hljs-comment">// 关闭写端</span><br>        close(fd[<span class="hljs-number">1</span>]);<br>        <span class="hljs-comment">// 从管道中读取</span><br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-type">int</span> len = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>((len = read(fd[<span class="hljs-number">0</span>], buf, <span class="hljs-keyword">sizeof</span>(buf) - <span class="hljs-number">1</span>)) &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 过滤数据输出</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, buf);<br>            <span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, <span class="hljs-number">1024</span>);<br>        &#125;<br>        wait(<span class="hljs-literal">NULL</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 子进程</span><br>        <span class="hljs-comment">// 关闭读端</span><br>        close(fd[<span class="hljs-number">0</span>]);<br>        <span class="hljs-comment">// 文件描述符的重定向 stdout_fileno -&gt; fd[1]</span><br>        dup2(fd[<span class="hljs-number">1</span>], STDOUT_FILENO);<br>        <span class="hljs-comment">// 执行 ps aux</span><br>        execlp(<span class="hljs-string">&quot;ps&quot;</span>, <span class="hljs-string">&quot;ps&quot;</span>, <span class="hljs-string">&quot;aux&quot;</span>, <span class="hljs-literal">NULL</span>);<br>        perror(<span class="hljs-string">&quot;execlp&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        perror(<span class="hljs-string">&quot;fork&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="匿名管道的读写特点："><a href="#匿名管道的读写特点：" class="headerlink" title="匿名管道的读写特点："></a>匿名管道的读写特点：</h3><p>使用管道时，需要注意以下几种特殊的情况（假设都是阻塞I&#x2F;O操作）<br>1.所有的指向管道写端的文件描述符都关闭了（管道写端引用计数为0），有进程从管道的读端<br>读数据，那么管道中剩余的数据被读取以后，再次read会返回0，就像读到文件末尾一样。</p><p>2.如果有指向管道写端的文件描述符没有关闭（管道的写端引用计数大于0），而持有管道写端的进程<br>也没有往管道中写数据，这个时候有进程从管道中读取数据，那么管道中剩余的数据被读取后，<br>再次read会阻塞，直到管道中有数据可以读了才读取数据并返回。</p><p>3.如果所有指向管道读端的文件描述符都关闭了（管道的读端引用计数为0），这个时候有进程<br>向管道中写数据，那么该进程会收到一个信号SIGPIPE, 通常会导致进程异常终止。</p><p>4.如果有指向管道读端的文件描述符没有关闭（管道的读端引用计数大于0），而持有管道读端的进程<br>也没有从管道中读数据，这时有进程向管道中写数据，那么在管道被写满的时候再次write会阻塞，<br>直到管道中有空位置才能再次写入数据并返回。</p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>​    读管道：<br>​        管道中有数据，read返回实际读到的字节数。<br>​        管道中无数据：<br>​            写端被全部关闭，read返回0（相当于读到文件的末尾）<br>​            写端没有完全关闭，read阻塞等待</p><p>​写管道：<br>​管道读端全部被关闭，进程异常终止（进程收到SIGPIPE信号）<br>​管道读端没有全部关闭：<br>​    管道已满，write阻塞<br>​    管道没有满，write将数据写入，并返回实际写入的字节数</p><h3 id="有名管道（FIFO）"><a href="#有名管道（FIFO）" class="headerlink" title="有名管道（FIFO）"></a>有名管道（FIFO）</h3><h4 id="创建FIFO—-mkfifo"><a href="#创建FIFO—-mkfifo" class="headerlink" title="创建FIFO—-mkfifo();"></a>创建FIFO—-mkfifo();</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    创建fifo文件</span><br><span class="hljs-comment">    1.通过命令： mkfifo 名字</span><br><span class="hljs-comment">    2.通过函数：int mkfifo(const char *pathname, mode_t mode);</span><br><span class="hljs-comment">    #include &lt;sys/types.h&gt;</span><br><span class="hljs-comment">    #include &lt;sys/stat.h&gt;</span><br><span class="hljs-comment">    int mkfifo(const char *pathname, mode_t mode);</span><br><span class="hljs-comment">        参数：</span><br><span class="hljs-comment">            - pathname: 管道名称的路径</span><br><span class="hljs-comment">            - mode: 文件的权限 和 open 的 mode 是一样的</span><br><span class="hljs-comment">                    是一个八进制的数</span><br><span class="hljs-comment">        返回值：成功返回0，失败返回-1，并设置错误号</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 判断文件是否存在</span><br>    <span class="hljs-type">int</span> ret = access(<span class="hljs-string">&quot;fifo1&quot;</span>, F_OK);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;管道不存在，创建管道\n&quot;</span>); <br>        ret = mkfifo(<span class="hljs-string">&quot;fifo1&quot;</span>, <span class="hljs-number">0664</span>);<br>        <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) &#123;<br>            perror(<span class="hljs-string">&quot;mkfifo&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        &#125;       <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="read"><a href="#read" class="headerlink" title="read()"></a>read()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-comment">// 从管道中读取数据</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 1.打开管道文件</span><br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;test&quot;</span>, O_RDONLY);<br>    <span class="hljs-keyword">if</span>(fd == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;open&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-comment">// 读数据</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-type">int</span> len = read(fd, buf, <span class="hljs-keyword">sizeof</span>(buf));<br>        <span class="hljs-keyword">if</span>(len == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;写端断开连接了...\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;recv buf : %s\n&quot;</span>, buf);<br>    &#125;<br>    close(fd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="write"><a href="#write" class="headerlink" title="write()"></a>write()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-comment">// 向管道中写数据</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    有名管道的注意事项：</span><br><span class="hljs-comment">        1.一个为只读而打开一个管道的进程会阻塞，直到另外一个进程为只写打开管道</span><br><span class="hljs-comment">        2.一个为只写而打开一个管道的进程会阻塞，直到另外一个进程为只读打开管道</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    读管道：</span><br><span class="hljs-comment">        管道中有数据，read返回实际读到的字节数</span><br><span class="hljs-comment">        管道中无数据：</span><br><span class="hljs-comment">            管道写端被全部关闭，read返回0，（相当于读到文件末尾）</span><br><span class="hljs-comment">            写端没有全部被关闭，read阻塞等待</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    写管道：</span><br><span class="hljs-comment">        管道读端被全部关闭，进行异常终止（收到一个SIGPIPE信号）</span><br><span class="hljs-comment">        管道读端没有全部关闭：</span><br><span class="hljs-comment">            管道已经满了，write会阻塞</span><br><span class="hljs-comment">            管道没有满，write将数据写入，并返回实际写入的字节数。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 1.判断文件是否存在</span><br>    <span class="hljs-type">int</span> ret = access(<span class="hljs-string">&quot;test&quot;</span>, F_OK);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;管道不存在，创建管道\n&quot;</span>);<br>        <br>        <span class="hljs-comment">// 2.创建管道文件</span><br>        ret = mkfifo(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-number">0664</span>);<br><br>        <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) &#123;<br>            perror(<span class="hljs-string">&quot;mkfifo&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        &#125;       <br>    &#125;<br>    <span class="hljs-comment">// 3.以只写的方式打开管道</span><br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;test&quot;</span>, O_WRONLY);<br>    <span class="hljs-keyword">if</span>(fd == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;open&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-comment">// 写数据</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>];<br>        <span class="hljs-built_in">sprintf</span>(buf, <span class="hljs-string">&quot;hello, %d\n&quot;</span>, i);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;write data : %s\n&quot;</span>, buf);<br>        write(fd, buf, <span class="hljs-built_in">strlen</span>(buf));<br>        sleep(<span class="hljs-number">1</span>);<br>    &#125;<br>    close(fd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="FIFO实现聊天"><a href="#FIFO实现聊天" class="headerlink" title="FIFO实现聊天"></a>FIFO实现聊天</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 判断写是否存在</span><br>    <span class="hljs-type">int</span> ret_A = access(<span class="hljs-string">&quot;fifoA&quot;</span>, F_OK);<br>    <span class="hljs-keyword">if</span> (ret_A == <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;文件不存在，创建文件\n&quot;</span>);<br>        ret_A = mkfifo(<span class="hljs-string">&quot;fifoA&quot;</span>, <span class="hljs-number">0664</span>);<br>        <span class="hljs-keyword">if</span> (ret_A == <span class="hljs-number">-1</span>)<br>        &#123;<br>            perror(<span class="hljs-string">&quot;mkfifo&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> fd_A = open(<span class="hljs-string">&quot;fifoA&quot;</span>, O_WRONLY);<br>    <span class="hljs-keyword">if</span> (fd_A == <span class="hljs-number">-1</span>)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;open&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-type">int</span> ret_B = access(<span class="hljs-string">&quot;fifoB&quot;</span>, F_OK);<br>    <span class="hljs-keyword">if</span> (ret_B == <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;文件不存在，创建文件\n&quot;</span>);<br>        ret_B = mkfifo(<span class="hljs-string">&quot;fifoB&quot;</span>, <span class="hljs-number">0664</span>);<br>        <span class="hljs-keyword">if</span> (ret_B == <span class="hljs-number">-1</span>)<br>        &#123;<br>            perror(<span class="hljs-string">&quot;mkfifo&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> fd_B = open(<span class="hljs-string">&quot;fifoB&quot;</span>, O_RDONLY);<br>    <span class="hljs-keyword">if</span> (fd_B == <span class="hljs-number">-1</span>)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;open&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">128</span>];<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, <span class="hljs-number">128</span>);<br>        fgets(buf, <span class="hljs-number">128</span>, <span class="hljs-built_in">stdin</span>);<br>        ret_A = write(fd_A, buf, <span class="hljs-built_in">strlen</span>(buf));<br>        <span class="hljs-keyword">if</span> (ret_A == <span class="hljs-number">-1</span>)<br>        &#123;<br>            perror(<span class="hljs-string">&quot;write&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, <span class="hljs-number">128</span>);<br>        ret_B = read(fd_B, buf, <span class="hljs-number">128</span>);<br>        <span class="hljs-keyword">if</span>(ret_B&lt;=<span class="hljs-number">0</span>)&#123;<br>            perror(<span class="hljs-string">&quot;read&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;A recv : %s\n&quot;</span>,buf);<br>    &#125;<br>    close(fd_A);<br>    close(fd_B);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    #include &lt;sys/mman.h&gt;</span><br><span class="hljs-comment">    void *mmap(void *addr, size_t length, int prot, int flags,int fd, off_t offset);</span><br><span class="hljs-comment">        - 功能：将一个文件或者设备的数据映射到内存中</span><br><span class="hljs-comment">        - 参数：</span><br><span class="hljs-comment">            - void *addr: NULL, 由内核指定</span><br><span class="hljs-comment">            - length : 要映射的数据的长度，这个值不能为0。建议使用文件的长度。</span><br><span class="hljs-comment">                    获取文件的长度：stat lseek</span><br><span class="hljs-comment">            - prot : 对申请的内存映射区的操作权限</span><br><span class="hljs-comment">                -PROT_EXEC ：可执行的权限</span><br><span class="hljs-comment">                -PROT_READ ：读权限</span><br><span class="hljs-comment">                -PROT_WRITE ：写权限</span><br><span class="hljs-comment">                -PROT_NONE ：没有权限</span><br><span class="hljs-comment">                要操作映射内存，必须要有读的权限。</span><br><span class="hljs-comment">                PROT_READ、PROT_READ|PROT_WRITE</span><br><span class="hljs-comment">            - flags :</span><br><span class="hljs-comment">                - MAP_SHARED : 映射区的数据会自动和磁盘文件进行同步，进程间通信，必须要设置这个选项</span><br><span class="hljs-comment">                - MAP_PRIVATE ：不同步，内存映射区的数据改变了，对原来的文件不会修改，会重新创建一个新的文件。（copy on write）</span><br><span class="hljs-comment">            - fd: 需要映射的那个文件的文件描述符</span><br><span class="hljs-comment">                - 通过open得到，open的是一个磁盘文件</span><br><span class="hljs-comment">                - 注意：文件的大小不能为0，open指定的权限不能和prot参数有冲突。</span><br><span class="hljs-comment">                    prot: PROT_READ                open:只读/读写 </span><br><span class="hljs-comment">                    prot: PROT_READ | PROT_WRITE   open:读写</span><br><span class="hljs-comment">            - offset：偏移量，一般不用。必须指定的是4k的整数倍，0表示不偏移。</span><br><span class="hljs-comment">        - 返回值：返回创建的内存的首地址</span><br><span class="hljs-comment">            失败返回MAP_FAILED，(void *) -1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    int munmap(void *addr, size_t length);</span><br><span class="hljs-comment">        - 功能：释放内存映射</span><br><span class="hljs-comment">        - 参数：</span><br><span class="hljs-comment">            - addr : 要释放的内存的首地址</span><br><span class="hljs-comment">            - length : 要释放的内存的大小，要和mmap函数中的length参数的值一样。</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    使用内存映射实现进程间通信：</span><br><span class="hljs-comment">    1.有关系的进程（父子进程）</span><br><span class="hljs-comment">        - 还没有子进程的时候</span><br><span class="hljs-comment">            - 通过唯一的父进程，先创建内存映射区</span><br><span class="hljs-comment">        - 有了内存映射区以后，创建子进程</span><br><span class="hljs-comment">        - 父子进程共享创建的内存映射区</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    2.没有关系的进程间通信</span><br><span class="hljs-comment">        - 准备一个大小不是0的磁盘文件</span><br><span class="hljs-comment">        - 进程1 通过磁盘文件创建内存映射区</span><br><span class="hljs-comment">            - 得到一个操作这块内存的指针</span><br><span class="hljs-comment">        - 进程2 通过磁盘文件创建内存映射区</span><br><span class="hljs-comment">            - 得到一个操作这块内存的指针</span><br><span class="hljs-comment">        - 使用内存映射区通信</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    注意：内存映射区通信，是非阻塞。</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;wait.h&gt;</span></span><br><br><span class="hljs-comment">// 作业:使用内存映射实现没有关系的进程间的通信。</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-comment">// 1.打开一个文件</span><br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;test.txt&quot;</span>, O_RDWR);<br>    <span class="hljs-type">int</span> size = lseek(fd, <span class="hljs-number">0</span>, SEEK_END);  <span class="hljs-comment">// 获取文件的大小</span><br><br>    <span class="hljs-comment">// 2.创建内存映射区</span><br>    <span class="hljs-type">void</span> *ptr = mmap(<span class="hljs-literal">NULL</span>, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span>(ptr == MAP_FAILED) &#123;<br>        perror(<span class="hljs-string">&quot;mmap&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 3.创建子进程</span><br>    <span class="hljs-type">pid_t</span> pid = fork();<br>    <span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>) &#123;<br>        wait(<span class="hljs-literal">NULL</span>);<br>        <span class="hljs-comment">// 父进程</span><br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">64</span>];<br>        <span class="hljs-built_in">strcpy</span>(buf, (<span class="hljs-type">char</span> *)ptr);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;read data : %s\n&quot;</span>, buf);<br>       <br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">// 子进程</span><br>        <span class="hljs-built_in">strcpy</span>((<span class="hljs-type">char</span> *)ptr, <span class="hljs-string">&quot;nihao a, son!!!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 关闭内存映射区</span><br>    munmap(ptr, size);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="内存映射注意事项"><a href="#内存映射注意事项" class="headerlink" title="内存映射注意事项"></a>内存映射注意事项</h4><ul><li>如果对mmap的返回值(ptr)做++操作(ptr++), munmap是否能够成功?</li></ul><p>void * ptr &#x3D; mmap(…);<br>ptr++;  可以对其进行++操作<br>munmap(ptr, len);   &#x2F;&#x2F; 错误,要保存地址</p><ul><li>如果open时O_RDONLY, mmap时prot参数指定PROT_READ | PROT_WRITE会怎样?</li></ul><p>错误，返回MAP_FAILED<br>open()函数中的权限建议和prot参数的权限保持一致。</p><p>3.如果文件偏移量为1000会怎样?</p><p>偏移量必须是4K的整数倍，返回MAP_FAILED</p><p>4.mmap什么情况下会调用失败?<br>    - 第二个参数：length &#x3D; 0<br>    - 第三个参数：prot<br>        - 只指定了写权限<br>        - prot PROT_READ | PROT_WRITE<br>          第5个参数fd 通过open函数时指定的 O_RDONLY &#x2F; O_WRONLY</p><p>5.可以open的时候O_CREAT一个新文件来创建映射区吗?<br>    - 可以的，但是创建的文件的大小如果为0的话，肯定不行<br>        - 可以对新的文件进行扩展<br>        - lseek()<br>        - truncate()</p><p>6.mmap后关闭文件描述符，对mmap映射有没有影响？<br>    int fd &#x3D; open(“XXX”);<br>    mmap(,,,,fd,0);<br>    close(fd);<br>    映射区还存在，创建映射区的fd被关闭，没有任何影响。</p><p>7.对ptr越界操作会怎样？<br>void * ptr &#x3D; mmap(NULL, 100,,,,,);<br>4K<br>越界操作操作的是非法的内存 -&gt; 段错误</p><h4 id="使用内存映射实现文件复制功能"><a href="#使用内存映射实现文件复制功能" class="headerlink" title="使用内存映射实现文件复制功能"></a>使用内存映射实现文件复制功能</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// 使用内存映射完成文件拷贝</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    1.对原始文件进行内存映射</span><br><span class="hljs-comment">    2.创建新文件，并将其扩展到原始文件的大小</span><br><span class="hljs-comment">    3.将新文件映射到内存中</span><br><span class="hljs-comment">    4.将原始文件的内容拷贝到新文件中</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">// 对原始文件进行映射,出现create mmap error: Permission denied的原因是大部分的硬件设计都不支持在没有读取权限的情况下执行写操作。(或者你可以理解为mmap把文件的内容读到内存时隐含了一次读取操作)</span><br>    <span class="hljs-comment">// s所以在open中应该使用O_RDWR代替</span><br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;english.txt&quot;</span>, O_RDWR);<br>    <span class="hljs-keyword">if</span> (fd == <span class="hljs-number">-1</span>)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;open&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-type">int</span> new_fd = open(<span class="hljs-string">&quot;cpy.txt&quot;</span>, O_RDWR | O_CREAT, <span class="hljs-number">0664</span>);<br>    <span class="hljs-keyword">if</span> (new_fd == <span class="hljs-number">-1</span>)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;open&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-comment">// 对新文件进行扩</span><br>    <span class="hljs-type">size_t</span> size = lseek(fd, <span class="hljs-number">0</span>, SEEK_END);<br>    truncate(<span class="hljs-string">&quot;cpy.txt&quot;</span>, size);<br>    write(new_fd, <span class="hljs-string">&quot; &quot;</span>, <span class="hljs-number">1</span>);<br>    <span class="hljs-type">void</span> *ptr = mmap(<span class="hljs-literal">NULL</span>, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="hljs-number">0</span>);<br>    <span class="hljs-type">void</span> *ptr1 = mmap(<span class="hljs-literal">NULL</span>, size, PROT_READ | PROT_WRITE, MAP_SHARED, new_fd, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (ptr == MAP_FAILED)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;mmap&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (ptr1 == MAP_FAILED)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;mapp&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-built_in">memcpy</span>(ptr1, ptr, size);<br>    munmap(ptr1, size);<br>    munmap(ptr, size);<br>    close(fd);<br>    close(new_fd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><h4 id="kill"><a href="#kill" class="headerlink" title="kill()"></a>kill()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*  </span><br><span class="hljs-comment">    #include &lt;sys/types.h&gt;</span><br><span class="hljs-comment">    #include &lt;signal.h&gt;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    int kill(pid_t pid, int sig);</span><br><span class="hljs-comment">        - 功能：给任何的进程或者进程组pid, 发送任何的信号 sig</span><br><span class="hljs-comment">        - 参数：</span><br><span class="hljs-comment">            - pid ：</span><br><span class="hljs-comment">                &gt; 0 : 将信号发送给指定的进程</span><br><span class="hljs-comment">                = 0 : 将信号发送给当前的进程组</span><br><span class="hljs-comment">                = -1 : 将信号发送给每一个有权限接收这个信号的进程</span><br><span class="hljs-comment">                &lt; -1 : 这个pid=某个进程组的ID取反 （-12345）</span><br><span class="hljs-comment">            - sig : 需要发送的信号的编号或者是宏值，0表示不发送任何信号</span><br><span class="hljs-comment">        kill(getppid(), 9);</span><br><span class="hljs-comment">        kill(getpid(), 9);</span><br><span class="hljs-comment">        </span><br><span class="hljs-comment">    int raise(int sig);</span><br><span class="hljs-comment">        - 功能：给当前进程发送信号</span><br><span class="hljs-comment">        - 参数：</span><br><span class="hljs-comment">            - sig : 要发送的信号</span><br><span class="hljs-comment">        - 返回值：</span><br><span class="hljs-comment">            - 成功 0</span><br><span class="hljs-comment">            - 失败 非0</span><br><span class="hljs-comment">        kill(getpid(), sig);   </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    void abort(void);</span><br><span class="hljs-comment">        - 功能： 发送SIGABRT信号给当前的进程，杀死当前进程</span><br><span class="hljs-comment">        kill(getpid(), SIGABRT);</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-type">pid_t</span> pid = fork();<br><br>    <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 子进程</span><br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child process\n&quot;</span>);<br>            sleep(<span class="hljs-number">1</span>);<br>        &#125;<br><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 父进程</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;parent process\n&quot;</span>);<br>        sleep(<span class="hljs-number">2</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;kill child process now\n&quot;</span>);<br>        kill(pid, SIGINT);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="要操作core文件"><a href="#要操作core文件" class="headerlink" title="要操作core文件"></a>要操作core文件</h4><p>需要使用ulimit 给它分配大小，同时在编译程序的时候➕上-g ，调试命令</p><h4 id="alarm-函数"><a href="#alarm-函数" class="headerlink" title="alarm()函数"></a>alarm()函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    #include &lt;unistd.h&gt;</span><br><span class="hljs-comment">    unsigned int alarm(unsigned int seconds);</span><br><span class="hljs-comment">        - 功能：设置定时器（闹钟）。函数调用，开始倒计时，当倒计时为0的时候，</span><br><span class="hljs-comment">                函数会给当前的进程发送一个信号：SIGALARM</span><br><span class="hljs-comment">        - 参数：</span><br><span class="hljs-comment">            seconds: 倒计时的时长，单位：秒。如果参数为0，定时器无效（不进行倒计时，不发信号）。</span><br><span class="hljs-comment">                    取消一个定时器，通过alarm(0)。</span><br><span class="hljs-comment">        - 返回值：</span><br><span class="hljs-comment">            - 之前没有定时器，返回0</span><br><span class="hljs-comment">            - 之前有定时器，返回之前的定时器剩余的时间</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    - SIGALARM ：默认终止当前的进程，每一个进程都有且只有唯一的一个定时器。</span><br><span class="hljs-comment">        alarm(10);  -&gt; 返回0</span><br><span class="hljs-comment">        过了1秒</span><br><span class="hljs-comment">        alarm(5);   -&gt; 返回9</span><br><span class="hljs-comment">  alarm(100) -&gt; 该函数是不阻塞的</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> seconds = alarm(<span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;seconds = %d\n&quot;</span>, seconds);  <span class="hljs-comment">// 0</span><br>    sleep(<span class="hljs-number">2</span>);<br>    seconds = alarm(<span class="hljs-number">2</span>);    <span class="hljs-comment">// 不阻塞</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;seconds = %d\n&quot;</span>, seconds);  <span class="hljs-comment">// 3</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际的时间 &#x3D; 内核时间 + 用户时间 + 消耗的时间<br>进行文件IO操作的时候比较浪费时间</p><p>定时器，与进程的状态无关（自然定时法）。无论进程处于什么状态，alarm都会计时。</p><h4 id="setitimer"><a href="#setitimer" class="headerlink" title="setitimer()"></a>setitimer()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    #include &lt;sys/time.h&gt;</span><br><span class="hljs-comment">    int setitimer(int which, const struct itimerval *new_value,</span><br><span class="hljs-comment">                        struct itimerval *old_value);</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">        - 功能：设置定时器（闹钟）。可以替代alarm函数。精度微妙us，可以实现周期性定时</span><br><span class="hljs-comment">        - 参数：</span><br><span class="hljs-comment">            - which : 定时器以什么时间计时</span><br><span class="hljs-comment">              ITIMER_REAL: 真实时间，时间到达，发送 SIGALRM   常用</span><br><span class="hljs-comment">              ITIMER_VIRTUAL: 用户时间，时间到达，发送 SIGVTALRM</span><br><span class="hljs-comment">              ITIMER_PROF: 以该进程在用户态和内核态下所消耗的时间来计算，时间到达，发送 SIGPROF</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">            - new_value: 设置定时器的属性</span><br><span class="hljs-comment">            </span><br><span class="hljs-comment">                struct itimerval &#123;      // 定时器的结构体</span><br><span class="hljs-comment">                struct timeval it_interval;  // 每个阶段的时间，间隔时间</span><br><span class="hljs-comment">                struct timeval it_value;     // 延迟多长时间执行定时器</span><br><span class="hljs-comment">                &#125;;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">                struct timeval &#123;        // 时间的结构体</span><br><span class="hljs-comment">                    time_t      tv_sec;     //  秒数     </span><br><span class="hljs-comment">                    suseconds_t tv_usec;    //  微秒    </span><br><span class="hljs-comment">                &#125;;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">            过10秒后，每个2秒定时一次</span><br><span class="hljs-comment">           </span><br><span class="hljs-comment">            - old_value ：记录上一次的定时的时间参数，一般不使用，指定NULL</span><br><span class="hljs-comment">        </span><br><span class="hljs-comment">        - 返回值：</span><br><span class="hljs-comment">            成功 0</span><br><span class="hljs-comment">            失败 -1 并设置错误号</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-comment">// 过3秒以后，每隔2秒钟定时一次</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">itimerval</span> <span class="hljs-title">new_value</span>;</span><br>    <span class="hljs-comment">// 设置间隔的时间</span><br>    new_value.it_interval.tv_sec = <span class="hljs-number">2</span>;<br>    new_value.it_interval.tv_usec = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 设置延迟的时间,3秒之后开始第一次定时</span><br>    new_value.it_value.tv_sec = <span class="hljs-number">3</span>;<br>    new_value.it_value.tv_usec = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> ret = setitimer(ITIMER_REAL, &amp;new_value, <span class="hljs-literal">NULL</span>); <span class="hljs-comment">// 非阻塞的</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;定时器开始了...\n&quot;</span>);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;setitimer&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    getchar();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="信号捕捉"><a href="#信号捕捉" class="headerlink" title="信号捕捉"></a>信号捕捉</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    #include &lt;signal.h&gt;</span><br><span class="hljs-comment">    typedef void (*sighandler_t)(int);</span><br><span class="hljs-comment">    sighandler_t signal(int signum, sighandler_t handler);</span><br><span class="hljs-comment">        - 功能：设置某个信号的捕捉行为</span><br><span class="hljs-comment">        - 参数：</span><br><span class="hljs-comment">            - signum: 要捕捉的信号</span><br><span class="hljs-comment">            - handler: 捕捉到信号要如何处理</span><br><span class="hljs-comment">                - SIG_IGN ： 忽略信号</span><br><span class="hljs-comment">                - SIG_DFL ： 使用信号默认的行为</span><br><span class="hljs-comment">                - 回调函数 :  这个函数是内核调用，程序员只负责写，捕捉到信号后如何去处理信号。</span><br><span class="hljs-comment">                回调函数：</span><br><span class="hljs-comment">                    - 需要程序员实现，提前准备好的，函数的类型根据实际需求，看函数指针的定义</span><br><span class="hljs-comment">                    - 不是程序员调用，而是当信号产生，由内核调用</span><br><span class="hljs-comment">                    - 函数指针是实现回调的手段，函数实现之后，将函数名放到函数指针的位置就可以了。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        - 返回值：</span><br><span class="hljs-comment">            成功，返回上一次注册的信号处理函数的地址。第一次调用返回NULL</span><br><span class="hljs-comment">            失败，返回SIG_ERR，设置错误号</span><br><span class="hljs-comment">            </span><br><span class="hljs-comment">    SIGKILL SIGSTOP不能被捕捉，不能被忽略。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">myalarm</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;捕捉到了信号的编号是：%d\n&quot;</span>, num);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;xxxxxxx\n&quot;</span>);<br>&#125;<br><span class="hljs-comment">// 过3秒以后，每隔2秒钟定时一次</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 注册信号捕捉</span><br>    <span class="hljs-comment">// signal(SIGALRM, SIG_IGN);</span><br>    <span class="hljs-comment">// signal(SIGALRM, SIG_DFL);</span><br>    <span class="hljs-comment">// void (*sighandler_t)(int); 函数指针，int类型的参数表示捕捉到的信号的值。</span><br>    signal(SIGALRM, myalarm);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">itimerval</span> <span class="hljs-title">new_value</span>;</span><br>   <span class="hljs-comment">// 设置间隔的时间</span><br>    new_value.it_interval.tv_sec = <span class="hljs-number">2</span>;<br>    new_value.it_interval.tv_usec = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 设置延迟的时间,3秒之后开始第一次定时</span><br>    new_value.it_value.tv_sec = <span class="hljs-number">3</span>;<br>    new_value.it_value.tv_usec = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> ret = setitimer(ITIMER_REAL, &amp;new_value, <span class="hljs-literal">NULL</span>); <span class="hljs-comment">// 非阻塞的</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;定时器开始了...\n&quot;</span>);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;setitimer&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    getchar();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="信号集及相关函数"><a href="#信号集及相关函数" class="headerlink" title="信号集及相关函数"></a>信号集及相关函数</h4><p>1.用户通过键盘  Ctrl + C, 产生2号信号SIGINT (信号被创建)</p><p>2.信号产生但是没有被处理 （未决）<br>    - 在内核中将所有的没有被处理的信号存储在一个集合中 （未决信号集）<br>        - SIGINT信号状态被存储在第二个标志位上<br>        - 这个标志位的值为0， 说明信号不是未决状态<br>        - 这个标志位的值为1， 说明信号处于未决状态</p><p>3.这个未决状态的信号，需要被处理，处理之前需要和另一个信号集（阻塞信号集），进行比较<br>    - 阻塞信号集默认不阻塞任何的信号<br>        - 如果想要阻塞某些信号需要用户调用系统的API</p><p>4.在处理的时候和阻塞信号集中的标志位进行查询，看是不是对该信号设置阻塞了<br>    - 如果没有阻塞，这个信号就被处理<br>        - 如果阻塞了，这个信号就继续处于未决状态，直到阻塞解除，这个信号就被处理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    以下信号集相关的函数都是对自定义的信号集进行操作。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    int sigemptyset(sigset_t *set);</span><br><span class="hljs-comment">        - 功能：清空信号集中的数据,将信号集中的所有的标志位置为0</span><br><span class="hljs-comment">        - 参数：set,传出参数，需要操作的信号集</span><br><span class="hljs-comment">        - 返回值：成功返回0， 失败返回-1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    int sigfillset(sigset_t *set);</span><br><span class="hljs-comment">        - 功能：将信号集中的所有的标志位置为1</span><br><span class="hljs-comment">        - 参数：set,传出参数，需要操作的信号集</span><br><span class="hljs-comment">        - 返回值：成功返回0， 失败返回-1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    int sigaddset(sigset_t *set, int signum);</span><br><span class="hljs-comment">        - 功能：设置信号集中的某一个信号对应的标志位为1，表示阻塞这个信号</span><br><span class="hljs-comment">        - 参数：</span><br><span class="hljs-comment">            - set：传出参数，需要操作的信号集</span><br><span class="hljs-comment">            - signum：需要设置阻塞的那个信号</span><br><span class="hljs-comment">        - 返回值：成功返回0， 失败返回-1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    int sigdelset(sigset_t *set, int signum);</span><br><span class="hljs-comment">        - 功能：设置信号集中的某一个信号对应的标志位为0，表示不阻塞这个信号</span><br><span class="hljs-comment">        - 参数：</span><br><span class="hljs-comment">            - set：传出参数，需要操作的信号集</span><br><span class="hljs-comment">            - signum：需要设置不阻塞的那个信号</span><br><span class="hljs-comment">        - 返回值：成功返回0， 失败返回-1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    int sigismember(const sigset_t *set, int signum);</span><br><span class="hljs-comment">        - 功能：判断某个信号是否阻塞</span><br><span class="hljs-comment">        - 参数：</span><br><span class="hljs-comment">            - set：需要操作的信号集</span><br><span class="hljs-comment">            - signum：需要判断的那个信号</span><br><span class="hljs-comment">        - 返回值：</span><br><span class="hljs-comment">            1 ： signum被阻塞</span><br><span class="hljs-comment">            0 ： signum不阻塞</span><br><span class="hljs-comment">            -1 ： 失败</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-comment">// 创建一个信号集</span><br>    <span class="hljs-type">sigset_t</span> <span class="hljs-built_in">set</span>;<br><br>    <span class="hljs-comment">// 清空信号集的内容</span><br>    sigemptyset(&amp;<span class="hljs-built_in">set</span>);<br><br>    <span class="hljs-comment">// 判断 SIGINT 是否在信号集 set 里</span><br>    <span class="hljs-type">int</span> ret = sigismember(&amp;<span class="hljs-built_in">set</span>, SIGINT);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SIGINT 不阻塞\n&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SIGINT 阻塞\n&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 添加几个信号到信号集中</span><br>    sigaddset(&amp;<span class="hljs-built_in">set</span>, SIGINT);<br>    sigaddset(&amp;<span class="hljs-built_in">set</span>, SIGQUIT);<br><br>    <span class="hljs-comment">// 判断SIGINT是否在信号集中</span><br>    ret = sigismember(&amp;<span class="hljs-built_in">set</span>, SIGINT);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SIGINT 不阻塞\n&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SIGINT 阻塞\n&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 判断SIGQUIT是否在信号集中</span><br>    ret = sigismember(&amp;<span class="hljs-built_in">set</span>, SIGQUIT);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SIGQUIT 不阻塞\n&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SIGQUIT 阻塞\n&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 从信号集中删除一个信号</span><br>    sigdelset(&amp;<span class="hljs-built_in">set</span>, SIGQUIT);<br><br>    <span class="hljs-comment">// 判断SIGQUIT是否在信号集中</span><br>    ret = sigismember(&amp;<span class="hljs-built_in">set</span>, SIGQUIT);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SIGQUIT 不阻塞\n&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SIGQUIT 阻塞\n&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="sigprocmask"><a href="#sigprocmask" class="headerlink" title="sigprocmask()"></a>sigprocmask()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);</span><br><span class="hljs-comment">        - 功能：将自定义信号集中的数据设置到内核中（设置阻塞，解除阻塞，替换）</span><br><span class="hljs-comment">        - 参数：</span><br><span class="hljs-comment">            - how : 如何对内核阻塞信号集进行处理</span><br><span class="hljs-comment">                SIG_BLOCK: 将用户设置的阻塞信号集添加到内核中，内核中原来的数据不变</span><br><span class="hljs-comment">                    假设内核中默认的阻塞信号集是mask， mask | set</span><br><span class="hljs-comment">                SIG_UNBLOCK: 根据用户设置的数据，对内核中的数据进行解除阻塞</span><br><span class="hljs-comment">                    mask &amp;= ~set</span><br><span class="hljs-comment">                SIG_SETMASK:覆盖内核中原来的值</span><br><span class="hljs-comment">            </span><br><span class="hljs-comment">            - set ：已经初始化好的用户自定义的信号集</span><br><span class="hljs-comment">            - oldset : 保存设置之前的内核中的阻塞信号集的状态，可以是 NULL</span><br><span class="hljs-comment">        - 返回值：</span><br><span class="hljs-comment">            成功：0</span><br><span class="hljs-comment">            失败：-1</span><br><span class="hljs-comment">                设置错误号：EFAULT、EINVAL</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    int sigpending(sigset_t *set);</span><br><span class="hljs-comment">        - 功能：获取内核中的未决信号集</span><br><span class="hljs-comment">        - 参数：set,传出参数，保存的是内核中的未决信号集中的信息。</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 编写一个程序，把所有的常规信号（1-31）的未决状态打印到屏幕</span><br><span class="hljs-comment">// 设置某些信号是阻塞的，通过键盘产生这些信号</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-comment">// 设置2、3号信号阻塞</span><br>    <span class="hljs-type">sigset_t</span> <span class="hljs-built_in">set</span>;<br>    sigemptyset(&amp;<span class="hljs-built_in">set</span>);<br>    <span class="hljs-comment">// 将2号和3号信号添加到信号集中</span><br>    sigaddset(&amp;<span class="hljs-built_in">set</span>, SIGINT);<br>    sigaddset(&amp;<span class="hljs-built_in">set</span>, SIGQUIT);<br><br>    <span class="hljs-comment">// 修改内核中的阻塞信号集</span><br>    sigprocmask(SIG_BLOCK, &amp;<span class="hljs-built_in">set</span>, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>        num++;<br>        <span class="hljs-comment">// 获取当前的未决信号集的数据</span><br>        <span class="hljs-type">sigset_t</span> pendingset;<br>        sigemptyset(&amp;pendingset);<br>        sigpending(&amp;pendingset);<br><br>        <span class="hljs-comment">// 遍历前32位</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">31</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span>(sigismember(&amp;pendingset, i) == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;1&quot;</span>);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sigismember(&amp;pendingset, i) == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0&quot;</span>);<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                perror(<span class="hljs-string">&quot;sigismember&quot;</span>);<br>                <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>        sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span>(num == <span class="hljs-number">10</span>) &#123;<br>            <span class="hljs-comment">// 解除阻塞</span><br>            sigprocmask(SIG_UNBLOCK, &amp;<span class="hljs-built_in">set</span>, <span class="hljs-literal">NULL</span>);<br>        &#125;<br><br>    &#125;<br><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="sigaction"><a href="#sigaction" class="headerlink" title="sigaction()"></a>sigaction()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    #include &lt;signal.h&gt;</span><br><span class="hljs-comment">    int sigaction(int signum, const struct sigaction *act,</span><br><span class="hljs-comment">                            struct sigaction *oldact);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        - 功能：检查或者改变信号的处理。信号捕捉</span><br><span class="hljs-comment">        - 参数：</span><br><span class="hljs-comment">            - signum : 需要捕捉的信号的编号或者宏值（信号的名称）</span><br><span class="hljs-comment">            - act ：捕捉到信号之后的处理动作</span><br><span class="hljs-comment">            - oldact : 上一次对信号捕捉相关的设置，一般不使用，传递NULL</span><br><span class="hljs-comment">        - 返回值：</span><br><span class="hljs-comment">            成功 0</span><br><span class="hljs-comment">            失败 -1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     struct sigaction &#123;</span><br><span class="hljs-comment">        // 函数指针，指向的函数就是信号捕捉到之后的处理函数</span><br><span class="hljs-comment">        void     (*sa_handler)(int);</span><br><span class="hljs-comment">        // 不常用</span><br><span class="hljs-comment">        void     (*sa_sigaction)(int, siginfo_t *, void *);</span><br><span class="hljs-comment">        // 临时阻塞信号集，在信号捕捉函数执行过程中，临时阻塞某些信号。</span><br><span class="hljs-comment">        sigset_t   sa_mask;</span><br><span class="hljs-comment">        // 使用哪一个信号处理对捕捉到的信号进行处理</span><br><span class="hljs-comment">        // 这个值可以是0，表示使用sa_handler,也可以是SA_SIGINFO表示使用sa_sigaction</span><br><span class="hljs-comment">        int        sa_flags;</span><br><span class="hljs-comment">        // 被废弃掉了</span><br><span class="hljs-comment">        void     (*sa_restorer)(void);</span><br><span class="hljs-comment">    &#125;;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">myalarm</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;捕捉到了信号的编号是：%d\n&quot;</span>, num);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;xxxxxxx\n&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 过3秒以后，每隔2秒钟定时一次</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigaction</span> <span class="hljs-title">act</span>;</span><br>    act.sa_flags = <span class="hljs-number">0</span>;<br>    act.sa_handler = myalarm;<br>    sigemptyset(&amp;act.sa_mask);  <span class="hljs-comment">// 清空临时阻塞信号集</span><br>   <br>    <span class="hljs-comment">// 注册信号捕捉</span><br>    sigaction(SIGALRM, &amp;act, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">itimerval</span> <span class="hljs-title">new_value</span>;</span><br><br>    <span class="hljs-comment">// 设置间隔的时间</span><br>    new_value.it_interval.tv_sec = <span class="hljs-number">2</span>;<br>    new_value.it_interval.tv_usec = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 设置延迟的时间,3秒之后开始第一次定时</span><br>    new_value.it_value.tv_sec = <span class="hljs-number">3</span>;<br>    new_value.it_value.tv_usec = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-type">int</span> ret = setitimer(ITIMER_REAL, &amp;new_value, <span class="hljs-literal">NULL</span>); <span class="hljs-comment">// 非阻塞的</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;定时器开始了...\n&quot;</span>);<br><br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;setitimer&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// getchar();</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="SIGCHLD信号"><a href="#SIGCHLD信号" class="headerlink" title="SIGCHLD信号"></a>SIGCHLD信号</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    SIGCHLD信号产生的3个条件：</span><br><span class="hljs-comment">        1.子进程结束</span><br><span class="hljs-comment">        2.子进程暂停了</span><br><span class="hljs-comment">        3.子进程继续运行</span><br><span class="hljs-comment">        都会给父进程发送该信号，父进程默认忽略该信号。</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    使用SIGCHLD信号解决僵尸进程的问题。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">myFun</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;捕捉到的信号 ：%d\n&quot;</span>, num);<br>    <span class="hljs-comment">// 回收子进程PCB的资源</span><br>    <span class="hljs-comment">// while(1) &#123;</span><br>    <span class="hljs-comment">//     wait(NULL); </span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>       <span class="hljs-type">int</span> ret = waitpid(<span class="hljs-number">-1</span>, <span class="hljs-literal">NULL</span>, WNOHANG);<br>       <span class="hljs-keyword">if</span>(ret &gt; <span class="hljs-number">0</span>) &#123;<br>           <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child die , pid = %d\n&quot;</span>, ret);<br>       &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">0</span>) &#123;<br>           <span class="hljs-comment">// 说明还有子进程或者</span><br>           <span class="hljs-keyword">break</span>;<br>       &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) &#123;<br>           <span class="hljs-comment">// 没有子进程</span><br>           <span class="hljs-keyword">break</span>;<br>       &#125;<br>    &#125;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 提前设置好阻塞信号集，阻塞SIGCHLD，因为有可能子进程很快结束，父进程还没有注册完信号捕捉</span><br>    <span class="hljs-type">sigset_t</span> <span class="hljs-built_in">set</span>;<br>    sigemptyset(&amp;<span class="hljs-built_in">set</span>);<br>    sigaddset(&amp;<span class="hljs-built_in">set</span>, SIGCHLD);<br>    sigprocmask(SIG_BLOCK, &amp;<span class="hljs-built_in">set</span>, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-comment">// 创建一些子进程</span><br>    <span class="hljs-type">pid_t</span> pid;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>        pid = fork();<br>        <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 父进程</span><br>        <span class="hljs-comment">// 捕捉子进程死亡时发送的SIGCHLD信号</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigaction</span> <span class="hljs-title">act</span>;</span><br>        act.sa_flags = <span class="hljs-number">0</span>;<br>        act.sa_handler = myFun;<br>        sigemptyset(&amp;act.sa_mask);<br>        sigaction(SIGCHLD, &amp;act, <span class="hljs-literal">NULL</span>);<br><br>        <span class="hljs-comment">// 注册完信号捕捉以后，解除阻塞</span><br>        sigprocmask(SIG_UNBLOCK, &amp;<span class="hljs-built_in">set</span>, <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;parent process pid : %d\n&quot;</span>, getpid());<br>            sleep(<span class="hljs-number">2</span>);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( pid == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 子进程</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child process pid : %d\n&quot;</span>, getpid());<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="共享内存（效率很高）"><a href="#共享内存（效率很高）" class="headerlink" title="共享内存（效率很高）"></a>共享内存（效率很高）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs C">共享内存相关的函数<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/shm.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">shmget</span><span class="hljs-params">(<span class="hljs-type">key_t</span> key, <span class="hljs-type">size_t</span> size, <span class="hljs-type">int</span> shmflg)</span>;<br>    - 功能：创建一个新的共享内存段，或者获取一个既有的共享内存段的标识。<br>        新创建的内存段中的数据都会被初始化为<span class="hljs-number">0</span><br>    - 参数：<br>        - key : <span class="hljs-type">key_t</span>类型是一个整形，通过这个找到或者创建一个共享内存。<br>                一般使用<span class="hljs-number">16</span>进制表示，非<span class="hljs-number">0</span>值<br>        - size: 共享内存的大小<br>        - shmflg: 属性<br>            - 访问权限<br>            - 附加属性：创建/判断共享内存是不是存在<br>                - 创建：IPC_CREAT<br>                - 判断共享内存是否存在： IPC_EXCL , 需要和IPC_CREAT一起使用<br>                    IPC_CREAT | IPC_EXCL | <span class="hljs-number">0664</span><br>        - 返回值：<br>            失败：<span class="hljs-number">-1</span> 并设置错误号<br>            成功：&gt;<span class="hljs-number">0</span> 返回共享内存的引用的ID，后面操作共享内存都是通过这个值。<br><br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">shmat</span><span class="hljs-params">(<span class="hljs-type">int</span> shmid, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *shmaddr, <span class="hljs-type">int</span> shmflg)</span>;<br>    - 功能：和当前的进程进行关联<br>    - 参数：<br>        - shmid : 共享内存的标识（ID）,由shmget返回值获取<br>        - shmaddr: 申请的共享内存的起始地址，指定<span class="hljs-literal">NULL</span>，内核指定<br>        - shmflg : 对共享内存的操作<br>            - 读 ： SHM_RDONLY, 必须要有读权限<br>            - 读写： <span class="hljs-number">0</span><br>    - 返回值：<br>        成功：返回共享内存的首（起始）地址。  失败(<span class="hljs-type">void</span> *) <span class="hljs-number">-1</span><br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">shmdt</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *shmaddr)</span>;<br>    - 功能：解除当前进程和共享内存的关联<br>    - 参数：<br>        shmaddr：共享内存的首地址<br>    - 返回值：成功 <span class="hljs-number">0</span>， 失败 <span class="hljs-number">-1</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">shmctl</span><span class="hljs-params">(<span class="hljs-type">int</span> shmid, <span class="hljs-type">int</span> cmd, <span class="hljs-keyword">struct</span> shmid_ds *buf)</span>;<br>    - 功能：对共享内存进行操作。删除共享内存，共享内存要删除才会消失，创建共享内存的进行被销毁了对共享内存是没有任何影响。<br>    - 参数：<br>        - shmid: 共享内存的ID<br>        - cmd : 要做的操作<br>            - IPC_STAT : 获取共享内存的当前的状态<br>            - IPC_SET : 设置共享内存的状态<br>            - IPC_RMID: 标记共享内存被销毁<br>        - buf：需要设置或者获取的共享内存的属性信息<br>            - IPC_STAT : buf存储数据<br>            - IPC_SET : buf中需要初始化数据，设置到内核中<br>            - IPC_RMID : 没有用，<span class="hljs-literal">NULL</span><br><br><span class="hljs-type">key_t</span> <span class="hljs-title function_">ftok</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> proj_id)</span>;<br>    - 功能：根据指定的路径名，和<span class="hljs-type">int</span>值，生成一个共享内存的key<br>    - 参数：<br>        - pathname:指定一个存在的路径<br>            /home/nowcoder/Linux/a.txt<br>            / <br>        - proj_id: <span class="hljs-type">int</span>类型的值，但是这系统调用只会使用其中的<span class="hljs-number">1</span>个字节<br>                   范围 ： <span class="hljs-number">0</span><span class="hljs-number">-255</span>  一般指定一个字符 <span class="hljs-string">&#x27;a&#x27;</span><br><br><br>问题<span class="hljs-number">1</span>：操作系统如何知道一块共享内存被多少个进程关联？<br>    - 共享内存维护了一个结构体<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">shmid_ds</span> 这个结构体中有一个成员 <span class="hljs-title">shm_nattch</span></span><br><span class="hljs-class">    - <span class="hljs-title">shm_nattach</span> 记录了关联的进程个数</span><br><span class="hljs-class"></span><br><span class="hljs-class">问题2：可不可以对共享内存进行多次删除 <span class="hljs-title">shmctl</span></span><br><span class="hljs-class">    - 可以的</span><br><span class="hljs-class">    - 因为<span class="hljs-title">shmctl</span> 标记删除共享内存，不是直接删除</span><br><span class="hljs-class">    - 什么时候真正删除呢?</span><br><span class="hljs-class">        当和共享内存关联的进程数为0的时候，就真正被删除</span><br><span class="hljs-class">    - 当共享内存的<span class="hljs-title">key</span>为0的时候，表示共享内存被标记删除了</span><br><span class="hljs-class">        如果一个进程和共享内存取消关联，那么这个进程就不能继续操作这个共享内存。也不能进行关联。</span><br><span class="hljs-class"></span><br><span class="hljs-class">    共享内存和内存映射的区别</span><br><span class="hljs-class">    1.共享内存可以直接创建，内存映射需要磁盘文件（匿名映射除外）</span><br><span class="hljs-class">    2.共享内存效果更高</span><br><span class="hljs-class">    3.内存</span><br><span class="hljs-class">        所有的进程操作的是同一块共享内存。</span><br><span class="hljs-class">        内存映射，每个进程在自己的虚拟地址空间中有一个独立的内存。</span><br><span class="hljs-class">    4.数据安全</span><br><span class="hljs-class">        - 进程突然退出</span><br><span class="hljs-class">            共享内存还存在</span><br><span class="hljs-class">            内存映射区消失</span><br><span class="hljs-class">        - 运行进程的电脑死机，宕机了</span><br><span class="hljs-class">            数据存在在共享内存中，没有了</span><br><span class="hljs-class">            内存映射区的数据 ，由于磁盘文件中的数据还在，所以内存映射区的数据还存在。</span><br><span class="hljs-class"></span><br><span class="hljs-class">    5.生命周期</span><br><span class="hljs-class">        - 内存映射区：进程退出，内存映射区销毁</span><br><span class="hljs-class">        - 共享内存：进程退出，共享内存还在，标记删除（所有的关联的进程数为0），或者关机</span><br><span class="hljs-class">            如果一个进程退出，会自动和共享内存进行取消关联。</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/shm.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;    <br><br>    <span class="hljs-comment">// 1.创建一个共享内存</span><br>    <span class="hljs-type">int</span> shmid = shmget(<span class="hljs-number">100</span>, <span class="hljs-number">4096</span>, IPC_CREAT|<span class="hljs-number">0664</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;shmid : %d\n&quot;</span>, shmid);<br>    <br>    <span class="hljs-comment">// 2.和当前进程进行关联</span><br>    <span class="hljs-type">void</span> * ptr = shmat(shmid, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-type">char</span> * str = <span class="hljs-string">&quot;helloworld&quot;</span>;<br><br>    <span class="hljs-comment">// 3.写数据</span><br>    <span class="hljs-built_in">memcpy</span>(ptr, str, <span class="hljs-built_in">strlen</span>(str) + <span class="hljs-number">1</span>);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;按任意键继续\n&quot;</span>);<br>    getchar();<br><br>    <span class="hljs-comment">// 4.解除关联</span><br>    shmdt(ptr);<br><br>    <span class="hljs-comment">// 5.删除共享内存</span><br>    shmctl(shmid, IPC_RMID, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    写一个守护进程，每隔2s获取一下系统时间，将这个时间写入到磁盘文件中。</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">work</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>    <span class="hljs-comment">// 捕捉到信号之后，获取系统时间，写入磁盘文件</span><br>    <span class="hljs-type">time_t</span> tm = time(<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tm</span> * <span class="hljs-title">loc</span> =</span> localtime(&amp;tm);<br>    <span class="hljs-comment">// char buf[1024];</span><br><br>    <span class="hljs-comment">// sprintf(buf, &quot;%d-%d-%d %d:%d:%d\n&quot;,loc-&gt;tm_year,loc-&gt;tm_mon</span><br>    <span class="hljs-comment">// ,loc-&gt;tm_mday, loc-&gt;tm_hour, loc-&gt;tm_min, loc-&gt;tm_sec);</span><br><br>    <span class="hljs-comment">// printf(&quot;%s\n&quot;, buf);</span><br><br>    <span class="hljs-type">char</span> * str = asctime(loc);<br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;time.txt&quot;</span>, O_RDWR | O_CREAT | O_APPEND, <span class="hljs-number">0664</span>);<br>    write(fd ,str, <span class="hljs-built_in">strlen</span>(str));<br>    close(fd);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-comment">// 1.创建子进程，退出父进程</span><br>    <span class="hljs-type">pid_t</span> pid = fork();<br><br>    <span class="hljs-keyword">if</span>(pid &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 2.将子进程重新创建一个会话</span><br>    setsid();<br><br>    <span class="hljs-comment">// 3.设置掩码</span><br>    umask(<span class="hljs-number">022</span>);<br><br>    <span class="hljs-comment">// 4.更改工作目录</span><br>    chdir(<span class="hljs-string">&quot;/home/nowcoder/&quot;</span>);<br><br>    <span class="hljs-comment">// 5. 关闭、重定向文件描述符</span><br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;/dev/null&quot;</span>, O_RDWR);<br>    dup2(fd, STDIN_FILENO);<br>    dup2(fd, STDOUT_FILENO);<br>    dup2(fd, STDERR_FILENO);<br><br>    <span class="hljs-comment">// 6.业务逻辑</span><br><br>    <span class="hljs-comment">// 捕捉定时信号</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sigaction</span> <span class="hljs-title">act</span>;</span><br>    act.sa_flags = <span class="hljs-number">0</span>;<br>    act.sa_handler = work;<br>    sigemptyset(&amp;act.sa_mask);<br>    sigaction(SIGALRM, &amp;act, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">itimerval</span> <span class="hljs-title">val</span>;</span><br>    val.it_value.tv_sec = <span class="hljs-number">2</span>;<br>    val.it_value.tv_usec = <span class="hljs-number">0</span>;<br>    val.it_interval.tv_sec = <span class="hljs-number">2</span>;<br>    val.it_interval.tv_usec = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 创建定时器</span><br>    setitimer(ITIMER_REAL, &amp;val, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// 不让进程结束</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>        sleep(<span class="hljs-number">10</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
    
    
    <categories>
      
      <category>Linux编程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux系统编程</title>
    <link href="/2023/06/03/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    <url>/2023/06/03/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux系统编程"><a href="#Linux系统编程" class="headerlink" title="Linux系统编程"></a>Linux系统编程</h1><h2 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h2><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><ol><li><p>源代码</p></li><li><p>预处理器    -E    <code>gcc  main.c -E -o main.i</code></p><p>预处理后的源代码</p></li><li><p>编译器    -S    <code>gcc  main.i -S -o main.s</code></p><p>汇编代码</p></li><li><p>汇编器    -c    <code>gcc  main.s -c -o main.o</code></p><p>目标代码</p></li><li><p>链接器</p><p>启动代码、目标代码、库代码、其他目标代码</p></li><li><p>可执行程序</p></li></ol><h3 id="G"><a href="#G" class="headerlink" title="G++"></a>G++</h3><ol><li>gcc 和 g++都可以编译C 和 C++，gcc不能自动的链接C++的库，所以就统一使用g++了</li><li>gcc 链接C++的命令  <code>gcc -lstdc++</code></li></ol><h3 id="GCC常用命令"><a href="#GCC常用命令" class="headerlink" title="GCC常用命令"></a>GCC常用命令</h3><img src="截屏2023-03-11 13.12.50.png" alt="截屏2023-03-11 13.12.50" style="zoom: 67%;" /><img src="截屏2023-03-11 13.21.38.png" alt="截屏2023-03-11 13.21.38" style="zoom: 67%;" /><p>-D 可以指定代码里定义的 #ifdefine FUCK 的宏，可以在debug时用</p><hr><h2 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h2><h3 id="什么是库"><a href="#什么是库" class="headerlink" title="什么是库"></a>什么是库</h3><p>库是计算机上的一类文件，可以将其简单的看作代码仓库。库不能单独运行。</p><p><strong>静态库：</strong>在程序链接阶段被复制到程序中</p><p><strong>动态库：</strong>在程序运行阶段由系统动态加载到内存中，供程序使用</p><h3 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h3><p><code>libxxx.a</code>,xxx写库的名称</p><h3 id="静态库制作"><a href="#静态库制作" class="headerlink" title="静态库制作"></a>静态库制作</h3><ol><li>gcc获取.o文件，<code>gcc -c add.c sub.c mult.c div.c </code></li><li>使用ar工具将.o文件打包<code>ar rcs libcalc.a add.o sub.o div.o mult.o</code><ol><li>参数：r 将.o文件插入到库中</li><li>参数：c 创建库文件</li><li>参数：s 创建索引</li></ol></li></ol><h3 id="静态库使用"><a href="#静态库使用" class="headerlink" title="静态库使用"></a>静态库使用</h3><p>库文件要和对应的头文件一起使用</p><p><code>gcc main.c -o app -I ./include/ -l calc -L ./lib</code></p><p>-l 后面是库的名字而不是库文件的名字，-I添加头文件搜索路径，-L添加库文件搜索路径</p><h2 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h2><h3 id="命名规则-1"><a href="#命名规则-1" class="headerlink" title="命名规则"></a>命名规则</h3><p><code>libxxx.so</code>，后缀不一样，在Linux中是个可执行文件</p><h3 id="制作过程"><a href="#制作过程" class="headerlink" title="制作过程"></a>制作过程</h3><h4 id="得到-o文件，和文件位置无关-fpic"><a href="#得到-o文件，和文件位置无关-fpic" class="headerlink" title="得到.o文件，和文件位置无关 -fpic"></a>得到.o文件，和文件位置无关 -fpic</h4><p><code>gcc -c -fpic add.c sub.c</code></p><h4 id="得到动态库"><a href="#得到动态库" class="headerlink" title="得到动态库"></a>得到动态库</h4><p><code>gcc -shared add.o sub.o -o libcalc.so</code></p><h3 id="动态库使用原理"><a href="#动态库使用原理" class="headerlink" title="动态库使用原理"></a>动态库使用原理</h3><p>动态库不会被打包到可执行文件中，只会放里一些库的信息，在程序运行时会加载到内存中。</p><p>使用 <code>ldd 程序名</code>  命令查询程序动态库依赖信息</p><p> 程序需要获取动态库的绝对路径，这就要使用系统的动态载入器了。会查询系统的 <strong>环境变量LD_LIBRARY_PATH</strong>，&#x2F;etc&#x2F;ld.so.cache，&#x2F;lib&#x2F;，&#x2F;usr&#x2F;lib</p><p><strong>所以使用动态库的时候要选上面的一个文件，将动态库绝对路径添加进去</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#终端级别</span><br><span class="hljs-built_in">export</span> LD_LIBRARY_PATH=<span class="hljs-variable">$LD_LIBRARY_PATH</span>:/home/webserver/test/lib  <span class="hljs-comment">#这个方法只在当前终端生效，关掉终端就没了</span><br><span class="hljs-comment">#用户级别 </span><br>vim .bashrc <span class="hljs-comment">#在用户文件夹下的.bashrc文件中添加上面的代码</span><br><span class="hljs-built_in">source</span> .bashrc<br><span class="hljs-comment">#系统级别,有的时候如果提前配置了用户或者终端的，最好重开一下终端</span><br>sudo vim /etc/profile<span class="hljs-comment">#在这个文件中加上面的代码</span><br><span class="hljs-built_in">source</span> /etc/profile<br><span class="hljs-comment">#ld.so.config级别</span><br>sodu vim /etc/ld.so.conf<br>ldconfig<br><br>gcc main.c -o APP -I ./include/ -l calc -L ./lib<br>./APP<br></code></pre></td></tr></table></figure><h2 id="静态库和动态库的对比"><a href="#静态库和动态库的对比" class="headerlink" title="静态库和动态库的对比"></a>静态库和动态库的对比</h2><h3 id="静态库优缺点"><a href="#静态库优缺点" class="headerlink" title="静态库优缺点"></a>静态库优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li>静态库被打包到应用程序中加载速度快。</li><li>发布程序不需要提供静态库，移植方便。</li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li>消耗系统资源，浪费内存。</li><li>更新部署发布麻烦。</li></ol><h3 id="动态库优缺点"><a href="#动态库优缺点" class="headerlink" title="动态库优缺点"></a>动态库优缺点</h3><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ol><li>可以实现进程间资源共享</li><li>更新发布简单</li><li>可以控制何时加载库</li></ol><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ol><li>加载速度慢</li><li>发布程序的时候需要提供以来的动态库</li></ol><h2 id="Makefile-—》CMake"><a href="#Makefile-—》CMake" class="headerlink" title="Makefile —》CMake"></a>Makefile —》CMake</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 将文件夹内的所有源文件保存到指定变量名中</span><br><span class="hljs-keyword">aux_source_directory</span>(&lt;dir&gt; &lt;variable&gt;) <br><span class="hljs-keyword">aux_source_directory</span>(. DIR_SRC)<br><span class="hljs-keyword">add_executable</span>(Demo,<span class="hljs-variable">$&#123;DIR_SRC&#125;</span>)<br><br><br><span class="hljs-comment"># 多目录多文件的情况下，每个目录都要有自己的CMakeLists</span><br><span class="hljs-keyword">add_subdirectory</span>(<span class="hljs-keyword">math</span>)<br><span class="hljs-keyword">add_executable</span>(Demo,<span class="hljs-variable">$&#123;DIR_SRC&#125;</span>)<br>target_link_library(Demo MathFunction)<br><span class="hljs-comment"># 子目录的CMakeList</span><br><span class="hljs-comment"># 查找当前目录下的所有源文件</span><br><span class="hljs-comment"># 并将名称保存到 DIR_LIB_SRCS 变量</span><br><span class="hljs-keyword">aux_source_directory</span>(. DIR_LIB_SRCS)<br><span class="hljs-comment"># 生成链接库</span><br><span class="hljs-keyword">add_library</span> (MathFunctions <span class="hljs-variable">$&#123;DIR_LIB_SRCS&#125;</span>)<br></code></pre></td></tr></table></figure><h2 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>为调试而编译的时，打开调试选项-g  -Wall </p><p>-g是在可执行程序中加入源代码信息</p><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p><code>gdb xxx</code> 开启</p><p><code>set args xxx1 xxx2</code> 设置参数</p><p><code>show args</code> 获取参数</p><p><code>list</code>  显示代码，后面可以跟行号、函数名  </p><p><code>break</code> 设置断点。 <code>info break</code> 查看断点。<code>del break</code>  删除</p><img src="截屏2023-03-16 21.20.40.png" alt="截屏2023-03-16 21.20.40" style="zoom:25%;" /><p><code>quit</code> 退出</p><img src="截屏2023-03-16 21.21.21.png" alt="截屏2023-03-16 21.21.21" style="zoom: 25%;" /><hr><h2 id="标准C库IO函数和Linux系统IO函数对比"><a href="#标准C库IO函数和Linux系统IO函数对比" class="headerlink" title="标准C库IO函数和Linux系统IO函数对比"></a>标准C库IO函数和Linux系统IO函数对比</h2> <img src="截屏2023-03-16 22.03.14.png" alt="截屏2023-03-16 22.03.14" style="zoom:50%;" /><p>缓冲区提高了效率，降低了写磁盘的次数。因为缓冲区是在内存中的，写它速度快。默认大约8kb。</p><img src="截屏2023-03-16 22.13.11.png" alt="截屏2023-03-16 22.13.11" style="zoom:50%;" /><h2 id="虚拟地址空间"><a href="#虚拟地址空间" class="headerlink" title="虚拟地址空间"></a>虚拟地址空间</h2><img src="截屏2023-03-16 22.25.36.png" alt="截屏2023-03-16 22.25.36" style="zoom:50%;" /><h2 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h2><img src="截屏2023-03-21 22.40.31.png" alt="截屏2023-03-21 22.40.31" style="zoom:50%;" /><h2 id="Linux系统IO函数"><a href="#Linux系统IO函数" class="headerlink" title="Linux系统IO函数"></a>Linux系统IO函数</h2><p>![截屏2023-03-21 22.48.14](截屏2023-03-21 22.48.14.png)</p><h3 id="open函数"><a href="#open函数" class="headerlink" title="open函数"></a>open函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    #include &lt;sys/types.h&gt;</span><br><span class="hljs-comment">    #include &lt;sys/stat.h&gt;</span><br><span class="hljs-comment">    #include &lt;fcntl.h&gt;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    // 打开一个已经存在的文件</span><br><span class="hljs-comment">    int open(const char *pathname, int flags);</span><br><span class="hljs-comment">        参数：</span><br><span class="hljs-comment">            - pathname：要打开的文件路径</span><br><span class="hljs-comment">            - flags：对文件的操作权限设置还有其他的设置</span><br><span class="hljs-comment">              O_RDONLY,  O_WRONLY,  O_RDWR  这三个设置是互斥的</span><br><span class="hljs-comment">        返回值：返回一个新的文件描述符，如果调用失败，返回-1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    errno：属于Linux系统函数库，库里面的一个全局变量，记录的是最近的错误号。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    #include &lt;stdio.h&gt;</span><br><span class="hljs-comment">    void perror(const char *s);作用：打印errno对应的错误描述</span><br><span class="hljs-comment">        s参数：用户描述，比如hello,最终输出的内容是  hello:xxx(实际的错误描述)</span><br><span class="hljs-comment">    // 创建一个新的文件</span><br><span class="hljs-comment">    int open(const char *pathname, int flags, mode_t mode);</span><br><span class="hljs-comment">    flags = O_CREAT 文件不存在将会创建</span><br><span class="hljs-comment">    mode 必须是8进制的数，表示创建出的文件的操作权限 比如0775</span><br><span class="hljs-comment">    最终权限是：mode &amp; ~umask</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-comment">// 打开一个文件</span><br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;a.txt&quot;</span>, O_RDONLY);<br><br>    <span class="hljs-keyword">if</span>(fd == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;open&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 读写操作</span><br><br>    <span class="hljs-comment">// 关闭</span><br>    close(fd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过open创建文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> fd=open(<span class="hljs-string">&quot;create.txt&quot;</span>, O_RDWR | O_CREAT,<span class="hljs-number">0777</span>);<br>    <span class="hljs-keyword">if</span>(fd == <span class="hljs-number">-1</span>)&#123;<br>        perror(<span class="hljs-string">&quot;open&quot;</span>);<br>    &#125;<br>    close(fd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>flag是一个int类型的数字。占4个字节，32位。所以flag32个bit，每个位就是一个标志位。用按位或，可以增加多个权限。</p><h3 id="read和write函数"><a href="#read和write函数" class="headerlink" title="read和write函数"></a>read和write函数</h3><p>read从文件中读取数据到内存中，write反过来。</p><p><code>ssize_t read(int fd,void* buf,size_t count);</code></p><p>fd ：是文件描述符</p><p>buf ：要读取数据存放的地方，数组的地址</p><p>count ：指定数组的大小</p><p>返回值为：成功，&gt;0返回读取的比特数，&#x3D;0说明文件读完了</p><p>​   失败返回-1，并将errno设置为合适的值</p><p>write函数参数的含义和read类似</p><h3 id="lseek函数"><a href="#lseek函数" class="headerlink" title="lseek函数"></a>lseek函数</h3><p>对文件指针进行操作。</p><p><code>off_t lseek(int fd, off_t offset, int whence)</code></p><p>offset：偏移量</p><p>whence：</p><ul><li>SEEK_SET：设置文件指针偏移量</li><li>SEEK_END：设置偏移量，当前位置+第二个参数offset</li><li>SEEK_CUR：设置偏移量，文件结尾+第二个参数offset</li></ul><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ol><li>移动文件指针到头文件，<code>lseek(fd, 0 , SEEK_SET)</code></li><li>用来获取当前文件指针的位置 , <code>lseek(fd,0 , SEEK_CUR)</code></li><li>用来获取文件长度 <code>lseek(fd,0,SEEK_END)</code></li><li>拓展文件的长度 <code>lseek(fd,1000,SEEK_END)</code>将文件扩展1000个字节</li></ol><h3 id="stat，lstat函数"><a href="#stat，lstat函数" class="headerlink" title="stat，lstat函数"></a>stat，lstat函数</h3><h4 id="stat作用"><a href="#stat作用" class="headerlink" title="stat作用"></a>stat作用</h4><p>获取一个文件相关的信息  </p><p><code>int stat(const char* pathname, struct stat* bufstat)</code></p><ul><li>pathname : 文件路径</li><li>statbuf：结构体，传出参数，用与保存获取到的文件的信息 </li><li>返回值：0 -1 errno</li></ul><p><img src="../../../../../../../WebServer.assets/截屏2023-03-24 22.33.04.png" alt="截屏2023-03-24 22.33.04" style="zoom:50%;" /><img src="截屏2023-03-24 22.34.19.png" alt="截屏2023-03-24 22.34.19" style="zoom:50%;" /></p><p>判断文件权限，将st_mode和权限的宏进行按位与，判断是否为1  </p><p>判断文件类型，将st_mode和掩码进行按位与，然后和宏进行相等的比较</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">statbuf</span>;</span><br>   <span class="hljs-type">int</span> ret = stat(<span class="hljs-string">&quot;a.txt&quot;</span>,&amp;statbuf);<br>   <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)&#123;<br>       perror(<span class="hljs-string">&quot;stat&quot;</span>);<br>       <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>   &#125;<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;size: %ld\n&quot;</span>,statbuf.st_size);<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="lstat"><a href="#lstat" class="headerlink" title="lstat"></a>lstat</h4><p>获取软连接文件的信息</p><h3 id="模拟实现ls-l命令"><a href="#模拟实现ls-l命令" class="headerlink" title="模拟实现ls -l命令"></a>模拟实现ls -l命令</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 模拟实现ls -l指令</span><br><span class="hljs-comment">// -rw-r--r-- 1 root root 0 Mar 24 14:43 a.txt</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pwd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;grp.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s 文件名称\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 通过stat函数获取用户传入文件的信息</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">st</span>;</span><br>    <span class="hljs-type">int</span> ret = stat(argv[<span class="hljs-number">1</span>], &amp;st);<br>    <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;stat&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 获取文件类型和文件权限</span><br>    <span class="hljs-type">char</span> perms[<span class="hljs-number">11</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">switch</span> (st.st_mode &amp; __S_IFMT)<br>    &#123;<br>    <span class="hljs-keyword">case</span> __S_IFLNK:<br>        perms[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;l&#x27;</span>;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> __S_IFDIR:<br>        perms[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;d&#x27;</span>;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> __S_IFREG:<br>        perms[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;-&#x27;</span>;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> __S_IFBLK:<br>        perms[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;b&#x27;</span>;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> __S_IFCHR:<br>        perms[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;c&#x27;</span>;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> __S_IFSOCK:<br>        perms[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;s&#x27;</span>;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> __S_IFIFO:<br>        perms[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;p&#x27;</span>;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>        perms[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;?&#x27;</span>;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">// 判断文件访问权限</span><br>    <span class="hljs-comment">// 文件所有者</span><br>    perms[<span class="hljs-number">1</span>] = (st.st_mode &amp; S_IRUSR) ? <span class="hljs-string">&#x27;r&#x27;</span> : <span class="hljs-string">&#x27;-&#x27;</span>;<br>    perms[<span class="hljs-number">2</span>] = (st.st_mode &amp; S_IWUSR) ? <span class="hljs-string">&#x27;w&#x27;</span> : <span class="hljs-string">&#x27;-&#x27;</span>;<br>    perms[<span class="hljs-number">3</span>] = (st.st_mode &amp; S_IXUSR) ? <span class="hljs-string">&#x27;x&#x27;</span> : <span class="hljs-string">&#x27;-&#x27;</span>;<br>    <span class="hljs-comment">// 文件所在组</span><br>    perms[<span class="hljs-number">4</span>] = (st.st_mode &amp; S_IRGRP) ? <span class="hljs-string">&#x27;r&#x27;</span> : <span class="hljs-string">&#x27;-&#x27;</span>;<br>    perms[<span class="hljs-number">5</span>] = (st.st_mode &amp; S_IWGRP) ? <span class="hljs-string">&#x27;w&#x27;</span> : <span class="hljs-string">&#x27;-&#x27;</span>;<br>    perms[<span class="hljs-number">6</span>] = (st.st_mode &amp; S_IXGRP) ? <span class="hljs-string">&#x27;x&#x27;</span> : <span class="hljs-string">&#x27;-&#x27;</span>;<br>    <span class="hljs-comment">// 其他人</span><br>    perms[<span class="hljs-number">7</span>] = (st.st_mode &amp; S_IROTH) ? <span class="hljs-string">&#x27;r&#x27;</span> : <span class="hljs-string">&#x27;-&#x27;</span>;<br>    perms[<span class="hljs-number">8</span>] = (st.st_mode &amp; S_IWOTH) ? <span class="hljs-string">&#x27;w&#x27;</span> : <span class="hljs-string">&#x27;-&#x27;</span>;<br>    perms[<span class="hljs-number">9</span>] = (st.st_mode &amp; S_IXOTH) ? <span class="hljs-string">&#x27;x&#x27;</span> : <span class="hljs-string">&#x27;-&#x27;</span>;<br><br>    <span class="hljs-comment">// 硬连接数</span><br>    <span class="hljs-type">int</span> link_num = st.st_nlink;<br><br>    <span class="hljs-comment">// 获取文件所有者名称</span><br>    <span class="hljs-type">char</span> *file_user = getpwuid(st.st_uid)-&gt;pw_name;<br><br>    <span class="hljs-comment">// 获取文件所在组</span><br>    <span class="hljs-type">char</span> *file_group = getgrgid(st.st_gid)-&gt;gr_name;<br><br>    <span class="hljs-comment">// 获取文件大小</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">int</span> file_size = st.st_size;<br><br>    <span class="hljs-comment">// 获取修改时间</span><br>    <span class="hljs-type">char</span> *time = ctime(&amp;st.st_mtim);<br><br>    <span class="hljs-type">char</span> mtime[<span class="hljs-number">512</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-built_in">strncpy</span>(mtime, time, <span class="hljs-built_in">strlen</span>(time) - <span class="hljs-number">1</span>);<br><br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>];<br>    <span class="hljs-built_in">sprintf</span>(buf, <span class="hljs-string">&quot;%s %d %s %s %ld %s %s&quot;</span>, perms, link_num, file_user, file_group, file_size, mtime, argv[<span class="hljs-number">1</span>]);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, buf);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="access"><a href="#access" class="headerlink" title="access()"></a>access()</h3><p><code> #include &lt;unistd.h&gt;</code></p><p><code>int access(const char* pathname, int mode)</code>判断文件是否具有某种权限，或者判断文件是否存在。</p><ul><li>pathname:文件路径</li><li>mode：R_OK W_OK X_OK F_OK(判断是否存在)</li><li>成功返回0 失败返回-1</li></ul><h3 id="chmod"><a href="#chmod" class="headerlink" title="chmod()"></a>chmod()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">chmod</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">mode_t</span> mode)</span>;<br></code></pre></td></tr></table></figure><p>修改文件的权限。</p><ul><li>mode_t:需要修改的权限值。八进制的数。 man手册里有</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> ret = chmod(<span class="hljs-string">&quot;fake_ls.c&quot;</span>,<span class="hljs-number">0777</span>);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)&#123;<br>        perror(<span class="hljs-string">&quot;chmod&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="truncate（）"><a href="#truncate（）" class="headerlink" title="truncate（）"></a>truncate（）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">truncate</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">off_t</span> length)</span>;<br><span class="hljs-comment">// length是需要最终文件变成的大小</span><br></code></pre></td></tr></table></figure><p>缩减或者扩展文件的尺寸到指定的大小。如果缩小尺寸，超出部分数据会丢失。</p><h3 id="和目录操作相关的函数"><a href="#和目录操作相关的函数" class="headerlink" title="和目录操作相关的函数"></a>和目录操作相关的函数</h3><img src="截屏2023-03-27 21.50.40.png" alt="截屏2023-03-27 21.50.40" style="zoom:50%;" /><p>DIR* 可以理解为目录流</p><p><code>#include &lt;dirent.h&gt;</code></p><p><code>DIR* opendir(char const *name)</code></p><p><code>struct dirent *readdir(DIR* dirp)</code>每次调用，dirp都会执向下一个目录。</p><p>读取到末尾返回NULL，但是不设置errno。读取错误就返回NULL并设置errno。</p><p><code>int closedir(DIR* dirp)</code></p><p>![截屏2023-03-31 16.04.26](截屏2023-03-31 16.04.26.png)</p><p>实现一个统计目录下所有普通文件个数的功能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dirent.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">getFileNum</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* path)</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(argc&lt;<span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入路径: %s \n&quot;</span>,argv[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> nums = getFileNum(argv[<span class="hljs-number">1</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;普通文件个数 : %d\n&quot;</span>,nums);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">getFileNum</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* path)</span>&#123;<br>    DIR* dir = opendir(path);<br>    <span class="hljs-keyword">if</span>(dir==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;opendir failed&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 记录普通文件的个数</span><br>    <span class="hljs-type">int</span> total = <span class="hljs-number">0</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span>* <span class="hljs-title">dirp</span> =</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">while</span>((dirp = readdir(dir)) != <span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-comment">// 获取名称</span><br>        <span class="hljs-type">char</span>* dname = dirp-&gt;d_name;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(dname,<span class="hljs-string">&quot;.&quot;</span>)==<span class="hljs-number">0</span> || <span class="hljs-built_in">strcmp</span>(dname,<span class="hljs-string">&quot;..&quot;</span>)==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-comment">// 为目录</span><br>        <span class="hljs-keyword">if</span>(dirp-&gt;d_type==DT_DIR)&#123;<br>            <span class="hljs-type">char</span> newpath[<span class="hljs-number">256</span>];<br>            <span class="hljs-built_in">sprintf</span>(newpath,<span class="hljs-string">&quot;%s/%s&quot;</span>,path,dname);<br>            total += getFileNum(newpath);    <br>        &#125;<br>        <span class="hljs-comment">// 为普通文件</span><br>        <span class="hljs-keyword">if</span>(dirp-&gt;d_type == DT_REG)&#123;<br>            total++;<br>        &#125;<br>    &#125;<br>    closedir(dir);<br>    <span class="hljs-keyword">return</span> total;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="和文件操作符相关的函数"><a href="#和文件操作符相关的函数" class="headerlink" title="和文件操作符相关的函数"></a>和文件操作符相关的函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">dup</span><span class="hljs-params">(<span class="hljs-type">int</span> oldfd)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">dup2</span><span class="hljs-params">(<span class="hljs-type">int</span> oldfd, <span class="hljs-type">int</span> newfd)</span>;<br></code></pre></td></tr></table></figure><h4 id="dup-int-oldfd-复制文件描述符"><a href="#dup-int-oldfd-复制文件描述符" class="headerlink" title="dup(int oldfd)复制文件描述符"></a>dup(int oldfd)复制文件描述符</h4><p>创建一个传入文件描述符的复制品，复制品从文件描述符表中挑目前可用的、最小的文件描述符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;dum.txt&quot;</span>, O_RDWR | O_CREAT, <span class="hljs-number">0664</span>);<br>    <span class="hljs-type">int</span> fd1 = dup(fd);<br>    <span class="hljs-keyword">if</span> (fd1 == <span class="hljs-number">-1</span>)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;dup&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fd : %d , fd1 :%d&quot;</span>, fd, fd1);<br>    close(fd);<br><br>    <span class="hljs-type">char</span>* str = <span class="hljs-string">&quot;Hello World&quot;</span>;<br>    <span class="hljs-type">int</span> ret = write(fd1,str,<span class="hljs-built_in">strlen</span>(str));<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)&#123;<br>        perror(<span class="hljs-string">&quot;write&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    close(fd1);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//TERMINAL</span><br><span class="hljs-comment">//fd : 3 , fd1 :4</span><br></code></pre></td></tr></table></figure><h4 id="dup2-int-oldfd-int-newfd-重定向文件描述符"><a href="#dup2-int-oldfd-int-newfd-重定向文件描述符" class="headerlink" title="dup2(int oldfd, int newfd)重定向文件描述符"></a>dup2(int oldfd, int newfd)重定向文件描述符</h4><p>和dup执行的功能差不多，但是用我们指定的newfd文件描述符去指向oldfd指向的文件。</p><p>newfd之前指向的文件就不算数了。oldfd必须是一个有效的文件描述符。</p><p>old和new的值相同时，什么都不会发生。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;1.txt&quot;</span>, O_RDWR | O_CREAT, <span class="hljs-number">0664</span>);<br>    <span class="hljs-keyword">if</span> (fd == <span class="hljs-number">-1</span>)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;open&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> fd1 = open(<span class="hljs-string">&quot;2.txt&quot;</span>, O_RDWR | O_CREAT, <span class="hljs-number">0664</span>);<br>    <span class="hljs-keyword">if</span> (fd1 == <span class="hljs-number">-1</span>)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;open&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fd : %d , fd1 :%d \n&quot;</span>, fd, fd1);<br>    <span class="hljs-type">int</span> fd2 = dup2(fd, fd1);<br>    <span class="hljs-keyword">if</span> (fd2 == <span class="hljs-number">-1</span>)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;dup2&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 通过fd1去写数据，实际操作的1.txt</span><br>    <span class="hljs-type">char</span> *str = <span class="hljs-string">&quot;Hello World&quot;</span>;<br>    <span class="hljs-type">int</span> ret = write(fd1, str, <span class="hljs-built_in">strlen</span>(str));<br>    <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>)<br>    &#123;<br>        perror(<span class="hljs-string">&quot;write&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fd : %d , fd1 :%d , fd2:%d \n&quot;</span>, fd, fd1, fd2);<br>    close(fd1);<br>    close(fd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//fd : 3 , fd1 :4 </span><br><span class="hljs-comment">//fd : 3 , fd1 :4 , fd2:4 </span><br><span class="hljs-comment">//2.txt中有HELLO WORLD</span><br></code></pre></td></tr></table></figure><h3 id="fcntl"><a href="#fcntl" class="headerlink" title="fcntl()"></a>fcntl()</h3><p>去查chatgpt吧</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fcntl</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> cmd, ... <span class="hljs-comment">/* arg */</span> )</span>;<br><span class="hljs-comment">// cmd：命令宏</span><br><span class="hljs-comment">// ...：可变参数</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    #include &lt;unistd.h&gt;</span><br><span class="hljs-comment">    #include &lt;fcntl.h&gt;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    int fcntl(int fd, int cmd, ...);</span><br><span class="hljs-comment">    参数：</span><br><span class="hljs-comment">        fd : 表示需要操作的文件描述符</span><br><span class="hljs-comment">        cmd: 表示对文件描述符进行如何操作</span><br><span class="hljs-comment">            - F_DUPFD : 复制文件描述符,复制的是第一个参数fd，得到一个新的文件描述符（返回值）</span><br><span class="hljs-comment">                int ret = fcntl(fd, F_DUPFD);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">            - F_GETFL : 获取指定的文件描述符文件状态flag</span><br><span class="hljs-comment">              获取的flag和我们通过open函数传递的flag是一个东西。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">            - F_SETFL : 设置文件描述符文件状态flag</span><br><span class="hljs-comment">              必选项：O_RDONLY, O_WRONLY, O_RDWR 不可以被修改</span><br><span class="hljs-comment">              可选性：O_APPEND, O)NONBLOCK</span><br><span class="hljs-comment">                O_APPEND 表示追加数据</span><br><span class="hljs-comment">                NONBLOK 设置成非阻塞</span><br><span class="hljs-comment">        </span><br><span class="hljs-comment">        阻塞和非阻塞：描述的是函数调用的行为。</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><br>    <span class="hljs-comment">// 1.复制文件描述符</span><br>    <span class="hljs-comment">// int fd = open(&quot;1.txt&quot;, O_RDONLY);</span><br>    <span class="hljs-comment">// int ret = fcntl(fd, F_DUPFD);</span><br><br>    <span class="hljs-comment">// 2.修改或者获取文件状态flag</span><br>    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;1.txt&quot;</span>, O_RDWR);<br>    <span class="hljs-keyword">if</span>(fd == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;open&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取文件描述符状态flag</span><br>    <span class="hljs-type">int</span> flag = fcntl(fd, F_GETFL);<br>    <span class="hljs-keyword">if</span>(flag == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;fcntl&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    flag |= O_APPEND;   <span class="hljs-comment">// flag = flag | O_APPEND</span><br><br>    <span class="hljs-comment">// 修改文件描述符状态的flag，给flag加入O_APPEND这个标记。不能直接设置，不然会将原先的权限抹除。需要按位或。</span><br>    <span class="hljs-type">int</span> ret = fcntl(fd, F_SETFL, flag);<br>    <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;fcntl&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-type">char</span> * str = <span class="hljs-string">&quot;nihao&quot;</span>;<br>    write(fd, str, <span class="hljs-built_in">strlen</span>(str));<br><br>    close(fd);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="fcntl取代其他接口了吗"><a href="#fcntl取代其他接口了吗" class="headerlink" title="fcntl取代其他接口了吗"></a>fcntl取代其他接口了吗</h4><p>fcntl 函数并没有完全取代 dup 和 chmod 接口，它们之间的功能有所重叠，但仍然各有所长，可以根据需要选择使用。</p><p>对于 dup 接口，fcntl 提供了类似的功能，可以通过 F_DUPFD 命令来实现文件描述符的复制。与 dup 不同的是，fcntl 的 F_DUPFD 命令可以指定新的文件描述符的最小值。</p><p>对于 chmod 接口，fcntl 可以通过 F_SETFL 命令来修改文件描述符的访问模式。但是，fcntl 无法直接修改文件的权限，仍然需要使用 chmod 接口。</p><p>总的来说，fcntl 函数提供了更加细粒度的文件描述符和文件锁控制功能，可以实现一些比较复杂的操作，但对于一些简单的操作，如文件描述符的复制和文件权限的修改，还是可以使用 dup 和 chmod 接口</p>]]></content>
    
    
    <categories>
      
      <category>Linux编程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JSON解析器</title>
    <link href="/2023/02/27/json%E8%A7%A3%E6%9E%90%E5%99%A8/"/>
    <url>/2023/02/27/json%E8%A7%A3%E6%9E%90%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="测试驱动开发（test-driven-development-TDD）"><a href="#测试驱动开发（test-driven-development-TDD）" class="headerlink" title="测试驱动开发（test-driven development, TDD）"></a>测试驱动开发（test-driven development, TDD）</h2><ol><li>加入一个测试。</li><li>运行所有测试，新的测试应该会失败。</li><li>编写实现代码。</li><li>运行所有测试，若有测试失败回到3。</li><li>重构代码。</li><li>回到 1</li></ol><p>TDD 是先写测试，再实现功能。好处是实现只会刚好满足测试，而不会写了一些不需要的代码，或是没有被测试的代码。</p><h2 id="关于断言"><a href="#关于断言" class="headerlink" title="关于断言"></a>关于断言</h2><p>断言（assertion）是 C 语言中常用的防御式编程方式，减少编程错误。最常用的是在函数开始的地方，检测所有参数。有时候也可以在调用函数后，检查上下文是否正确。</p><p>C 语言的标准库含有 assert() 这个宏（需 #include ），提供断言功能。当程序以 release 配置编译时（定义了 NDEBUG 宏），assert() 不会做检测；而当在 debug 配置时（没定义 NDEBUG 宏），则会在运行时检测 assert(cond) 中的条件是否为真（非 0），断言失败会直接令程序崩溃。</p><h2 id="十进制转换至二进制"><a href="#十进制转换至二进制" class="headerlink" title="十进制转换至二进制"></a>十进制转换至二进制</h2><p>为了简单起见，leptjson 将使用标准库的<a href="https://link.zhihu.com/?target=http://en.cppreference.com/w/c/string/byte/strtof">strtod()</a> 来进行转换。strtod() 可转换 JSON 所要求的格式，但问题是，一些 JSON 不容许的格式，strtod() 也可转换，所以我们需要自行做格式校验。</p><h2 id="union"><a href="#union" class="headerlink" title="union"></a>union</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <span class="hljs-type">char</span>* s; <span class="hljs-type">size_t</span> len; &#125;s;  <span class="hljs-comment">/* string */</span><br>        <span class="hljs-type">double</span> n;                          <span class="hljs-comment">/* number */</span><br>    &#125;u;<br>    lept_type type;<br>&#125;lept_value;<br></code></pre></td></tr></table></figure><p>一个变量可以存储多个不同类型的数据，但是每次只能使用其中的一个，用 . 运算符进行访问。占用的内存空间为其中最大的那个变量的空间。</p><p>这样的设计可以节省内存。</p><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>解析、写入字符串的时候，要清理内存和动态分配内存。基于malloc、free、realloc等函数。</p><h3 id="realloc-void-mem-address-unsigned-int-newsize"><a href="#realloc-void-mem-address-unsigned-int-newsize" class="headerlink" title="realloc(void *mem_address, unsigned int newsize)"></a>realloc(void *mem_address, unsigned int newsize)</h3><p>realloc为已经分配好的内存进行重新分配，当后面的内存空间够用的时候，会返回原来的地址➕新扩展的部分。如果空间不过，就重新分配一个地址，将原内容拷贝过去，然后free掉原地址的内存空间。</p><h2 id="缓冲区和堆栈"><a href="#缓冲区和堆栈" class="headerlink" title="缓冲区和堆栈"></a>缓冲区和堆栈</h2><p>在解析字符串、数组、对象之后，需要将解析内容存储在临时的 <strong>缓冲区</strong>，最后使用wson_set_string()函数将缓冲区的内容设置进值中。在解析好一个字符串之前，缓冲区的大小是不能够预知的，所以使用 <strong>动态数组</strong> 这种数据结构，即使空间不够，也可以自动扩展。</p><p>如果每次解析都重新创建一个数组是比较浪费时间的，<strong>可以重用此数组</strong> ，每次解析JSON时只建立一个， <strong>先进后出</strong>的动态数组</p><p>综合以上，可知我们需要一个 <strong>动态堆栈结构</strong></p><h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><img src="截屏2023-02-27 21.32.41.png" alt="截屏2023-02-27 21.32.41" style="zoom: 33%;" /><h2 id="怎样检查内存泄漏"><a href="#怎样检查内存泄漏" class="headerlink" title="怎样检查内存泄漏"></a>怎样检查内存泄漏</h2><p>valgrind工具</p><p>用swap观察还有多少可用的交换空间，一分钟内键入多次，查看可用的交换区是否减少</p><h2 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h2><p>格式为<code>\uXXXX</code>，XXXX为16进制数。同时还定义了Uniform Transformation Format, UTF</p>]]></content>
    
    
    <categories>
      
      <category>C++项目</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>二叉树</title>
    <link href="/2022/09/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2022/09/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="二叉树的分类"><a href="#二叉树的分类" class="headerlink" title="二叉树的分类"></a>二叉树的分类</h2><h3 id="斜二叉树"><a href="#斜二叉树" class="headerlink" title="斜二叉树"></a>斜二叉树</h3><p>只有单侧的子树</p><h3 id="完美二叉树（满二叉树）"><a href="#完美二叉树（满二叉树）" class="headerlink" title="完美二叉树（满二叉树）"></a>完美二叉树（满二叉树）</h3><p>每一层都是满的。（根节点在第一层）</p><h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>每一层从左到右依次填满的二叉树。最后一层可以不满，但是所有节点的编号和完美二叉树是一样的。</p><h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p>有序树</p><ol><li>左子树的所有节点都小于根节点的值</li><li>右子树的所有节点都大于根节点的值</li><li>左右子树也是二叉搜索树</li></ol><h3 id="平衡二叉搜索树"><a href="#平衡二叉搜索树" class="headerlink" title="平衡二叉搜索树"></a>平衡二叉搜索树</h3><p>平衡二叉搜索树：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：</p><p>它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p><p><strong>C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树</strong>，所以map、set的增删操作时间时间复杂度是<strong>logn</strong></p><p>注意我这里没有说unordered_map、unordered_set，unordered_map、unordered_map底层实现是<strong>哈希表</strong>。</p><h2 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h2><ol><li><p>一个二叉树第<strong>i</strong>层的最大结点数为： $2^{i-1},i\geq1$</p></li><li><p>深度为<strong>k</strong>的二叉树的最大结点<strong>总数</strong>为：$2^k-1,k\geq1$</p></li><li><p>对任何非空二叉树T，若$n_0$表示叶结点的个数，$n_2$是度为2的非叶结点个数。两个满足关系 $n_0&#x3D;n_2+1$</p><p>下图中n0为4（d,j,k,h)，n2为3（a,b,e</p></li></ol><pre><code class=" mermaid">graph TD;A--&gt;B;A--&gt;C;B--&gt;D;B--&gt;E;E--&gt;J;E--&gt;K;C--&gt;F;F--&gt;H;</code></pre><h2 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h2><h3 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h3><p>完全二叉树，顺序存到数组里。<strong>在数组中：</strong></p><ol><li>序号为 i 的结点，其<strong>父结点</strong>序号为 <strong>i&#x2F;2</strong>，舍去小数！</li><li>序号为 i 的结点，其<strong>左</strong>孩子结点序号为 <strong>2i+1</strong></li><li>序号为 i 的结点，其<strong>右</strong>孩子结点序号为 <strong>2i+2</strong></li></ol><h3 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h3><p>用指针存储。</p><h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><h3 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h3><h4 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h4><ol><li>根节点</li><li>先序遍历左子树</li><li>先序遍历右子树</li></ol><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><ol><li>中序遍历左子树</li><li>根节点</li><li>中序遍历右子树</li></ol><h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><ol><li>后序遍历左子树</li><li>后序遍历右子树</li><li>根节点</li></ol><h2 id="二叉树的递归遍历"><a href="#二叉树的递归遍历" class="headerlink" title="二叉树的递归遍历"></a>二叉树的递归遍历</h2><h3 id="递归三要素"><a href="#递归三要素" class="headerlink" title="递归三要素"></a>递归三要素</h3><ol><li>确定递归的参数和返回值（范围）</li><li>确定终止条件</li><li>确定单层递归的逻辑</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">(大范围)</span></span>&#123;<br><span class="hljs-keyword">if</span>(终止条件)&#123;<br>处理终止条件<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-built_in">func</span>(小范围)<span class="hljs-comment">// 递去，递去的函数在没有到达终止的时候，会被一直调用。</span><br><span class="hljs-comment">// 下面的代码是函数递去到头后，开始返回时，要进行的处理</span><br>slove<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="自己的理解"><a href="#自己的理解" class="headerlink" title="自己的理解"></a>自己的理解</h3><p>递归要有来有回，递去是为了把问题简单化。但是一定要有终止条件。递归的数学模型是归纳法。我的终止条件，其实就是数学归纳法的n&#x3D;0的情况。数学归纳法是从0 –》N。递归是翻过来的，从N–&gt;0。</p><h3 id="代码：中序遍历"><a href="#代码：中序遍历" class="headerlink" title="代码：中序遍历"></a>代码：中序遍历</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt;result;<br>        <span class="hljs-built_in">traversal</span>(root,result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(<span class="hljs-type">const</span> TreeNode* <span class="hljs-type">const</span> cur,vector&lt;<span class="hljs-type">int</span>&gt;&amp; result)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(cur==<span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">traversal</span>(cur-&gt;left,result);<br>            result.<span class="hljs-built_in">emplace_back</span>(cur-&gt;val);<br>            <span class="hljs-built_in">traversal</span>(cur-&gt;right,result);    <br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="二叉树的迭代遍历"><a href="#二叉树的迭代遍历" class="headerlink" title="二叉树的迭代遍历"></a>二叉树的迭代遍历</h2><h3 id="前序遍历迭代"><a href="#前序遍历迭代" class="headerlink" title="前序遍历迭代"></a>前序遍历迭代</h3><ol><li>先放根节点到栈中</li><li>栈不空就开始循环<ol><li>保存栈顶元素，然后出栈</li><li>将栈顶元素放进结果数组中</li><li>如果右孩子不为空：右孩子进栈</li><li>如果左孩子不为空：左孩子进栈</li></ol></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt;result;<br>        stack&lt;TreeNode*&gt; st;<br>        <span class="hljs-keyword">if</span> (root==<span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        st.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>())&#123;<br>            TreeNode* node = st.<span class="hljs-built_in">top</span>();<br>            result.<span class="hljs-built_in">emplace_back</span>(node-&gt;val);<br>            st.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (node-&gt;right)&#123;<br>                st.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(node-&gt;left)&#123;<br>                st.<span class="hljs-built_in">push</span>(node-&gt;left);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="后序迭代遍历"><a href="#后序迭代遍历" class="headerlink" title="后序迭代遍历"></a>后序迭代遍历</h3><p>后序和前序的思路一样</p><p>前序的输出顺序是中左右 –》 更换左右孩子节点进站顺序–〉输出中右左 –》将结果数组逆序 –〉左右中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt;result;<br>        stack&lt;TreeNode*&gt;st;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> result;<br>        st.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>())&#123;<br>            TreeNode* node = st.<span class="hljs-built_in">top</span>();<br>            st.<span class="hljs-built_in">pop</span>();<br>            result.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>            <span class="hljs-keyword">if</span> (node-&gt;left) st.<span class="hljs-built_in">push</span>(node-&gt;left); <span class="hljs-comment">// 相对于前序遍历，这更改一下入栈顺序 （空节点不入栈）</span><br>            <span class="hljs-keyword">if</span> (node-&gt;right) st.<span class="hljs-built_in">push</span>(node-&gt;right); <span class="hljs-comment">// 空节点不入栈</span><br>        &#125;<br>        <span class="hljs-built_in">reverse</span>(result.<span class="hljs-built_in">begin</span>(), result.<span class="hljs-built_in">end</span>()); <br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="中序迭代遍历"><a href="#中序迭代遍历" class="headerlink" title="中序迭代遍历"></a>中序迭代遍历</h3><p>中序遍历的思路是，遇到cur的节点不为空，就入栈，<strong>然后</strong>将cur赋为其左孩子，一路向左。直到cur的左孩子为空。</p><p>这个时候，就应该处理栈中的元素了。将栈中的元素弹出来，此时它应该是最左边的节点，然后放入结果队列。然后将cur赋为其右孩子。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        stack&lt;TreeNode*&gt; st;<br>        TreeNode* cur = root;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">NULL</span> || !st.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">if</span> (cur != <span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">// 指针来访问节点，访问到最底层</span><br>                st.<span class="hljs-built_in">push</span>(cur); <span class="hljs-comment">// 将访问的节点放进栈</span><br>                cur = cur-&gt;left;                <span class="hljs-comment">// 左</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur = st.<span class="hljs-built_in">top</span>(); <span class="hljs-comment">// 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据）</span><br>                st.<span class="hljs-built_in">pop</span>();<br>                result.<span class="hljs-built_in">push_back</span>(cur-&gt;val);     <span class="hljs-comment">// 中</span><br>                cur = cur-&gt;right;               <span class="hljs-comment">// 右</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="层序遍历（广度优先遍历）"><a href="#层序遍历（广度优先遍历）" class="headerlink" title="层序遍历（广度优先遍历）"></a>层序遍历（广度优先遍历）</h3><p>使用队列这种先进先出的结构作辅助。</p><p>每遍历一层，都要把队列里的所有节点的左右孩子都进队，然后其出队。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; result;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        queue&lt;TreeNode*&gt; que;<br>        que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>())&#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; layer;<br>            <span class="hljs-keyword">auto</span> layer_size=que.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i=<span class="hljs-number">0</span>;i&lt;layer_size;i++)&#123;<br>                <span class="hljs-keyword">auto</span> cur = que.<span class="hljs-built_in">front</span>();<br>                layer.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>                que.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(cur-&gt;left!=<span class="hljs-literal">nullptr</span>)<br>                    que.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                <span class="hljs-keyword">if</span>(cur-&gt;right!=<span class="hljs-literal">nullptr</span>)<br>                    que.<span class="hljs-built_in">push</span>(cur-&gt;right); <br>            &#125;<br>            result.<span class="hljs-built_in">push_back</span>(layer);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>栈和队列</title>
    <link href="/2022/09/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <url>/2022/09/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h1><h2 id="栈的原理"><a href="#栈的原理" class="headerlink" title="栈的原理"></a>栈的原理</h2><p>先进后出，不提供走访和迭代器。栈是一个适配器，它底层靠vector、deque、list等来实现。默认使用deque来实现。</p><hr><h2 id="LC-232-用栈实现队列"><a href="#LC-232-用栈实现队列" class="headerlink" title="LC-232 用栈实现队列"></a>LC-232 用栈实现队列</h2><p>队列是先进先出，队头删除元素，队尾插入元素</p><p>用两个栈，一个是in，一个是out。</p><p>队列pop元素的时候，就从out中pop。如果out栈为空，就将in的元素全部倒入out中。</p><p>队列push元素时，就往in里push就好。</p><p>队列top元素时，调用pop，然后把pop的值再放回out中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyQueue</span>()<br>    &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        in.<span class="hljs-built_in">push</span>(x);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (out.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-keyword">while</span> (!in.<span class="hljs-built_in">empty</span>())<br>            &#123;<br>                out.<span class="hljs-built_in">push</span>(in.<span class="hljs-built_in">top</span>());<br>                in.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> result = out.<span class="hljs-built_in">top</span>();<br>        out.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> temp = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">pop</span>();<br>        out.<span class="hljs-built_in">push</span>(temp);<br>        <span class="hljs-keyword">return</span> temp;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> in.<span class="hljs-built_in">empty</span>() &amp;&amp; out.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>    <span class="hljs-keyword">private</span>:<br>        stack&lt;<span class="hljs-type">int</span>&gt; in;<br>        stack&lt;<span class="hljs-type">int</span>&gt; out;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="LC-225-用队列实现栈"><a href="#LC-225-用队列实现栈" class="headerlink" title="LC-225 用队列实现栈"></a>LC-225 用队列实现栈</h2><p>搞个大回旋，pop的时候，把队列头的元素放入队列尾中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStack</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyStack</span>() &#123;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        que.<span class="hljs-built_in">push</span>(x);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> result = que.<span class="hljs-built_in">back</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; que.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i++)<br>        &#123;<br>            que.<span class="hljs-built_in">push</span>(que.<span class="hljs-built_in">front</span>());<br>            que.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        que.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> que.<span class="hljs-built_in">back</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> que.<span class="hljs-built_in">empty</span>();<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    queue&lt;<span class="hljs-type">int</span>&gt; que;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="LC-20-有效的括号"><a href="#LC-20-有效的括号" class="headerlink" title="LC-20 有效的括号"></a>LC-20 有效的括号</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">size_t</span> length = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (length % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 如果s的长度为奇数，一定不符合要求</span><br>        stack&lt;<span class="hljs-type">char</span>&gt; ST;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; length; i++)<br>        &#123;<br>            <span class="hljs-keyword">switch</span> (s[i])<br>            &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&#123;&#x27;</span>:<br>                ST.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;&#125;&#x27;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;(&#x27;</span>:<br>                ST.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;)&#x27;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;[&#x27;</span>:<br>                ST.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;]&#x27;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">if</span> (ST.<span class="hljs-built_in">empty</span>() || ST.<span class="hljs-built_in">top</span>() != s[i])<br>                &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    ST.<span class="hljs-built_in">pop</span>();<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ST.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="LC-1047-删除字符串中的所有相邻重复项"><a href="#LC-1047-删除字符串中的所有相邻重复项" class="headerlink" title="LC-1047 删除字符串中的所有相邻重复项"></a>LC-1047 删除字符串中的所有相邻重复项</h2><p>这个是错误的代码，没完成要求。这个是把所有相邻的重复元素全部删除掉</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> s;<br>        stack&lt;<span class="hljs-type">char</span>&gt; st;<br>        <span class="hljs-type">int</span> repet = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>();i++)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(repet)&#123;<br>                st.<span class="hljs-built_in">pop</span>();<br>                repet--;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(s[i]!=st.<span class="hljs-built_in">top</span>())&#123;<br>                st.<span class="hljs-built_in">push</span>(s[i]);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">while</span>(s[i]==st.<span class="hljs-built_in">top</span>())&#123;<br>                    st.<span class="hljs-built_in">push</span>(s[i++]);<br>                    repet++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        string result=<span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            result = st.<span class="hljs-built_in">top</span>() + result;<br>            st.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>()&lt;<span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">return</span> s;<br>        &#125;<br>        stack&lt;<span class="hljs-type">char</span>&gt; st;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> c:s)&#123;<br>            <span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">empty</span>())&#123;<br>                st.<span class="hljs-built_in">push</span>(c);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(c == st.<span class="hljs-built_in">top</span>())&#123;<br>                st.<span class="hljs-built_in">pop</span>();<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                st.<span class="hljs-built_in">push</span>(c);<br>            &#125;<br>        &#125;<br>        string result = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            result += st.<span class="hljs-built_in">top</span>();<br>            st.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-built_in">reverse</span>(result.<span class="hljs-built_in">begin</span>(), result.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="LC-150-逆波兰表达式求值"><a href="#LC-150-逆波兰表达式求值" class="headerlink" title="LC-150 逆波兰表达式求值"></a>LC-150 逆波兰表达式求值</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>string的stoi()函数可以把字符串格式转换为整形格式</p><p>数字用long 代替int</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">evalRPN</span><span class="hljs-params">(vector&lt;string&gt; &amp;tokens)</span></span><br><span class="hljs-function">    </span>&#123;<br>        stack&lt;<span class="hljs-type">long</span>&gt; st;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> s : tokens)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(s==<span class="hljs-string">&quot;+&quot;</span> || s==<span class="hljs-string">&quot;-&quot;</span>||s==<span class="hljs-string">&quot;/&quot;</span>||s==<span class="hljs-string">&quot;*&quot;</span>)&#123;<br>                <span class="hljs-type">long</span> num1 = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-type">long</span> num2 = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (s == <span class="hljs-string">&quot;+&quot;</span>)<br>                &#123;<br>                    st.<span class="hljs-built_in">push</span>(num2 + num1);<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s == <span class="hljs-string">&quot;-&quot;</span>)<br>                &#123;<br>                    st.<span class="hljs-built_in">push</span>(num2 - num1);<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s == <span class="hljs-string">&quot;*&quot;</span>)<br>                &#123;<br>                    st.<span class="hljs-built_in">push</span>(num2 * num1);<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s == <span class="hljs-string">&quot;/&quot;</span>)<br>                &#123;<br>                    st.<span class="hljs-built_in">push</span>(num2 / num1);<br>                &#125;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                cout &lt;&lt; s &lt;&lt; endl;<br>                st.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">stoi</span>(s));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> st.<span class="hljs-built_in">top</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="LC-239-滑动窗口的最单调队列"><a href="#LC-239-滑动窗口的最单调队列" class="headerlink" title="LC-239 滑动窗口的最单调队列"></a>LC-239 滑动窗口的最单调队列</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>实现一个单调队列。这个单调队列只拿来维护可能成为最大值的数。</li><li>把最大值放到队伍的头处，getmax的时候就直接访问队伍的头。</li><li>自己定义的队列使用deque作为底层。</li><li>push值的时候，要从队伍的尾端进行push。push时，要从队伍的尾端，把所有小于待入队值的值从尾部扔出去。</li></ol><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function">    </span>&#123;<br>        Que que;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> start = nums.<span class="hljs-built_in">begin</span>(),end=nums.<span class="hljs-built_in">begin</span>(); end != nums.<span class="hljs-built_in">end</span>(); ++end)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (end-start==k)&#123;<br>                result.<span class="hljs-built_in">push_back</span>(que.<span class="hljs-built_in">get_max_value</span>());<br>                que.<span class="hljs-built_in">pop</span>(*start);<br>                ++start;<br>            &#125;<br>            que.<span class="hljs-built_in">push</span>(*end);<br>        &#125;<br>        <span class="hljs-comment">// 补最后一个窗口的最大值进来</span><br>        result.<span class="hljs-built_in">push_back</span>(que.<span class="hljs-built_in">get_max_value</span>());<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Que</span><br>    &#123;<br>    <span class="hljs-keyword">private</span>:<br>        deque&lt;<span class="hljs-type">int</span>&gt; deq;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Que</span>() = <span class="hljs-keyword">default</span>;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_max_value</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">if</span> (!deq.<span class="hljs-built_in">empty</span>())<br>            &#123;<br>                <span class="hljs-keyword">return</span> deq.<span class="hljs-built_in">front</span>();<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-100001</span>;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">if</span> (!deq.<span class="hljs-built_in">empty</span>() &amp;&amp; x == <span class="hljs-built_in">get_max_value</span>())<br>            &#123;<br>                deq.<span class="hljs-built_in">pop_front</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">while</span> (deq.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span> &amp;&amp; x &gt; deq.<span class="hljs-built_in">back</span>())<br>            &#123;<br>                deq.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>            deq.<span class="hljs-built_in">push_back</span>(x);<br>        &#125;<br>    &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="LC-347-前K个高频元素"><a href="#LC-347-前K个高频元素" class="headerlink" title="LC-347 前K个高频元素"></a>LC-347 前K个高频元素</h2><h3 id="方法一：O-NlogN"><a href="#方法一：O-NlogN" class="headerlink" title="方法一：O(NlogN)"></a>方法一：O(NlogN)</h3><p>使用标准库的sort算法和哈希表。没啥可说的。注意下，map没有排序算法，需要构建一个pair的vector，然后传一个自定义的sort算法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">topKFrequent</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>    map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> num : nums) &#123;<br>      m[num]++;<br>    &#125;<br>    vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">vec</span>(m.<span class="hljs-built_in">begin</span>(),m.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(),<br>         [](<span class="hljs-keyword">auto</span> a, <span class="hljs-keyword">auto</span> b) &#123; <span class="hljs-keyword">return</span> a.second &gt; b.second; &#125;);<br>  vector&lt;<span class="hljs-type">int</span>&gt; res;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) <br>  &#123;<br>    res.<span class="hljs-built_in">push_back</span>(vec[i].first);<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="方法二：优先级队列"><a href="#方法二：优先级队列" class="headerlink" title="方法二：优先级队列"></a>方法二：优先级队列</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-comment">// 时间复杂度：O(nlogk)</span><br><span class="hljs-comment">// 空间复杂度：O(n)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 小顶堆</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">mycomparison</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; lhs, <span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; rhs)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> lhs.second &gt; rhs.second;<br>        &#125;<br>    &#125;;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">topKFrequent</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">// 要统计元素出现频率</span><br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; map; <span class="hljs-comment">// map&lt;nums[i],对应出现的次数&gt;</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            map[nums[i]]++;<br>        &#125;<br>        <span class="hljs-comment">// 对频率排序</span><br>        <span class="hljs-comment">// 定义一个小顶堆，大小为k</span><br>        priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, mycomparison&gt; pri_que;<br>        <span class="hljs-comment">// 用固定大小为k的小顶堆，扫面所有频率的数值</span><br>        <span class="hljs-keyword">for</span> (unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;::iterator it = map.<span class="hljs-built_in">begin</span>(); it != map.<span class="hljs-built_in">end</span>(); it++) &#123;<br>            pri_que.<span class="hljs-built_in">push</span>(*it);<br>            <span class="hljs-keyword">if</span> (pri_que.<span class="hljs-built_in">size</span>() &gt; k) &#123; <span class="hljs-comment">// 如果堆的大小大于了K，则队列弹出，保证堆的大小一直为k</span><br>                pri_que.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 找出前K个高频元素，因为小顶堆先弹出的是最小的，所以倒序来输出到数组</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(k)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = k - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            result[i] = pri_que.<span class="hljs-built_in">top</span>().first;<br>            pri_que.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>字符串</title>
    <link href="/2022/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2022/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="LC-344-反转字符串"><a href="#LC-344-反转字符串" class="headerlink" title="LC-344 反转字符串"></a>LC-344 反转字符串</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>双指针。一个指向头，一个指向尾。</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverseString</span><span class="hljs-params">(vector&lt;<span class="hljs-type">char</span>&gt;&amp; s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(len==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,r=s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>            <span class="hljs-type">char</span> tmep = s[l];<br>            s[l] = s[r];<br>            s[r] = tmep;<br>            l++,r--;<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="LC-541-翻转字符串2⃣️"><a href="#LC-541-翻转字符串2⃣️" class="headerlink" title="LC-541 翻转字符串2⃣️"></a>LC-541 翻转字符串2⃣️</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><h4 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h4><p>因为题中要求三种情况，所以我就分成了三种情况分别进行处理。在对2k取余数后，根据余数的大小进行分类。</p><p>翻转的操作，是通过size&#x2F;2k得到loop值，这个值代表着，数组可以分为loop个部分，每个部分都进行一次一半的翻转</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">reverseStr</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">//2k的整数倍</span><br>        <span class="hljs-comment">// n*2k+0.9k</span><br>        <span class="hljs-comment">//n2k+1.9k</span><br>        <span class="hljs-type">int</span> size = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> loop = size/(<span class="hljs-number">2</span>*k);<br>        <span class="hljs-type">int</span> temp = loop;<br>        string res = s;<br>        <span class="hljs-keyword">while</span>(loop)&#123;<br>            <span class="hljs-built_in">rev</span>(res, (loop<span class="hljs-number">-1</span>)*<span class="hljs-number">2</span>*k,(<span class="hljs-number">2</span>*loop<span class="hljs-number">-1</span>)*k);<br>            loop--;<br>        &#125;<br>        <span class="hljs-type">int</span> last = size%(<span class="hljs-number">2</span>*k);<br>        <span class="hljs-keyword">if</span>(last&gt;<span class="hljs-number">0</span> &amp;&amp; last&lt;k)&#123;<br>            <span class="hljs-built_in">rev</span>(res,temp*<span class="hljs-number">2</span>*k,size);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(last&gt;=k &amp;&amp; last&lt;<span class="hljs-number">2</span>*k)&#123;<br>            <span class="hljs-built_in">rev</span>(res,temp*<span class="hljs-number">2</span>*k,temp*<span class="hljs-number">2</span>*k+k);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rev</span><span class="hljs-params">(string &amp;s,<span class="hljs-type">int</span> start,<span class="hljs-type">int</span> e)</span></span>&#123;<br>        <span class="hljs-type">int</span> len = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(len==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-type">int</span> l=start,r=e<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>            <span class="hljs-built_in">swap</span>(s[l],s[r]);<br>            l++,r--;<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="剑指Offer-05-替换空格"><a href="#剑指Offer-05-替换空格" class="headerlink" title="剑指Offer-05 替换空格"></a>剑指Offer-05 替换空格</h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>题目要求时间复杂度为O(N),空间复杂度为O(1).</p><ol><li>先遍历字符串，记录空格个数，然后根据空格个数扩容字符串</li><li><strong>从后向前遍历</strong>字符串，双指针。</li><li>慢指针指向扩容后的尾部，快指针指向原字符串的尾部，然后向前推进，快指针将指向的内容放到慢指针处。遇到空格，就写入”%20”.</li></ol><p><strong>很多数组填充类的问题，都可以预先给数组扩容到填充后的大小，然后从后往前进行操作</strong></p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">replaceSpace</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> begin = s.<span class="hljs-built_in">begin</span>();<br>        <span class="hljs-keyword">auto</span> end = s.<span class="hljs-built_in">end</span>();<br>        <span class="hljs-type">int</span> countZ=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(begin!=end)&#123;<br>            <span class="hljs-keyword">if</span>(*begin == <span class="hljs-string">&#x27; &#x27;</span>)<br>            &#123;++countZ;&#125;<br>            ++begin;<br>        &#125;<br>        <span class="hljs-comment">//指向原字符串末尾</span><br>        <span class="hljs-type">int</span> fast = s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-comment">// 扩容后的size</span><br>        <span class="hljs-type">int</span> size = fast+<span class="hljs-number">1</span>+countZ*<span class="hljs-number">2</span>;<br>        s.<span class="hljs-built_in">resize</span>(size);<br><br>        <span class="hljs-comment">// 开始替换字符串</span><br>        <span class="hljs-type">int</span> slow = size<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(;fast&gt;=<span class="hljs-number">0</span>;fast--)&#123;<br>            <span class="hljs-keyword">if</span>(s[fast]==<span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>                s[slow--] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>                s[slow--] =<span class="hljs-string">&#x27;2&#x27;</span>;<br>                s[slow--] = <span class="hljs-string">&#x27;%&#x27;</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                s[slow--] = s[fast];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="LC-151-翻转字符串里的单词"><a href="#LC-151-翻转字符串里的单词" class="headerlink" title="LC-151 翻转字符串里的单词"></a>LC-151 翻转字符串里的单词</h2><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ol><li><p>我是真的不会做</p></li><li><p>将这个题分成三个部分</p><ol><li><strong>去除多余空格</strong></li><li>翻转整个字符串</li><li>翻转单词</li></ol></li><li><p>去除空格的做法是我根本不会的</p><p>思路和去除数组中的某个元素类似，要使用双指针。但是要注意的点是： <strong>每个单词可以看做单词➕一个空格</strong>。fast指针向右遍历的时候，如果遇到非空格元素，说明碰到一个单词；如果遇到空格，说明这个单词结束了，然后fast继续向后寻找单词。</p><p>所以，我们需要在fast遍历的循环里面，增加一个移动单词的循环。这个循环的终止条件和外面的循环一样。</p><p>大概的流程是，slow指向新字符串的结尾，fast在外层循环的作用下一直往右，遇到空格就跳过，遇到非空格，开始执行写单词的循环，然后fast继续遍历。在循环过程中，要手动补写每个单词后面的空格，从第二次交换单词开始，前一个单词后面补一个空格，slow指向空格后的位置。</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">reverseWords</span><span class="hljs-params">(string s)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 1 去掉多余的空格</span><br>        <span class="hljs-type">int</span> len = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-built_in">removeExtraSpaces</span>(s, len);<br>        <span class="hljs-comment">// 2 翻转字符串</span><br>        len = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-built_in">reverseLine</span>(s, len);<br>        <span class="hljs-comment">// 3 翻转每个单词</span><br>        <span class="hljs-type">int</span> cur = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (cur &lt; len)<br>        &#123;<br>            <span class="hljs-type">int</span> l = cur, r = cur;<br>            <span class="hljs-keyword">while</span> (s[r] != <span class="hljs-string">&#x27; &#x27;</span>&amp;&amp;r&lt;len)<br>            &#123;<br>                r++;<br>            &#125;<br>            cur = r+<span class="hljs-number">1</span>;<br>            r -= <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (l &lt; r)<br>            &#123;<br>                <span class="hljs-type">char</span> t = s[l];<br>                s[l++] = s[r];<br>                s[r--] = t;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeExtraSpaces</span><span class="hljs-params">(string &amp;s, <span class="hljs-type">int</span> len)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> fast = <span class="hljs-number">0</span>, slow = <span class="hljs-number">0</span>;<br>      <span class="hljs-comment">// fast开始遍历</span><br>        <span class="hljs-keyword">for</span> (; fast &lt; len; fast++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (s[fast] != <span class="hljs-string">&#x27; &#x27;</span>)<br>            &#123;<br>             <span class="hljs-comment">//从第一个交换好的单词后开始，添加空格</span><br>                <span class="hljs-keyword">if</span> (slow != <span class="hljs-number">0</span>)<br>                &#123;<br>                    s[slow++] = <span class="hljs-string">&#x27; &#x27;</span>;<br>                &#125;<br>              <span class="hljs-comment">// 当找到一个单词后，在该循环中，完成s写单词的任务</span><br>                <span class="hljs-keyword">while</span> (fast &lt; len &amp;&amp; s[fast] != <span class="hljs-string">&#x27; &#x27;</span>)<br>                &#123;<br>                    s[slow++] = s[fast++];<br>                &#125;<br>            &#125;<br>        &#125;<br>        s.<span class="hljs-built_in">resize</span>(slow);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverseLine</span><span class="hljs-params">(string &amp;s, <span class="hljs-type">int</span> len)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = len - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt; r)<br>        &#123;<br>            <span class="hljs-type">char</span> t = s[l];<br>            s[l++] = s[r];<br>            s[r--] = t;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="剑指Offer-58-2⃣️-左旋字符串"><a href="#剑指Offer-58-2⃣️-左旋字符串" class="headerlink" title="剑指Offer 58-2⃣️ 左旋字符串"></a>剑指Offer 58-2⃣️ 左旋字符串</h2><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">reverseLeftWords</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-built_in">reverse</span>(s,<span class="hljs-number">0</span>,len<span class="hljs-number">-1</span>);<br>        <span class="hljs-built_in">reverse</span>(s,<span class="hljs-number">0</span>,len<span class="hljs-number">-1</span>-n);<br>        <span class="hljs-built_in">reverse</span>(s,len-n,len<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(string &amp;s,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>        <span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>            <span class="hljs-type">char</span> t = s[l];<br>            s[l++] = s[r];<br>            s[r--] = t;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>主要用于 <strong>字符串匹配</strong>，当字符串不匹配时，可以知道一部分之前已经匹配的内容，不用从头匹配了。</p><h2 id="前缀表-next"><a href="#前缀表-next" class="headerlink" title="前缀表 next[]"></a>前缀表 next[]</h2><p>前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。</p><p>记录的内容是： 最长相同前后缀的长度</p><h3 id="怎么实现next"><a href="#怎么实现next" class="headerlink" title="怎么实现next[]"></a>怎么实现next[]</h3><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><ol><li><p>新建一个<code>void getNext(int*next,const string&amp; text)</code></p></li><li><p>初始化指针j&#x3D;0，i&#x3D;1,next[0] &#x3D; 0</p><ol><li>j:指向前缀</li><li>i：指向后缀</li><li>next[0]&#x3D; 0，第一个子串只有一个字符，所以没有相同前后缀</li></ol></li><li><p>然后后缀i开始从1到末尾进行遍历</p><ol><li><p>当text[j]!&#x3D;text[i]的时候，就要进行j的回退，j的值要变成next[j-1]的值。告诉j回退到上一个相同的地方，这是个连续的回退！（while）当退到j&#x3D;0的时候，退出while循环。</p></li><li><p>当text[j] &#x3D;&#x3D; text[i]的时候，j++，</p></li><li><p>然后将next[i] &#x3D; j</p></li></ol></li></ol><h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getNext</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp;next,<span class="hljs-type">const</span> string&amp; text)</span></span>&#123;<br>    <span class="hljs-type">size_t</span> j = <span class="hljs-number">0</span>, i = <span class="hljs-number">1</span>;<br>    next[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (; i &lt; text.<span class="hljs-built_in">size</span>();i++)&#123;<br>        <span class="hljs-keyword">while</span> (j&gt;<span class="hljs-number">0</span>&amp;&amp;text[j]!=text[i])<br>        &#123;<br>            j = next[j - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">if</span>(text[j]==text[i])&#123;<br>            ++j;<br>        &#125;<br>        next[i] = j;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string text = <span class="hljs-string">&quot;aabaaf&quot;</span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">next</span><span class="hljs-params">(text.size())</span></span>;<br>    <span class="hljs-built_in">getNext</span>(next, text);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c:text)<br>    &#123;cout &lt;&lt; c &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;&#125;<br>    cout &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : next)<br>    &#123;cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;&#125;<br>    cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LC-28-找出字符串中第一个匹配项的下标"><a href="#LC-28-找出字符串中第一个匹配项的下标" class="headerlink" title="LC-28 找出字符串中第一个匹配项的下标"></a>LC-28 找出字符串中第一个匹配项的下标</h2><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>KMP的实践，先拿到一个next表。然后两个指针i，j分别指向文本串和模式串，从0开始进行比较。不相等的时候，在while中回退。</p><p>相等的时候，就j++。 当j遍历完模式串的时候，说明找到了匹配的对象，通过和i j 的差，返回出现的下标</p><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">strStr</span><span class="hljs-params">(string haystack, string needle)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> len = needle.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">next</span><span class="hljs-params">(len)</span></span>;<br>        <span class="hljs-built_in">getNext</span>(next, needle);<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (; i &lt; haystack.<span class="hljs-built_in">size</span>() &amp;&amp; j &lt; len; i++)<br>        &#123;<br>            <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; needle[j] != haystack[i])<br>            &#123;<br>                j = next[j - <span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (haystack[i] == needle[j])<br>            &#123;<br>                j++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (j == len)<br>            &#123;<br>                <span class="hljs-keyword">return</span> i - j+<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getNext</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;next, <span class="hljs-type">const</span> string &amp;text)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">size_t</span> j = <span class="hljs-number">0</span>, i = <span class="hljs-number">1</span>;<br>        next[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (; i &lt; text.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; text[j] != text[i])<br>            &#123;<br>                j = next[j - <span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (text[j] == text[i])<br>            &#123;<br>                ++j;<br>            &#125;<br>            next[i] = j;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="LC-459"><a href="#LC-459" class="headerlink" title="LC-459"></a>LC-459</h2><h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><p>给定一个非空的字符串 <code>s</code> ，检查是否可以通过由它的一个子串重复多次构成。</p><ol><li>KMP算法</li><li>相等最长前缀和相等最长后缀都不包含的子串，就是最小重复单位。</li><li>next数组中最后一个元素，如果不是0，则代表该串有最长相等前后缀。</li><li>用长度剪去该值，就得到了最小重复单元的长度。看看其能不能被字符串长度所整除。</li></ol><h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getNext</span><span class="hljs-params">(<span class="hljs-type">int</span> *next, <span class="hljs-type">const</span> string &amp;t)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>, i = <span class="hljs-number">1</span>;<br>    next[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (; i &lt; t.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; t[i] != t[j])<br>        &#123;<br>            j = next[j - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (t[i] == t[j])<br>        &#123;<br>            j++;<br>        &#125;<br>        next[i] = j;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">repeatedSubstringPattern</span><span class="hljs-params">(string s)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> len = s.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">int</span> next[len];<br>    <span class="hljs-built_in">getNext</span>(next, s);<br>    cout&lt;&lt;<span class="hljs-string">&quot;next数组为：&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> t : next)<br>    &#123;<br>        cout &lt;&lt; t &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-comment">// if(next[len-1]!=0;)</span><br>    <span class="hljs-keyword">if</span> (next[len - <span class="hljs-number">1</span>] != <span class="hljs-number">0</span> &amp;&amp; len % (len - next[len - <span class="hljs-number">1</span>]) == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>哈希表</title>
    <link href="/2022/09/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    <url>/2022/09/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><h2 id="LC-242-有效的字母异位词"><a href="#LC-242-有效的字母异位词" class="headerlink" title="LC-242 有效的字母异位词"></a>LC-242 有效的字母异位词</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>建立一个表，记录字母和出现的次数。循环两次，第一次记录s的字母和出现次数；第二次循环，用t的字母和出现次数去和第一次的结果相减</li><li>然后遍历这个结果map，map中如果有次数不为零，则说明不是异位词</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isAnagram</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; a;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> c:s)&#123;<br>           a[c]++; <br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> c:t)&#123;<br>            a[c]--;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> p:a)&#123;<br>            <span class="hljs-keyword">if</span>(p.second!=<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="LC-349-两个数组的交集"><a href="#LC-349-两个数组的交集" class="headerlink" title="LC-349 两个数组的交集"></a>LC-349 两个数组的交集</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>C++中的 std::unordered_set是用哈希表作为底层实现的</li><li>读写效率非常高</li><li>但是数据是没有排序的</li></ol><h2 id="LC-202-快乐数"><a href="#LC-202-快乐数" class="headerlink" title="LC-202 快乐数"></a>LC-202 快乐数</h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>关键是快乐数的确认条件是<strong>无限循环</strong>，怎么才能判定呢？</li><li>无限循环的话，判定值一定会重复出现的。</li><li>每个位上的数相加：除10取余数，得到位。然后除10，得到下一个要取余数的数字。</li></ol><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isHappy</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; sumSet;<br>        <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>,x=n;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">while</span>(x)&#123;<br>                sum+=<span class="hljs-built_in">pow</span>(x%<span class="hljs-number">10</span>,<span class="hljs-number">2</span>);<br>                x = x/<span class="hljs-number">10</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(sum==<span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sumSet.<span class="hljs-built_in">find</span>(sum)!=sumSet.<span class="hljs-built_in">end</span>())&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                sumSet.<span class="hljs-built_in">insert</span>(sum);<br>                x=sum;<br>                sum=<span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="LC-1-两数之和"><a href="#LC-1-两数之和" class="headerlink" title="LC-1 两数之和"></a>LC-1 两数之和</h2><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ol><li>哈希表法 –》 unordered_map</li><li>哈希表存的是{元素，下标}</li><li>每次在表中查询当前数组元素和target的差值</li></ol><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        std::unordered_map &lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; map;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-comment">// 遍历当前元素，并在map中寻找是否有匹配的key</span><br>            <span class="hljs-keyword">auto</span> iter = map.<span class="hljs-built_in">find</span>(target - nums[i]); <br>            <span class="hljs-keyword">if</span>(iter != map.<span class="hljs-built_in">end</span>()) &#123;<br>                <span class="hljs-keyword">return</span> &#123;iter-&gt;second, i&#125;;<br>            &#125;<br>            <span class="hljs-comment">// 如果没找到匹配对，就把访问过的元素和下标加入到map中</span><br>            map.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(nums[i], i)); <br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="LC-454-四数相加"><a href="#LC-454-四数相加" class="headerlink" title="LC-454 四数相加"></a>LC-454 四数相加</h2><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><ol><li>肯定不能写一个 $O(n^4)$</li><li>前两个数组双层循环求出来和，放入map中，map存和的值，和和出现的次数</li><li>后两个数组双层循环求和，在map中find -和，找得的话就将count+&#x3D;和出现的次数</li></ol><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fourSumCount</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums3, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums4)</span> </span>&#123;<br>        <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>        unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> a:nums1)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> b:nums2)&#123;<br>                res[a+b]++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> c:nums3)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> d:nums4)&#123;<br>                <span class="hljs-keyword">auto</span> x = res.<span class="hljs-built_in">find</span>(-(c+d));<br>                <span class="hljs-keyword">if</span>(x!=res.<span class="hljs-built_in">end</span>())&#123;<br>                    count+=x-&gt;second;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="LC-383-赎金信"><a href="#LC-383-赎金信" class="headerlink" title="LC-383 赎金信"></a>LC-383 赎金信</h2><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canConstruct</span><span class="hljs-params">(string ransomNote, string magazine)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">unsigned</span>&gt; m;<br>        <span class="hljs-keyword">if</span>(magazine.<span class="hljs-built_in">size</span>()&lt;ransomNote.<span class="hljs-built_in">size</span>())<br>        &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> c: magazine)&#123;<br>            m[c]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> c:ransomNote)&#123;<br>            <span class="hljs-keyword">if</span>(m.<span class="hljs-built_in">find</span>(c)!=m.<span class="hljs-built_in">end</span>()&amp;&amp;m.<span class="hljs-built_in">find</span>(c)-&gt;second!=<span class="hljs-number">0</span>)&#123;<br>                m[c]--;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="LC-15-三数之和"><a href="#LC-15-三数之和" class="headerlink" title="LC-15 三数之和"></a>LC-15 三数之和</h2><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><ol><li>因为不要求返回索引，所以可以对原数组进行排序</li><li>设置三个指针<ol><li>一个指针 i，用来遍历数组</li><li>第二个指针left，在i的后面</li><li>第三个指针right，在数组的最末尾</li></ol></li><li>三个指针开始相加，因为数组是排好序的，所以left越往后，指向的值越大，三个数之和就越大。同理，right越往左，和越小。</li></ol><h4 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h4><p><strong>在题目中，要求返回和为零的元素值，不能有重复的元素值组合</strong></p><p>这就要求我们进行去掉重复值的操作。要针对每个指针进行去重的操作。</p><ol><li>i ： 这个指针从数组的最前方开始往后遍历。它能出现的重复情况是，它前面的数字和它一样。 <ol><li>如果和后面的比较，那么元组内的重复元素就被过掉了，例如{-1,-1,2}</li></ol></li><li>left ： 这个是它后面的数字和他一样</li><li>right ： 它前面的数字和他一样</li></ol><p><strong>去重复的位置</strong></p><p>对于left和right来说，应该在找到一组元素后进行去重复。否则就会漏掉left和right都是0的情况。</p><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-comment">// 找出a + b + c = 0</span><br>        <span class="hljs-comment">// a = nums[i], b = nums[left], c = nums[right]</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-comment">// 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了</span><br>            <span class="hljs-keyword">if</span> (nums[i] &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> result;<br>            &#125;<br>            <span class="hljs-comment">// 错误去重a方法，将会漏掉-1,-1,2 这种情况</span><br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">            if (nums[i] == nums[i + 1]) &#123;</span><br><span class="hljs-comment">                continue;</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">            */</span><br>            <span class="hljs-comment">// 正确去重a方法</span><br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-type">int</span> left = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (right &gt; left) &#123;<br>                <span class="hljs-comment">// 去重复逻辑如果放在这里，0，0，0 的情况，可能直接导致 right&lt;=left 了，从而漏掉了 0,0,0 这种三元组</span><br>                <span class="hljs-comment">/*</span><br><span class="hljs-comment">                while (right &gt; left &amp;&amp; nums[right] == nums[right - 1]) right--;</span><br><span class="hljs-comment">                while (right &gt; left &amp;&amp; nums[left] == nums[left + 1]) left++;</span><br><span class="hljs-comment">                */</span><br>                <span class="hljs-keyword">if</span> (nums[i] + nums[left] + nums[right] &gt; <span class="hljs-number">0</span>) right--;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] + nums[left] + nums[right] &lt; <span class="hljs-number">0</span>) left++;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    result.<span class="hljs-built_in">push_back</span>(vector&lt;<span class="hljs-type">int</span>&gt;&#123;nums[i], nums[left], nums[right]&#125;);<br>                    <span class="hljs-comment">// 去重逻辑应该放在找到一个三元组之后，对b 和 c去重</span><br>                    <span class="hljs-keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="hljs-number">1</span>]) right--;<br>                    <span class="hljs-keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="hljs-number">1</span>]) left++;<br>                    <span class="hljs-comment">// 找到答案时，双指针同时收缩</span><br>                    right--;<br>                    left++;<br>                &#125;<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++基础知识</title>
    <link href="/2022/09/01/%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/09/01/%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="rand-，random-的区别"><a href="#rand-，random-的区别" class="headerlink" title="rand()，random()的区别"></a>rand()，random()的区别</h2><h3 id="rand（）"><a href="#rand（）" class="headerlink" title="rand（）"></a>rand（）</h3><p>要使用srand()函数设置随机数种子。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">srand</span>((<span class="hljs-type">int</span>)<span class="hljs-built_in">time</span>(<span class="hljs-number">0</span>));  <span class="hljs-comment">// 产生随机种子  把0换成NULL也行</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<span class="hljs-comment">//产生十次</span><br>    &#123;<br>        cout &lt;&lt; <span class="hljs-built_in">rand</span>()%<span class="hljs-number">100</span>&lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<span class="hljs-comment">//范围在[0,100)的随机数</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="const与指针"><a href="#const与指针" class="headerlink" title="const与指针"></a>const与指针</h2><p><strong>const：优先修饰左边</strong></p><hr><h2 id="堆、栈和内存管理"><a href="#堆、栈和内存管理" class="headerlink" title="堆、栈和内存管理"></a>堆、栈和内存管理</h2><p>c++执行程序时，会将内存分为4个区域</p><ul><li>代码区：存放函数体的二进制代码，由操作系统进行管理</li><li>全局区：存放全局变量和静态变量以及常量</li><li>栈区：由编译器自动分配释放。存放函数的参数值和局部变量</li><li>堆区：由程序员分配和释放，若不人为释放，程序结束时由系统回收。</li></ul><p><strong>不同区域存放的数据，有不同生命周期。</strong></p><h3 id="程序运行前"><a href="#程序运行前" class="headerlink" title="程序运行前"></a>程序运行前</h3><p>编译以后，exe可执行文件在<strong>未执行</strong>的时候，分为两个区域。</p><ul><li>代码区<ul><li>共享</li><li>只读</li><li>cpu执行的机器指令</li></ul></li><li>全局区<ul><li>全局变量和静态变量存放在此</li><li>常量区：字符串常量和const修饰的全局变量<ul><li>const修饰的局部变量<strong>不在全局区</strong></li></ul></li><li>程序结束后，由系统释放</li></ul></li></ul><h3 id="程序运行后"><a href="#程序运行后" class="headerlink" title="程序运行后"></a>程序运行后</h3><ul><li><p>栈区：</p><ul><li><p>由编译器自动分配释放，存放函数的参数值、局部变量、形参。</p></li><li><p><strong>注意：</strong>不要返回局部变量的地址，栈区开辟的数据由编译器自动释放。（函数里不要返回函数里定义的变量的地址）</p></li><li><p>堆区：</p><p>程序员进行分配释放、使用new在堆区开辟内存。 <strong>这里也是内存泄漏的原发地</strong></p></li></ul></li></ul><h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><p>存在于某个作用域内的一块内存空间，当调用函数的时候，函数本身就会形成一个stack用来放置他所接受的参数、local object、返回地址。离开作用域的时候，就自动消失了。</p><h3 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h3><p>由操作系统提供的一块global内存空间。这块空间由new操作符，动态的取得，<strong>手动释放！</strong></p><p><strong>离开作用域后，那块申请的内存空间也不会消失！</strong>但是，离开作用域后，新建的指针就不可见了，就发生了内存泄漏，没机会delete。</p><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p>其生命在作用域结束后，也仍然存在！直到程序结束。</p><h3 id="全局对象"><a href="#全局对象" class="headerlink" title="全局对象"></a>全局对象</h3><p>任何大括号之外的，全局对象。生命在程序结束后才消失。</p><hr><h2 id="new操作符"><a href="#new操作符" class="headerlink" title="new操作符"></a>new操作符</h2><p><a href="https://blog.csdn.net/hazir/article/details/21413833?spm=1001.2101.3001.6650.9&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-9.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-9.pc_relevant_default&utm_relevant_index=13">https://blog.csdn.net/hazir/article/details/21413833?spm=1001.2101.3001.6650.9&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-9.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-9.pc_relevant_default&amp;utm_relevant_index=13</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">10</span>);<br><span class="hljs-keyword">delete</span> p;<br><span class="hljs-type">int</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>];<br><span class="hljs-keyword">delete</span>[] p;<br></code></pre></td></tr></table></figure><p><strong>New[] 一定要搭配delete[]</strong>, 编译器才知道，delete的是一个数组，delete会调用数组长度次。不然的话，只调用一次，剩下的内存就泄漏了。</p><h3 id="new发生了什么？"><a href="#new发生了什么？" class="headerlink" title="new发生了什么？"></a>new发生了什么？</h3><ol><li>先分配内存，内部调用了C的malloc() </li><li>将指针转型</li><li>通过2得到的指针调用构造函数</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-type">void</span>* mem = <span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(<span class="hljs-built_in">sizeof</span>(Complex));<br>pc = <span class="hljs-built_in">static_cast</span>&lt;Complex*&gt;(mem);<br>pc-&gt;Complex::<span class="hljs-built_in">Complex</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>); <span class="hljs-comment">// pc调用了构造函数，那么构造函数中的this就是pc  谁调用就是谁</span><br></code></pre></td></tr></table></figure><h3 id="什么时候在堆上分配内存"><a href="#什么时候在堆上分配内存" class="headerlink" title="什么时候在堆上分配内存"></a>什么时候在堆上分配内存</h3><ul><li>类的对象比较大</li><li>想要显示的控制对象的生命周期</li></ul><hr><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ol><li>引用必须初始化。</li><li>引用初始化后不能再改变他里面的地址。</li><li>赋值可以。</li></ol><h3 id="引用作为函数的返回值"><a href="#引用作为函数的返回值" class="headerlink" title="引用作为函数的返回值"></a>引用作为函数的返回值</h3><p><strong>不要返回局部变量的引用</strong></p><h4 id="传递者不需要知道接受者是以引用的形式接受"><a href="#传递者不需要知道接受者是以引用的形式接受" class="headerlink" title="传递者不需要知道接受者是以引用的形式接受"></a>传递者不需要知道接受者是以引用的形式接受</h4><p>意思是，函数的返回值是引用，但是我在函数中return一个value也是可以的。如果设计者足够聪明，就会用reference的形式进行接受，速度足够快。 </p><p>例子代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">inline</span> complex&amp; __doapl(complex&amp; ths)&#123;<br><span class="hljs-keyword">return</span> *ths;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="explicit和隐式类型转换"><a href="#explicit和隐式类型转换" class="headerlink" title="explicit和隐式类型转换"></a>explicit和隐式类型转换</h2><p>某个类有一些构造函数，我们可以直接给类成员赋值 <code>=</code>  字面量。这样看上去很不合理，但是C++认为这个字面量可以触发该类的构造函数，所以会隐式的调用构造函数。但是隐式转换只允许转换一次，也就是说 <code>“this is a string!&quot;</code>这个字符数组不会被转换为一个含有 <code>string </code>构造函数的类的，因为这样要经过两次转换。先从 <code>char*[]</code> 转换为 <code> string</code> 在转换为 <code>类类型</code>。</p><h3 id="explicit关键词"><a href="#explicit关键词" class="headerlink" title="explicit关键词"></a>explicit关键词</h3><p><code>explicit</code>关键词放在构造函数的前面，该关键词限制了对象必须<strong>显示调用构造函数</strong>来生成类对象。</p><p>所以就不会有上面的那种情况了。</p><hr><h2 id="函数的默认参数"><a href="#函数的默认参数" class="headerlink" title="函数的默认参数"></a>函数的默认参数</h2><p>第一个默认参数的后面必须都有默认值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fun</span> <span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b=<span class="hljs-number">10</span>, <span class="hljs-type">int</span> c=<span class="hljs-number">100</span>)</span></span>&#123;<br>xxxxxxx<br>&#125;<br></code></pre></td></tr></table></figure><p>声明和实现，只能有一个有默认参数！</p><hr><h2 id="函数的占位参数"><a href="#函数的占位参数" class="headerlink" title="函数的占位参数"></a>函数的占位参数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a ,<span class="hljs-type">int</span>)</span></span>&#123;<br>  xxxx;<br>&#125;<br><span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>,<span class="hljs-number">10</span>);<span class="hljs-comment">//这样才能调用，但是目前阶段的占位参数还用不到。</span><br></code></pre></td></tr></table></figure><hr><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><ul><li>同一作用域</li><li>函数名相同</li><li>函数参数<ul><li>类型不同</li><li>个数不同</li><li>顺序不同</li></ul></li></ul><h3 id="函数重载的注意事项"><a href="#函数重载的注意事项" class="headerlink" title="函数重载的注意事项"></a>函数重载的注意事项</h3><h4 id="引用作为重载的条件"><a href="#引用作为重载的条件" class="headerlink" title="引用作为重载的条件"></a>引用作为重载的条件</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;a)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;a)</span></span>;<br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">func</span>(a); <br><span class="hljs-comment">// result: 调用第一行的！</span><br><br><span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>);<br><span class="hljs-comment">// result :调用第二行的！</span><br></code></pre></td></tr></table></figure><h3 id="重载碰到默认参数"><a href="#重载碰到默认参数" class="headerlink" title="重载碰到默认参数"></a>重载碰到默认参数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;a)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b=<span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-type">int</span> a =<span class="hljs-number">10</span>;<br><span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>);<span class="hljs-comment">//会出现错误，有二义性的出现</span><br></code></pre></td></tr></table></figure><hr><h2 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h2><p><a href="https://blog.csdn.net/K346K346/article/details/52065524">https://blog.csdn.net/K346K346/article/details/52065524</a></p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>用来代替C中宏定义的。</p><h3 id="编译器的处理方法"><a href="#编译器的处理方法" class="headerlink" title="编译器的处理方法"></a>编译器的处理方法</h3><p>编译器在编译阶段进行处理，但是编译器有权不去做。通过减少函数调用的相关痕迹，来提升性能。</p><ol><li>将inline函数体复制到调用处</li><li>给inline函数中的局部变量分配内存空间</li></ol><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>在函数的定义处，返回值之前加inline。</p><p>在声明时也最好加上，但是<strong>只在声明时加不好使</strong>！</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li>内联函数在代码处直接展开，减少了参数压栈、栈帧开辟和回收、结果返回等操作，提高运行速度。</li><li>和<strong>宏函数</strong>相比，有安全检查和自动类型转换。宏函数没有这些。</li><li>类内声明且定义的成员函数，自动转为内联函数。<strong>内联函数能访问成员变量，宏函数不行。</strong></li><li>inline运行时可以调试，宏函数不行。</li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li><p>代码膨胀，空间换时间。</p></li><li><p>内联不可控，由编译器决定</p></li><li><p>不能跟随函数库升级而更新。如果f是函数库的一个inline函数，f会直接编译到程序中，如果函数库改变f，则用到f的程序都需要重新编译。</p><p>如果f不是内联的，那么只重新链接就行。</p></li></ol><hr><h2 id="临时对象-temp-object"><a href="#临时对象-temp-object" class="headerlink" title="临时对象 temp object"></a>临时对象 temp object</h2><p>使用方法是 typename();例如，int(1)、complex(real(x),imagine(x));</p><p>临时使用，声明周期到下一行就结束啦。</p><hr><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><p>智能指针允许多个指针指向一个目标。使用 <code>make_shared&lt;int&gt;(996)</code>函数进行构造，在进行拷贝和赋值操作时（作为函数返回值），会进行记数操作。记数为0时，就自动释放指针指向的对象。</p><h4 id="空悬指针"><a href="#空悬指针" class="headerlink" title="空悬指针"></a>空悬指针</h4><p>delete一个指针以后，其他地方可能还会保存着这个指针。这个指针现在指向的内容不存在了，属于是空悬指针。</p><p>有一种方法可以避免空悬指针问题，即在指针离开作用域时，将其释放掉。这样就不会出现后面再使用这个指针的状况了。但这个方法只提供了有限的保护。</p><h4 id="不要使用get为另一个智能指针初始化或者赋值、"><a href="#不要使用get为另一个智能指针初始化或者赋值、" class="headerlink" title="不要使用get为另一个智能指针初始化或者赋值、"></a>不要使用get为另一个智能指针初始化或者赋值、</h4><p>因为这样可能会导致智能指针自动释放了内存，出现空悬指针和多次释放。</p><h4 id="reset"><a href="#reset" class="headerlink" title="reset()"></a>reset()</h4><p>reset()函数可以为智能指针重新分配底层的对象，同时重制计数，甚至释放内存。一般和unique混合使用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(!p.<span class="hljs-built_in">unique</span>())&#123;<br>p.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(*p)); <span class="hljs-comment">//不是唯一用户的时候，拷贝一份新的进行操作。</span><br>&#125;<br>*p +=newVal;<br></code></pre></td></tr></table></figure><h2 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CPP">std::tuple&lt;std::string,std::vector&gt; fuck<br></code></pre></td></tr></table></figure><h2 id="Template"><a href="#Template" class="headerlink" title="Template"></a>Template</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">(T value)</span></span>&#123;<br>std::cout&lt;&lt;value&lt;&lt;std::endl;<br>&#125;<br><span class="hljs-built_in">Print</span>(<span class="hljs-number">5</span>);<br><span class="hljs-built_in">Print</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">5</span>);<br><span class="hljs-built_in">Print</span>&lt;std::string&gt;(<span class="hljs-string">&quot;hello&quot;</span>);<br></code></pre></td></tr></table></figure><p>用template关键词。会用T代替实际的类型，可以隐式也可以显式调用。</p><p>模版函数只有在调用的时候才会真正存在。不然的话就是不存在的。 </p><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><h3 id="作为结构体成员"><a href="#作为结构体成员" class="headerlink" title="作为结构体成员"></a>作为结构体成员</h3><h3 id="作为函数的参数"><a href="#作为函数的参数" class="headerlink" title="作为函数的参数"></a>作为函数的参数</h3><p>作为参数传递的函数，一般叫做回调函数。</p><h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><h2 id="vector中的push-back-和empalce-back"><a href="#vector中的push-back-和empalce-back" class="headerlink" title="vector中的push_back()和empalce_back()"></a>vector中的push_back()和empalce_back()</h2><p><strong>两个的功能都是往vector的尾部插入一个新值。</strong></p><h3 id="emplace-back-和-push-back-的区别，就在于底层实现的机制不同。"><a href="#emplace-back-和-push-back-的区别，就在于底层实现的机制不同。" class="headerlink" title="emplace_back() 和 push_back() 的区别，就在于底层实现的机制不同。"></a>emplace_back() 和 push_back() 的区别，就在于底层实现的机制不同。</h3><p>push_back()向容器尾部添加元素时，首先会创建这个元素，然后再将这个元素拷贝或者移动到容器中（如果是拷贝的话，事后会自行销毁先前创建的这个元素）</p><p>而emplace_back()在实现时，则是直接在容器尾部创建这个元素，省去了拷贝或移动元素的过程。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><h3 id="头文件干啥"><a href="#头文件干啥" class="headerlink" title="头文件干啥"></a>头文件干啥</h3><ol><li>定义常量</li><li>引用其他头文件</li><li>声明类</li></ol><h3 id="预编译器和头文件"><a href="#预编译器和头文件" class="headerlink" title="预编译器和头文件"></a>预编译器和头文件</h3><h4 id="为了防止头文件被重复包含"><a href="#为了防止头文件被重复包含" class="headerlink" title="为了防止头文件被重复包含"></a>为了防止头文件被重复包含</h4><p><strong>在头文件中：</strong></p><ul><li>使用#ifndef</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> SALES_DATA_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SALES_DATA_H</span><br>xxx ...<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><ul><li>使用 <code>#pragma once</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++语言</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>链表</title>
    <link href="/2022/09/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/09/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="链表的定义"><a href="#链表的定义" class="headerlink" title="链表的定义"></a>链表的定义</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span>&#123;<br><span class="hljs-type">int</span> _val;<br>ListNode *next;<br><span class="hljs-built_in">ListNode</span>(<span class="hljs-type">int</span> val):_val(val),<span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ListNode* head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">5</span>);<br><span class="hljs-comment">// 如果没有定义构造函数的话</span><br>ListNode* head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>head-&gt;val = <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><p>使用C++的时候，再删除节点的时候要将内存进行释放。</p><h2 id="LC-203-移除链表元素"><a href="#LC-203-移除链表元素" class="headerlink" title="LC-203 移除链表元素"></a>LC-203 移除链表元素</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="删除中间的节点"><a href="#删除中间的节点" class="headerlink" title="删除中间的节点"></a>删除中间的节点</h4><p>就是让前面的节点指向要删除的节点的下一个节点。</p><h4 id="删除头节点"><a href="#删除头节点" class="headerlink" title="删除头节点"></a>删除头节点</h4><h5 id="直接使用原来的链表进行删除"><a href="#直接使用原来的链表进行删除" class="headerlink" title="直接使用原来的链表进行删除"></a>直接使用原来的链表进行删除</h5><p>将头节点往后移动一个就完成了删除</p><p>但是需要单独处理这个情况</p><h5 id="设置一个虚拟头节点再进行删除"><a href="#设置一个虚拟头节点再进行删除" class="headerlink" title="设置一个虚拟头节点再进行删除"></a>设置一个虚拟头节点再进行删除</h5><p>一视同仁，删除头和中间的节点都可以</p><p>设置一个虚拟头节点，指向真实头节点。</p><p>如果要删除真实头节点的话，就将虚拟头节点指向第二个节点。</p><p>最后返回头节点的时候，要返回 <code>dummyNode-&gt;next</code>,这才是真正的头节点。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeElements</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        ListNode *dummyNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        dummyNode-&gt;next = head<br>        ListNode * cur = dummyNode;<br>        <span class="hljs-keyword">while</span>(cur-&gt;next!=<span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">if</span> (cur-&gt;next-&gt;val == val)&#123;<br>                ListNode *tmp = cur-&gt;next;<br>                cur-&gt;next = cur-&gt;next-&gt;next;<br>                <span class="hljs-keyword">delete</span> tmp;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                cur = cur-&gt;next;<br>            &#125;<br>        &#125;<br>        head = dummyNode-&gt;next;<br>        <span class="hljs-keyword">delete</span> dummyNode;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="LC-703-设计链表"><a href="#LC-703-设计链表" class="headerlink" title="LC-703 设计链表"></a>LC-703 设计链表</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyLinkedList</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span><br>    &#123;<br>        <span class="hljs-type">int</span> val;<br>        Node *next;<br>        <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> v, Node *n) : <span class="hljs-built_in">val</span>(v), <span class="hljs-built_in">next</span>(n) &#123;&#125;<br>        <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> v) : <span class="hljs-built_in">val</span>(v), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>    &#125;;<br>    <span class="hljs-built_in">MyLinkedList</span>()<br>    &#123;<br>        _dummyNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (index &gt; _size - <span class="hljs-number">1</span> || index &lt; <span class="hljs-number">0</span>)<br>        &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;<br>        Node *cur = _dummyNode-&gt;next;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; index; i++)<br>        &#123;cur = cur-&gt;next;&#125;<br>        <span class="hljs-keyword">return</span> cur-&gt;val;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addAtHead</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function">    </span>&#123;<br>        Node *temp = _dummyNode-&gt;next;<br>        _dummyNode-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(val, temp);<br>        _size++;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addAtTail</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function">    </span>&#123;<br>        Node *cur = _dummyNode;<br>        <span class="hljs-keyword">while</span> (cur-&gt;next)<br>        &#123;<br>            cur = cur-&gt;next;<br>        &#125;<br>        Node *newNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(val);<br>        cur-&gt;next = newNode;<br>        _size++;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addAtIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (index &gt; _size || index &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        Node *cur = _dummyNode;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; index ; i++)<br>        &#123;<br>            cur = cur-&gt;next;<br>        &#125;<br>        Node *temp = cur-&gt;next;<br>        cur-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(val, temp);<br>        _size++;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteAtIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (index &gt;= _size || index &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        Node *cur = _dummyNode;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; index; i++)<br>        &#123;<br>            cur = cur-&gt;next;<br>        &#125;<br>        Node *temp = cur-&gt;next;<br>        cur-&gt;next = cur-&gt;next-&gt;next;<br>        <span class="hljs-keyword">delete</span> temp;<br>        _size--;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">//使用类内初始值进行初始化</span><br>    <span class="hljs-type">int</span> _size = <span class="hljs-number">0</span>;<br>    Node *_dummyNode = <span class="hljs-literal">nullptr</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="LC-206-翻转链表"><a href="#LC-206-翻转链表" class="headerlink" title="LC-206 翻转链表"></a>LC-206 翻转链表</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>我的思路是新建一个新的链表，进行数据的存储和反转。<strong>但是造成了空间资源的浪费。</strong></li><li>只需要将next的指针进行反转。<ol><li>双指针法，一个指针用来保存当前cur的地址，为了到下一个节点时，给节点的next赋值</li><li>另一个指针用来临时保存当前的节点的next值，用于移动到下一个节点。</li></ol></li><li>递归，将指针换方向的过程放到递归函数中，每次调用递归函数的时候，将参数向前移动一个。</li></ol><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><h4 id="思路一代码"><a href="#思路一代码" class="headerlink" title="思路一代码"></a>思路一代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* result = <span class="hljs-literal">nullptr</span>;<br>        ListNode *cur = head;<br>        <span class="hljs-keyword">while</span>(cur)&#123;<br>            ListNode * newNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(cur-&gt;val,result);<br>            result = newNode;<br>            cur = cur-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="思路二代码"><a href="#思路二代码" class="headerlink" title="思路二代码"></a>思路二代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode *cur = head,*pre = <span class="hljs-literal">nullptr</span>,*temp=<span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">while</span>(cur)&#123;<br>            temp = cur-&gt;next;<br>            cur-&gt;next = pre;<br>            pre = cur;<br>            cur = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="思路三递归"><a href="#思路三递归" class="headerlink" title="思路三递归"></a>思路三递归</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>      <span class="hljs-comment">//进行初始化</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">reverse</span>(head, <span class="hljs-literal">nullptr</span>);<br>    &#125;<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverse</span><span class="hljs-params">(ListNode* cur,ListNode* pre)</span></span>&#123;<br>      <span class="hljs-comment">// 递归函数的终止条件</span><br>        <span class="hljs-keyword">if</span>(cur==<span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span> pre;<br>        &#125;<br>      <span class="hljs-comment">//变换指针方向</span><br>        ListNode *temp = cur-&gt;next;<br>        cur-&gt;next = pre;<br>       <span class="hljs-keyword">return</span> <span class="hljs-built_in">reverse</span>(temp, cur);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="LC-24-两两交换链表中的节点"><a href="#LC-24-两两交换链表中的节点" class="headerlink" title="LC-24 两两交换链表中的节点"></a>LC-24 两两交换链表中的节点</h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>要想交换两个节点，需要知道这两个节点前面的一个节点</li><li>要新建一个虚拟头节点</li><li>奇数个和偶数个的情况是不一样的。</li></ol><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">swapPairs</span><span class="hljs-params">(ListNode *head)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ListNode *dummyNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        dummyNode-&gt;next = head;<br>        ListNode *cur = dummyNode;<br>        <span class="hljs-comment">// 这里的循环条件是，如果是奇数个，那么cur-&gt;next=null的时候，就已经到了最后剩下的一个节点</span><br>        <span class="hljs-comment">// 如果是cur-&gt;next-&gt;next = null，那么就是偶数个，遍历完了所有的节点。</span><br>      <span class="hljs-comment">// 要注意这里条件。cpp中是左边通过之后才去判断右边的。</span><br>        <span class="hljs-keyword">while</span> (cur-&gt;next!=<span class="hljs-literal">nullptr</span> &amp;&amp; cur-&gt;next-&gt;next!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            <span class="hljs-comment">// 记录cur后第一个</span><br>            ListNode *temp = cur-&gt;next;<br>            <span class="hljs-comment">// 记录cur后第三个</span><br>            ListNode *temp1 = cur-&gt;next-&gt;next-&gt;next;<br><br>            cur-&gt;next = cur-&gt;next-&gt;next;<br>            cur-&gt;next-&gt;next = temp;<br>            temp-&gt;next = temp1;<br>            cur = cur-&gt;next-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummyNode-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="LC-19-删除链表的倒数第N个节点"><a href="#LC-19-删除链表的倒数第N个节点" class="headerlink" title="LC-19 删除链表的倒数第N个节点"></a>LC-19 删除链表的倒数第N个节点</h2><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ol><li>暴力解法，遍历两次，第一次保存链表的长度；第二次遍历到目标节点</li><li>双指针<ol><li>两个指针，一个用于遍历，另一个和前一个指针隔N个。</li><li>当fast到了末尾的时候，slow也到了指定的节点的前一个节点处</li><li>执行删除的操作</li></ol></li></ol><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><h4 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        ListNode* dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>,head);<br>        ListNode* cur = dummyHead;<br>        <span class="hljs-type">int</span> size = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(cur-&gt;next)&#123;<br>            cur = cur-&gt;next;<br>            size++;<br>        &#125;<br>        ListNode* target = dummyHead;<br>        <span class="hljs-type">int</span> step = size - n;<br>        <span class="hljs-keyword">while</span>(step --)&#123;<br>            target = target-&gt;next;<br>        &#125;<br>        ListNode *temp = target-&gt;next;<br>        target-&gt;next = target-&gt;next-&gt;next;<br>        <span class="hljs-keyword">delete</span> temp;<br>        <span class="hljs-keyword">return</span> dummyHead-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        ListNode* dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>,head);<br>        ListNode* s=dummy,*f=dummy;<br>        <span class="hljs-type">int</span> interval = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(f-&gt;next)&#123;<br>            f = f-&gt;next;<br>            <span class="hljs-keyword">if</span>(interval&lt;n)&#123;<br>                interval++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                s=s-&gt;next;<br>            &#125;<br>        &#125;<br>        ListNode* temp = s-&gt;next;<br>        s-&gt;next = s-&gt;next-&gt;next;<br>        <span class="hljs-keyword">delete</span> temp;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="面试题-02-07-链表相交"><a href="#面试题-02-07-链表相交" class="headerlink" title="面试题 02.07. 链表相交"></a>面试题 02.07. 链表相交</h2><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><ol><li>返回的开始共用的节点地址</li><li>先获取两个表的长度，然后将两个表对齐。从对齐的地方开始两个表依次往后移动。</li></ol><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getListSize</span><span class="hljs-params">(ListNode* head)</span></span>&#123;<br>        <span class="hljs-type">int</span> size=<span class="hljs-number">0</span>;<br>        ListNode *dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>,head);<br>        ListNode *cur = dummy;<br>        <span class="hljs-keyword">while</span>(cur-&gt;next)&#123;<br>            cur = cur-&gt;next;<br>            size++;<br>        &#125;<br>        <span class="hljs-keyword">delete</span> dummy;<br>        <span class="hljs-keyword">return</span> size;<br>    &#125;<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>        ListNode * dummyA =<span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>,headA);<br>        ListNode * dummyB = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>,headB);<br>        ListNode * curA = dummyA;<br>        ListNode * curB = dummyB;<br>        <span class="hljs-type">int</span> size_a = <span class="hljs-built_in">getListSize</span>(headA);<br>        <span class="hljs-type">int</span> size_b = <span class="hljs-built_in">getListSize</span>(headB);<br>        <span class="hljs-type">int</span> interval =<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(size_a&gt;=size_b)&#123;<br>            interval = size_a-size_b;<br>            <span class="hljs-keyword">while</span>(interval--)&#123;<br>                curA = curA-&gt;next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            interval = size_b-size_a;<br>            <span class="hljs-keyword">while</span>(interval--)&#123;<br>                curB = curB-&gt;next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(curA-&gt;next)&#123;<br>            <span class="hljs-keyword">if</span>(curA-&gt;next == curB-&gt;next)&#123;<br>                <span class="hljs-keyword">return</span> curA-&gt;next;<br>            &#125;<br>            curA = curA-&gt;next;<br>            curB = curB-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="LC-142环型链表"><a href="#LC-142环型链表" class="headerlink" title="LC-142环型链表"></a>LC-142环型链表</h2><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><ol><li><p>暴力解法：</p><p>找一个数组存地址变量，每经过一个节点，就把这个节点的地址和数组中的所有地址做比较。但出现重复的地址时，就说明这个第一个出现的重复地址就是环的入口。</p></li><li><p>双指针：</p></li></ol><p>主要涉及两个问题，第一个是判断有没有环；第二个是知道环的入口。</p><p>这个题的解决方法是 <strong>双指针</strong>，用两个快慢指针来解题。</p><h4 id="判断是否有环"><a href="#判断是否有环" class="headerlink" title="判断是否有环"></a>判断是否有环</h4><p>快指针一次走2个，慢指针一次走1个，如果快慢指针相遇了，说明存在环。</p><h4 id="返回环的入口"><a href="#返回环的入口" class="headerlink" title="返回环的入口"></a>返回环的入口</h4><ol><li>当快慢指针相遇的时候，一定是在环内相遇的。</li><li>设整个链表有a+b个节点，a是到环入口处的节点数，b是环的节点数</li><li>在相遇的时候，快指针走了f步，慢指针走了s步，则f&#x3D;2s。</li><li>同时还有：快指针比慢指针多走了N个环的周长，然后和慢指针相遇，所以有f-s &#x3D; nb</li><li>综合 3，4可得 s &#x3D; nb，f&#x3D;2nb</li><li>设从头节点到环入口。需要走 a+nb步，每多走一个b，就能回到入口这里。</li><li>现在慢节点走了nb步，怎么再走a步呢？<ol><li>答案是，再从头节点出发一个指针，当指针和慢指针相遇的时候，慢指针一定走了nb+a步。</li></ol></li></ol><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        ListNode* fast = head;<br>        ListNode* slow = head;<br>        <span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="hljs-literal">NULL</span>) &#123;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next-&gt;next;<br>            <span class="hljs-comment">// 快慢指针相遇，此时从head 和 相遇点，同时查找直至相遇</span><br>            <span class="hljs-keyword">if</span> (slow == fast) &#123;<br>                ListNode* index1 = fast;<br>                ListNode* index2 = head;<br>                <span class="hljs-keyword">while</span> (index1 != index2) &#123;<br>                    index1 = index1-&gt;next;<br>                    index2 = index2-&gt;next;<br>                &#125;<br>                <span class="hljs-keyword">return</span> index2; <span class="hljs-comment">// 返回环的入口</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数组</title>
    <link href="/2022/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/"/>
    <url>/2022/08/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="数组是存放在连续内存空间上的相同类型的数据集合"><a href="#数组是存放在连续内存空间上的相同类型的数据集合" class="headerlink" title="数组是存放在连续内存空间上的相同类型的数据集合"></a>数组是存放在<strong>连续内存空间</strong>上的相同类型的数据集合</h2><ol><li>因为数组的在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址</li><li>在C++中<strong>二维数组</strong>的内存是<strong>连续</strong>分布的。</li></ol><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><ol><li>有序数组</li><li>无重复元素</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>二分查找涉及的很多的边界条件，逻辑比较简单，但就是写不好。例如到底是 <code>while(left &lt; right)</code>还是 <code>while(left &lt;= right)</code>，到底是<code>right = middle</code>呢，还是要<code>right = middle - 1</code>呢？</p><p>大家写二分法经常写乱，主要是因为<strong>对区间的定义没有想清楚，区间的定义就是不变量</strong>。要在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是<strong>循环不变量</strong>规则。</p><h4 id="左闭右闭"><a href="#左闭右闭" class="headerlink" title="左闭右闭"></a>左闭右闭</h4><p>第一种写法，我们定义 target 是在一个在左闭右闭的区间里，<strong>也就是[left, right] （这个很重要非常重要）</strong></p><p>区间的定义这就决定了二分法的代码应该如何写：</p><ul><li>while (left &lt;&#x3D; right) 要使用 &lt;&#x3D; ，因为left &#x3D;&#x3D; right是有意义的，所以使用 &lt;&#x3D;</li><li>if (nums[middle] &gt; target)时，要缩小区间，此时<strong>新的right</strong>要赋值为middle - 1</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; <span class="hljs-comment">// 定义target在左闭右闭的区间里，[left, right]</span><br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123; <span class="hljs-comment">// 当left==right，区间[left, right]依然有效，所以用 &lt;=</span><br>            <span class="hljs-type">int</span> middle = left + ((right - left) / <span class="hljs-number">2</span>);<span class="hljs-comment">// 防止溢出 等同于(left + right)/2</span><br>            <span class="hljs-keyword">if</span> (nums[middle] &gt; target) &#123;<br>                right = middle - <span class="hljs-number">1</span>; <span class="hljs-comment">// target 在左区间，所以[left, middle - 1]</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[middle] &lt; target) &#123;<br>                left = middle + <span class="hljs-number">1</span>; <span class="hljs-comment">// target 在右区间，所以[middle + 1, right]</span><br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// nums[middle] == target</span><br>                <span class="hljs-keyword">return</span> middle; <span class="hljs-comment">// 数组中找到目标值，直接返回下标</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 未找到目标值</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="LC-35-搜索插入位置"><a href="#LC-35-搜索插入位置" class="headerlink" title="LC-35 搜索插入位置"></a>LC-35 搜索插入位置</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>是二分查找的变体，多返回了一个该插入的位置。</p><p>这个题目用暴力解是最快的，遍历一遍，找不到就返回末尾的值或0；</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = n - <span class="hljs-number">1</span>; <span class="hljs-comment">// 定义target在左闭右闭的区间里，[left, right]</span><br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123; <span class="hljs-comment">// 当left==right，区间[left, right]依然有效</span><br>            <span class="hljs-type">int</span> middle = left + ((right - left) / <span class="hljs-number">2</span>);<span class="hljs-comment">// 防止溢出 等同于(left + right)/2</span><br>            <span class="hljs-keyword">if</span> (nums[middle] &gt; target) &#123;<br>                right = middle - <span class="hljs-number">1</span>; <span class="hljs-comment">// target 在左区间，所以[left, middle - 1]</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[middle] &lt; target) &#123;<br>                left = middle + <span class="hljs-number">1</span>; <span class="hljs-comment">// target 在右区间，所以[middle + 1, right]</span><br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// nums[middle] == target</span><br>                <span class="hljs-keyword">return</span> middle;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 分别处理如下四种情况</span><br>        <span class="hljs-comment">// 目标值在数组所有元素之前  [0, -1]</span><br>        <span class="hljs-comment">// 目标值等于数组中某一个元素  return middle;</span><br>        <span class="hljs-comment">// 目标值插入数组中的位置 [left, right]，return  right + 1</span><br>        <span class="hljs-comment">// 目标值在数组所有元素之后的情况 [left, right]， 因为是右闭区间，所以 return right + 1</span><br>        <span class="hljs-keyword">return</span> right + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><h4 id="不知道left和right最后的位置是哪里？"><a href="#不知道left和right最后的位置是哪里？" class="headerlink" title="不知道left和right最后的位置是哪里？"></a>不知道left和right最后的位置是哪里？</h4><p>最后一次缩圈中，根据循环条件知道left &#x3D;&#x3D; right &#x3D;&#x3D; middle：</p><ul><li>如果这个数大于目标值，则right往左移动，变成right-1</li><li>否则就是left往右移动，变成left+1</li></ul><h2 id="LC-34-在排序数组中查找元素的第一个和最后一个位置"><a href="#LC-34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="LC-34 在排序数组中查找元素的第一个和最后一个位置"></a>LC-34 在排序数组中查找元素的第一个和最后一个位置</h2><h3 id="条件-1"><a href="#条件-1" class="headerlink" title="条件"></a>条件</h3><ol><li>非递减数组</li><li>O(logn)</li></ol><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>非递减也是有序的，但是会有重复的值出现。</li><li>算法要求的时间复杂度需要我们用二分法</li><li>用两个二分法，分别寻找左右边界。我没想到这么做，想一个二分找出来。</li><li>寻找左边界是用二分法的mid找到目标值，但是继续将right向左移动，用来寻找最左边的目标值。</li></ol><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">searchRange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-built_in">findLeftLimit</span>(nums, target), <span class="hljs-built_in">findRightLimit</span>(nums, target)&#125;;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findLeftLimit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> target)</span></span>&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> limit = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right)<br>        &#123;<br>            <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid]&lt;target)<br>            &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid]&gt;target)&#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>          <span class="hljs-comment">// 在mid是目标值的时候，更新边界</span><br>            <span class="hljs-keyword">else</span> &#123;<br>                limit = mid;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> limit;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findRightLimit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> target)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> limit = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right)<br>        &#123;<br>            <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &lt; target)<br>            &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target)<br>            &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>              limit= mid;<br>                left = mid +<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> limit;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="LC-69-x的平方根"><a href="#LC-69-x的平方根" class="headerlink" title="LC-69 x的平方根"></a>LC-69 x的平方根</h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>二分法，缩圈的条件是中间值的平方和x的大小关系</li><li>注意： <strong>不要用int去存，会超出int的存储范围！</strong></li></ol><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mySqrt</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = x;<br>        <span class="hljs-keyword">while</span> (left &lt;= right)<br>        &#123;<br>            <span class="hljs-type">long</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (mid * mid &lt; x)<br>            &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mid * mid &gt; x)<br>            &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">return</span> mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> right;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="LC-367-有效的完全平方数"><a href="#LC-367-有效的完全平方数" class="headerlink" title="LC-367 有效的完全平方数"></a>LC-367 有效的完全平方数</h2><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>和上面的69题一摸一样</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPerfectSquare</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = num;<br>        <span class="hljs-keyword">while</span> (left&lt;=right)<br>        &#123;<br>            <span class="hljs-type">long</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (mid*mid &lt; num)<br>            &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(mid * mid &gt;num)&#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><h2 id="基础知识-1"><a href="#基础知识-1" class="headerlink" title="基础知识"></a>基础知识</h2><ol><li>数组中的元素不能删除，只能覆盖。</li><li>cpp中的erase()函数，他是一个O(N)的操作。</li></ol><h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3><ol><li>一层for循环</li><li>用双指针代替了第二层for循环<ul><li>快指针指向<strong>新数组所需要</strong>元素，在for循环中递增遍历</li><li>慢指针是新数组的最后一个元素，在发生交换之后，递增。</li><li>快指针将需要的元素和慢指针进行交换</li></ul></li><li>元素的相对位置没有被改变</li><li>双指针法会用在<strong>已经排好序</strong>的数组里</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> slowIndex = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> fastIndex = <span class="hljs-number">0</span>; fastIndex &lt; nums.<span class="hljs-built_in">size</span>(); fastIndex++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (nums[fastIndex] != val)<br>            &#123;<br>                nums[slowIndex++] = nums[fastIndex];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slowIndex;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="双向指针"><a href="#双向指针" class="headerlink" title="双向指针"></a>双向指针</h3><p>下面的这个方法，改变了元素的相对位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 相向双指针方法，基于元素顺序可以改变的题目描述改变了元素相对位置，确保了移动最少元素</span><br><span class="hljs-comment">* 时间复杂度：O(n)</span><br><span class="hljs-comment">* 空间复杂度：O(1)</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-type">int</span> leftIndex = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> rightIndex = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (leftIndex &lt;= rightIndex) &#123;<br>            <span class="hljs-comment">// 找左边等于val的元素</span><br>            <span class="hljs-keyword">while</span> (leftIndex &lt;= rightIndex &amp;&amp; nums[leftIndex] != val)&#123;<br>                ++leftIndex;<br>            &#125;<br>            <span class="hljs-comment">// 找右边不等于val的元素</span><br>            <span class="hljs-keyword">while</span> (leftIndex &lt;= rightIndex &amp;&amp; nums[rightIndex] == val) &#123;<br>                -- rightIndex;<br>            &#125;<br>            <span class="hljs-comment">// 将右边不等于val的元素覆盖左边等于val的元素</span><br>            <span class="hljs-keyword">if</span> (leftIndex &lt; rightIndex) &#123;<br>                nums[leftIndex++] = nums[rightIndex--];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> leftIndex;   <span class="hljs-comment">// leftIndex一定指向了最终数组末尾的下一个元素</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="LC-26-删除排序数组中的重复项"><a href="#LC-26-删除排序数组中的重复项" class="headerlink" title="LC-26 删除排序数组中的重复项"></a>LC-26 删除排序数组中的重复项</h2><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><ol><li>双指针，f在s的后面。</li><li>f把不重复的值一直往s的后面插入。插完之后，两个指针递增。</li><li>当f指向的值 &#x3D;&#x3D; s指向的值时，说明有重复的值。</li><li>此时，s的值不变，f往后遍历，找到后面的不重复的值，把这个值和s后面的第一个值交换。s递增1。</li></ol><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> slowIndex = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> fastIndex = <span class="hljs-number">1</span>; fastIndex &lt; nums.<span class="hljs-built_in">size</span>(); fastIndex++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (nums[fastIndex] != nums[slowIndex])<br>            &#123;<br>                nums[++slowIndex] = nums[fastIndex];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slowIndex+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="LC-977-有序数组的平方"><a href="#LC-977-有序数组的平方" class="headerlink" title="LC-977 有序数组的平方"></a>LC-977 有序数组的平方</h2><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><ol><li>给的数组是<strong>有序的</strong></li><li>要排序的数组是给的<strong>数组的平方</strong></li><li>结合1，2点得到，新数组的<strong>最大值肯定在首尾</strong>取得，这样就可以用两个指针分别指向首尾。</li><li>而且首尾的值一定比中间的值大，所以就只需要将首尾的值比较之后，放入结果数组的尾部就行。这样结果自然就有了顺序。</li></ol><h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortedSquares</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (right==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> &#123;(nums[<span class="hljs-number">0</span>]) * (nums[<span class="hljs-number">0</span>])&#125;;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-built_in">resuLC</span>(nums.<span class="hljs-built_in">size</span>());<br>            <span class="hljs-type">int</span> index = nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">while</span> (left&lt;=right &amp;&amp; index&gt;=<span class="hljs-number">0</span>)<br>            &#123;<br>                resuLC[index--] = (<span class="hljs-built_in">pow</span>(nums[right],<span class="hljs-number">2</span>)&gt;=<span class="hljs-built_in">pow</span>(nums[left],<span class="hljs-number">2</span>))?<span class="hljs-built_in">pow</span>(nums[right--],<span class="hljs-number">2</span>):<span class="hljs-built_in">pow</span>(nums[left++],<span class="hljs-number">2</span>);<br>            &#125;<br>            <span class="hljs-keyword">return</span> resuLC;<br>        &#125; <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="LC-283-移动零"><a href="#LC-283-移动零" class="headerlink" title="LC-283 移动零"></a>LC-283 移动零</h2><h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><ol><li>双指针</li><li>慢指针指向处理好的序列的尾部，快指针指向未处理序列的头部</li><li>满足条件之后就交换，然后把慢指针右移动</li></ol><h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h3><p>我这个方法是，让慢指针指向0，快指针指向非0元素。和官方思路差不多</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>       <span class="hljs-type">int</span> slowIndex = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> fastIndex = <span class="hljs-number">0</span>; fastIndex &lt; nums.<span class="hljs-built_in">size</span>(); fastIndex++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (nums[slowIndex]!=<span class="hljs-number">0</span>)<br>            &#123;<br>                slowIndex++;<br>                cout&lt;&lt;<span class="hljs-string">&quot;slow is not zero&quot;</span>&lt;&lt;slowIndex&lt;&lt;endl;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(nums[fastIndex]!=<span class="hljs-number">0</span> &amp;&amp; nums[slowIndex]==<span class="hljs-number">0</span>)&#123;<br>                nums[slowIndex++] = nums[fastIndex];<br>                nums[fastIndex] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><h2 id="基础知识-2"><a href="#基础知识-2" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="滑动窗口-1"><a href="#滑动窗口-1" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><ol><li>用双指针作为窗口的首尾，不断调节子序列的起始位置和终止位置，从而得到想要的结果。</li><li>用一个for循环，且循环的<strong>索引</strong>表示窗口的<strong>终止位置</strong></li></ol><h2 id="LC-209-长度最小的子数组"><a href="#LC-209-长度最小的子数组" class="headerlink" title="LC-209 长度最小的子数组"></a>LC-209 长度最小的子数组</h2><h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><ol><li>窗口内容：和大于目标值的序列</li><li>窗口起始位置变动条件：窗口内的值大于目标序列，起始位置➡️移动</li><li>窗口终止位置变化条件：for循环自动变</li></ol><h3 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> resuLC = INT32_MAX;<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=<span class="hljs-number">0</span>,sum=<span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 窗口右端 向右移动</span><br>        <span class="hljs-keyword">for</span>(right;right!=nums.<span class="hljs-built_in">size</span>();right++)&#123;<br>            <span class="hljs-comment">// 将窗口右移抱进来的新元素加上去</span><br>            sum+=nums[right];<br>            <span class="hljs-comment">// 当窗口满足条件时，开始移动窗口左端</span><br>            <span class="hljs-keyword">while</span>(sum&gt;=target)&#123;<br>                resuLC = resuLC &lt; (right-left+<span class="hljs-number">1</span>) ? resuLC : (right-left+<span class="hljs-number">1</span>);<br>                <span class="hljs-comment">// sum值减去窗口左移 排出的值</span><br>                sum -=nums[left++];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> resuLC==INT32_MAX? <span class="hljs-number">0</span>:resuLC;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="LC-59-螺旋矩阵"><a href="#LC-59-螺旋矩阵" class="headerlink" title="LC-59 螺旋矩阵"></a>LC-59 螺旋矩阵</h2><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><ol><li>没有算法，就是模拟，对代码要求高</li><li>要保证<strong>循环不变量</strong>原则</li><li>写循环的时候，可以随便设置变量去辅助控制。</li></ol><h3 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">generateMatrix</span>(<span class="hljs-type">int</span> n) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">result</span>(n,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n,<span class="hljs-number">0</span>));<br>        <span class="hljs-comment">//要走几个圈呢？ 每次转圈都会在两端减少一个元素。2*looploop=n。遇到奇数的情况，中间会多出来一个！</span><br>        <span class="hljs-type">int</span> loop = n/<span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> mid = n/<span class="hljs-number">2</span>;<br>        <span class="hljs-comment">// 定义每次循环打印的起始位置（0，0）（1，1）（2，2)...</span><br>        <span class="hljs-type">int</span> startX=<span class="hljs-number">0</span>,startY=<span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 定义角标</span><br>        <span class="hljs-type">int</span> x=<span class="hljs-number">0</span>,y=<span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 定义每圈循环要打印的次数的控制量,每加一圈，这一行就少打一个。</span><br>        <span class="hljs-type">int</span> offset=<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 定义要打印的值</span><br>        <span class="hljs-type">int</span> step = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(loop)&#123;<br>            <span class="hljs-keyword">for</span>(y=startY;y&lt;n-offset;y++)&#123;<br>                result[startX][y]=step++;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(x=startX;x&lt;n-offset;x++)&#123;<br>                result[x][y]=step++;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(;y&gt;startY;y--)&#123;<br>                result[x][y]=step++;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(;x&gt;startX;x--)&#123;<br>                result[x][y]=step++;<br>            &#125;<br>            startX++,startY++,offset++,loop--;<br>        &#125;<br>         <span class="hljs-comment">// 如果n为奇数的话，需要单独给矩阵最中间的位置赋值</span><br>        <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span>) &#123;<br>            result[mid][mid] = step;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++面向对象</title>
    <link href="/2022/03/17/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <url>/2022/03/17/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<blockquote><p>   面向对象：封装、继承、多态；万事万物皆是对象！</p></blockquote><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><h2 id="封装的意义"><a href="#封装的意义" class="headerlink" title="封装的意义"></a>封装的意义</h2><ul><li>将属性和行为作为一个整体</li><li>将属性和行为加权限控制</li></ul><h3 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h3><ul><li>protected：类外不可访问，子类可以访问</li><li>private：类外不可访问，子类不能访问。<strong>将成员属性设置为私有</strong></li></ul><h3 id="struct和class的区别"><a href="#struct和class的区别" class="headerlink" title="struct和class的区别"></a>struct和class的区别</h3><p>struct默认权限是public，calss是private </p><h3 id="类的分文件编写"><a href="#类的分文件编写" class="headerlink" title="类的分文件编写"></a>类的分文件编写</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// xxx.h文件中</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once <span class="hljs-comment">//防止头文件重复包含</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> xxxx</span><br></code></pre></td></tr></table></figure><h2 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">dogclass</span> &#123;</span><br>public:<br><span class="hljs-comment">/*   构造函数</span><br><span class="hljs-comment">//1. 没有返回值 不用写void</span><br><span class="hljs-comment">//2. 函数名和类名相同</span><br><span class="hljs-comment">//3. 构造函数可以有参数，可发生重载</span><br><span class="hljs-comment">//4. 创建对象的时候，构造函数会自动调用且只调用一次*/</span><br>    dogclass() &#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;这是构造函数！&quot;</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* 析构函数</span><br><span class="hljs-comment">     * 没有返回值 不写void</span><br><span class="hljs-comment">     * 函数名和类名相同但是要加～</span><br><span class="hljs-comment">     * 不可以有参数，不可以重载</span><br><span class="hljs-comment">     * 对象在销毁前，会自动调用析构，且调用一次*/</span><br>    ~dogclass()&#123;<br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;调用析构函数&quot;</span>&lt;&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>    &#125;<br>    <span class="hljs-type">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>析构和构造如果不写，编译器会自己提供一个空实现。</strong></p><p><strong>栈上的数据执行完后会自动释放</strong>！ </p><p><strong>析构函数：将堆区的数据释放干净！</strong></p><h3 id="构造函数的分类和调用"><a href="#构造函数的分类和调用" class="headerlink" title="构造函数的分类和调用"></a>构造函数的分类和调用</h3><h4 id="有无参数"><a href="#有无参数" class="headerlink" title="有无参数"></a>有无参数</h4><ul><li>有参</li><li>无参</li></ul><h4 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h4><ul><li><p>普通</p></li><li><p>拷贝构造函数，<strong>接受自己的类型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 拷贝构造函数</span><br>Person(<span class="hljs-type">const</span> Person &amp;p)&#123;<br>  age = p.age;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h4><ul><li>括号法</li><li>显示法</li><li>隐式转换法</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Person p1;<span class="hljs-comment">//默认构造</span><br><span class="hljs-comment">//括号法！</span><br><span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<span class="hljs-comment">//括号法</span><br><span class="hljs-function">Person <span class="hljs-title">p3</span><span class="hljs-params">(p2)</span></span>;<span class="hljs-comment">//括号法调用拷贝构造函数</span><br><span class="hljs-comment">//注意事项</span><br><span class="hljs-comment">//调用默认构造函数的时候 不要加()。</span><br>  <span class="hljs-comment">//对于Person p1(); 编译器会认为这是一个函数的声明 </span><br><span class="hljs-comment">//显示法</span><br>Person p1;<br>Person p2 = <span class="hljs-built_in">Person</span>(<span class="hljs-number">10</span>);<br>Person p3 = <span class="hljs-built_in">Person</span>(p2);<span class="hljs-comment">//拷贝</span><br><span class="hljs-comment">//注意事项</span><br><span class="hljs-comment">// 对于Person(10) ,单独拿出来叫匿名对象，特点：当前执行结束后，系统会立即回收掉</span><br><span class="hljs-comment">// 不要利用拷贝构造函数，来初始化匿名对象</span><br><span class="hljs-comment">// Person(p3);    编译器会认为该代码 Person(p3) === Person p3</span><br><span class="hljs-comment">//隐式转换</span><br>Person p4 =<span class="hljs-number">10</span>;<span class="hljs-comment">//等于Person p4 = Person(10);</span><br>Person p5 = p4 ; <span class="hljs-comment">//拷贝</span><br></code></pre></td></tr></table></figure><h4 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h4><p><code>构造函数():属性1(值1)，属性2(值2)...&#123;&#125;</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>,<span class="hljs-type">int</span> b=<span class="hljs-number">0</span>,<span class="hljs-type">int</span> c=<span class="hljs-number">0</span>):<span class="hljs-built_in">m_A</span>(a),<span class="hljs-built_in">m_B</span>(b),<span class="hljs-built_in">m_C</span>(c)&#123;&#125;<br><span class="hljs-function">Person <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="拷贝构造函数的调用时机"><a href="#拷贝构造函数的调用时机" class="headerlink" title="拷贝构造函数的调用时机"></a>拷贝构造函数的调用时机</h3><p>拷贝构造函数有三种调用时机</p><ul><li>使用已经创建完毕的对象构造新对象</li><li>值传递的方式给函数参数传值</li><li>以值方式返回局部对象</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> &#123;</span><br>private:<br>    <span class="hljs-type">int</span> m_age;<br>public:<br>    Person() &#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Person默认构造函数&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125;<br>    ~Person() &#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Person默认析构函数&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125;<br>    Person(<span class="hljs-type">int</span> age) &#123;<br>        m_age = age;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Person有参构造函数&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125;<br>    Person(<span class="hljs-type">const</span> Person &amp;p) &#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Person拷贝构造函数&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125;<br>&#125;;<br><span class="hljs-type">void</span> <span class="hljs-title function_">test01</span><span class="hljs-params">()</span> &#123;<br>    Person <span class="hljs-title function_">p1</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span>;<br>    Person <span class="hljs-title function_">p2</span><span class="hljs-params">(p1)</span>;<br>&#125;<br><span class="hljs-comment">// 值传递的方式给参数传值</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">doWork</span><span class="hljs-params">(Person p)</span> &#123;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">test02</span><span class="hljs-params">()</span> &#123;<br>    Person p;<br>    <span class="hljs-comment">//值传递，拷贝一个副本过去</span><br>    doWork(p);<br>&#125;<br><span class="hljs-comment">//值方式返回局部对象</span><br><span class="hljs-comment">// 局部对象在函数执行完之后会自动释放</span><br>Person <span class="hljs-title function_">doWork2</span><span class="hljs-params">()</span> &#123;<br>    Person p1;<br>    <span class="hljs-comment">// 返回的时候 会根据p1 拷贝一个p返回</span><br>    <span class="hljs-keyword">return</span> p1;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//    test01();</span><br>    test02();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="构造函数的调用原则"><a href="#构造函数的调用原则" class="headerlink" title="构造函数的调用原则"></a>构造函数的调用原则</h4><ul><li>自定义有参函数，编译器提供拷贝构造函数，不提供无参。</li><li>自定义拷贝函数，编译器啥都不干</li><li>自己摆烂，编译器提供默认和拷贝构造函数</li></ul><h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h3><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><p>​简单的拷贝赋值。</p><p>​使用编译器提供的拷贝操作，会做浅拷贝工作。</p><p>​<strong>浅拷贝带来的问题是：内存的重复释放</strong> </p><p>​这个问题要用深拷贝来解决。</p><p>![屏幕快照 2022-04-07 下午20.50.59 下午](屏幕快照 2022-04-07 下午20.50.59 下午.png)</p><h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><ol><li>清空原有的东西</li><li>分配一个和蓝本一样大的空间</li><li>赋值</li></ol><p>**拷贝构造函数的最开始，一定要检测自我赋值!!**虽然看起来，不会进行自我赋值的操作，但是会在我们看不到的地方发生。</p><p>不进行监测自我赋值的话，会出现严重的错误。如果没有自我赋值检测，左右相同的时候，释放左边的内容，其实也是释放右边的内存。那么后面的操作就没办法执行了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs CPP">String&amp; String::<span class="hljs-keyword">operator</span>= (<span class="hljs-type">const</span> String&amp; str)&#123;<br><span class="hljs-comment">//检测自我赋值</span><br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span> == &amp;str)  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br><span class="hljs-keyword">delete</span>[] m_data;<br>  m_data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(str.m_data)+<span class="hljs-number">1</span>];<br>  <span class="hljs-built_in">strcpy</span>(m_data,str.m_data);<br>  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="类对象作为类成员"><a href="#类对象作为类成员" class="headerlink" title="类对象作为类成员"></a>类对象作为类成员</h3><p>C++类中的成员可以是另一个类的对象，<strong>称其为对象成员</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Class A;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>&#123;<br>A a;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>构造的顺序：</p><p>会先调用成员类的构造函数，在调用自身的构造函数。</p></li><li><p>析构的顺序：</p><p>先析构自身，再析构成员。</p></li></ul><h2 id="C-对象模型和this指针"><a href="#C-对象模型和this指针" class="headerlink" title="C++对象模型和this指针"></a>C++对象模型和this指针</h2><h3 id="静态-static"><a href="#静态-static" class="headerlink" title="静态 static"></a>静态 static</h3><p><code>static</code>在成员和函数前面加。</p><ul><li>静态成员变量<ul><li>所有对象共享同一份数据。不属于某个对象，属于这个类本身！（类似java）<ul><li>通过对象进行访问</li><li>通过类名进行访问 <code>Person::m_A</code></li></ul></li><li>在编译阶段分配内存</li><li>类内声明，<strong>类外初始化</strong></li><li>访问权限：必须是pubilc。private、protect权限不行</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">Class Person&#123;<br>public:<br>  类内声明<br>  <span class="hljs-type">static</span> <span class="hljs-type">int</span> m_A;<br>&#125;<br><span class="hljs-comment">//初始化</span><br><span class="hljs-type">int</span> Person::m_A = <span class="hljs-number">100</span>;<br></code></pre></td></tr></table></figure><ul><li>静态成员函数<ul><li>所有对象共享一个函数：和👆同有两种访问方式</li><li>静态成员函数只能访问静态成员变量，可以在静态函数中声明静态变量。</li><li>有访问权限！</li></ul></li></ul><p>在函数内部声明static变量，这个变量的生存周期和程序一样长，但是在函数外不能访问。</p><h3 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">static</span> A&amp; <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>;<br><span class="hljs-built_in">setup</span>();<br><span class="hljs-keyword">private</span>: <br><span class="hljs-built_in">A</span>();<br>&#125;<br><span class="hljs-function">A&amp; <span class="hljs-title">A::getInstance</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">static</span> A a;<br><span class="hljs-keyword">return</span> a ;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="静态成员变量和静态成员函数是分开储存"><a href="#静态成员变量和静态成员函数是分开储存" class="headerlink" title="静态成员变量和静态成员函数是分开储存"></a>静态成员变量和静态成员函数是分开储存</h3><h4 id="空对象"><a href="#空对象" class="headerlink" title="空对象"></a>空对象</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Class Person&#123;&#125;<br>Person p;<br></code></pre></td></tr></table></figure><p>空对象占有的内存空间是1，编译器会给空对象分配一个独一无二的内存空间，是为了区分其所占的内存位置。</p><p>当里面有对象的时候，就会根据对象的大小去分配内存</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Class Person&#123;<br><span class="hljs-type">int</span> m_A; <span class="hljs-comment">//非静态成员变量是属于p对象的</span><br>&#125;<br>Person p;<br><span class="hljs-comment">//此时就占用4字节了 根据int给分配的</span><br></code></pre></td></tr></table></figure><p>在类里添加一个静态成员变量，会发现对象的大小不会因此受影响。所以可以知道静态不属于对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Class Person&#123;<br><span class="hljs-type">int</span> m_A; <span class="hljs-comment">//非静态成员变量是属于p对象的</span><br>  <span class="hljs-type">static</span> <span class="hljs-type">int</span> m_B;<br>&#125;<br>Person p;<br><span class="hljs-comment">//此时还占用4字节了 因为static不属于p对象</span><br></code></pre></td></tr></table></figure><p><strong>函数同理</strong>！</p><h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h3><p>在类中的非静态成员变量和函数会被多个对象使用。那么怎么区分是哪个对象调用了自己呢？<code>this指针</code></p><ul><li>this指针指向被调用的成员函数所属的对象。</li><li>this指针隐含每一个非静态成员函数内的一种指针。</li><li>this不用定义，直接使用。</li></ul><p>this 是一个指针常量，不能修改所存放的地址。</p><h4 id="通过C的角度"><a href="#通过C的角度" class="headerlink" title="通过C的角度"></a>通过C的角度</h4><p><code>c1.real()</code>相当于<code>complex::real(&amp;c1)</code>.</p><p>谁调用，就传谁的引用。这样this指针就指向对象了。</p><h4 id="this指针的用途"><a href="#this指针的用途" class="headerlink" title="this指针的用途"></a>this指针的用途</h4><ul><li>当形参和成员变量同名时，可用this指针来区分。—-》解决名称冲突</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">Class Person&#123;<br>public:<br> <span class="hljs-comment">//int m_Age;</span><br> <span class="hljs-type">int</span> age;<br> Person(<span class="hljs-type">int</span> age)&#123;<br> this-&gt;age = age;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在类的非静态成员函数中返回对象本身，可用return *this     —–〉返回对象本身用*this<ul><li>声明函数时，返回值类型是对象的引用！<ul><li>如果返回类型是 对象 ：意味着第一次调用后返回的值是一个拷贝的值。</li></ul></li></ul></li></ul><h3 id="空指针可以访问静态成员函数"><a href="#空指针可以访问静态成员函数" class="headerlink" title="空指针可以访问静态成员函数"></a>空指针可以访问静态成员函数</h3><h3 id="const修饰成员函数"><a href="#const修饰成员函数" class="headerlink" title="const修饰成员函数"></a>const修饰成员函数</h3><h4 id="常函数"><a href="#常函数" class="headerlink" title="常函数"></a>常函数</h4><ul><li>成员函数加const后就称作常函数</li><li>常函数内不可修改成员属性</li><li>成员属性声明时加 <code>mutable</code>后，就可以更改了</li></ul><p><code>this相当于Person * const this;</code>能改this指向的值，但是不能改this的指向</p><p>要是<strong>连指向</strong>都不想改，相当于定义一个 <code>Person const * const this ; </code>在声明常函数的时候，就在函数声明后加一个const，用于修饰左边的这个函数对应的this指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Class Person&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showPerson</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">  </span>&#123;<br>    m_A = <span class="hljs-number">100</span>;<br>    <span class="hljs-comment">//相当于 this-&gt;m_A=100;</span><br>    <span class="hljs-comment">//this指针的本质是指针常量，指针的指向是不可以修改的。</span><br>    <span class="hljs-comment">// this = NULL 是不允许的，不能改变this指针的指向</span><br>    m_B = <span class="hljs-number">100</span>；<br>  &#125;<br>  <span class="hljs-type">int</span> m_A;<br>  <span class="hljs-keyword">mutable</span> <span class="hljs-type">int</span> m_B；<span class="hljs-comment">//这个就可以在常函数中修改了</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="常对象"><a href="#常对象" class="headerlink" title="常对象"></a>常对象</h4><p><code>const Person p</code>是不能改常对象中的 <code>非mutable成员变量的</code>。</p><h5 id="常对象-只能-调用常函数："><a href="#常对象-只能-调用常函数：" class="headerlink" title="常对象 只能 调用常函数："></a>常对象 <strong>只能</strong> 调用常函数：</h5><p>​常对象不许修改普通成员函数 –&gt;但是普通成员变量可以被普通成员函数修改–&gt;常函数不能改普通成员变量</p><h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><p><strong>在程序里有些私有属性，想被类外的特殊函数和类被访问。</strong></p><p><code>friend</code> 三种实现</p><ul><li>全局函数做友元</li><li>类做友元</li><li>成员函数做友元</li></ul><p>成员函数做友元</p><p><code>  friend void GoodGay::f_Visit();</code></p><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p><strong>给运算符重新定义，赋予另一种功能，以适应不同的数据类型。</strong></p><h3 id="加号运算符重载"><a href="#加号运算符重载" class="headerlink" title="加号运算符重载"></a>加号运算符重载</h3><p><code>operator+</code> 用于自定义数据类型相加！</p><ul><li>通过成员函数重载</li><li>通过全局函数重载</li></ul><p>这里一定要注意，返回值是reference还是value，如果返回值是在函数里被创建的，那一定返回的是value。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//通过成员函数重载</span><br>Person::Person <span class="hljs-keyword">operator</span>+ (Person &amp;p)&#123;<br>  Person temp;<br>  temp.m_A = <span class="hljs-keyword">this</span>-&gt;m_A+p.m_A;<br>  <span class="hljs-keyword">return</span> temp;<br>&#125;<br>Person p3 = p1.<span class="hljs-keyword">operator</span>+(p2);<br><span class="hljs-comment">// 可以简化为</span><br>Person p3 = p1+p2;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 全局函数重载</span><br>Person <span class="hljs-keyword">operator</span>+ (Person &amp;p1，Person &amp;p2)&#123;<br>  Person temp;<br>  temp.m_A = p1.m_A+p2.m_A;<br>  <span class="hljs-keyword">return</span> temp;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="左移运算符重载"><a href="#左移运算符重载" class="headerlink" title="左移运算符重载"></a>左移运算符重载</h3><p><code>operator&lt;&lt;</code> 用与自定义输出类型！</p><blockquote><p><strong>通常不用成员函数实现&lt;&lt;，因为无法实现cout在左侧</strong></p></blockquote><h4 id="cout"><a href="#cout" class="headerlink" title="cout"></a>cout</h4><p>cout是标准输出流 <code>ostream</code> 对象，该对象全局只能有一个，所以用的时候要用引用！</p><h4 id="返回值是void时："><a href="#返回值是void时：" class="headerlink" title="返回值是void时："></a>返回值是void时：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//通常不用成员函数实现&lt;&lt;，因为无法实现cout在左侧</span><br><span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;cout,Person p)&#123;<br>  cout&lt;&lt;<span class="hljs-string">&quot;m_A=&quot;</span>&lt;&lt;p.m_A&lt;&lt;p.m_B;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-comment">//可以实现！</span><br>  cout&lt;&lt;p;<br>  <span class="hljs-comment">// 不能实现</span><br>  cout&lt;&lt;p&lt;&lt;endl;<br>  <span class="hljs-comment">//endl会报错，因为这里是链式编程，返会的void没办法进行</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="返回值是-ostream-amp-时"><a href="#返回值是-ostream-amp-时" class="headerlink" title="返回值是 ostream&amp; 时"></a>返回值是 <code>ostream</code>&amp; 时</h4><blockquote><p>通常成员变量是私有属性，全局函数重载的时候，可以用到 <strong>友元</strong> 的技术！</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//通常不用成员函数实现&lt;&lt;，因为无法实现cout在左侧</span><br>ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;zidingyi,Person p)&#123;<br>  zidingyi&lt;&lt;<span class="hljs-string">&quot;m_A=&quot;</span>&lt;&lt;p.m_A&lt;&lt;p.m_B;<br>  <span class="hljs-keyword">return</span> zidingyi;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>  zidingyi&lt;&lt;p&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="递增、递减-运算符重载"><a href="#递增、递减-运算符重载" class="headerlink" title="递增、递减 运算符重载"></a>递增、递减 运算符重载</h3><h4 id="前置、后置递增"><a href="#前置、后置递增" class="headerlink" title="前置、后置递增"></a>前置、后置递增</h4><p><code>++a</code>先递增，再使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyInt</span>&#123;<br>pubilc:<br>  <span class="hljs-type">int</span> m_Num=<span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// 如果返回值是MyInt，就没有办法进行累计的++ </span><br>  MyInt&amp; <span class="hljs-keyword">operator</span>++()&#123;<br>    m_Num++;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>  &#125;<br>&#125;<br>MyInt myInt;<br>myInt++;<br>(myInt++)++;<br></code></pre></td></tr></table></figure><p><code>a++</code>先使用，变量再递增</p><ul><li>返回值类型是 值<ul><li>载后置++的时候，要加一个占位参数int <code>MyInt operator++(int)</code></li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyInt</span>&#123;<br>pubilc:<br>  <span class="hljs-type">int</span> m_Num=<span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// 如果返回值是MyInt，就没有办法进行累计的++ </span><br>  MyInt&amp; <span class="hljs-keyword">operator</span>++()&#123;<br>    m_Num++;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>  &#125;<br>  <span class="hljs-comment">// 重载后置++的时候，要加一个占位参数，来和另一个用法进行区分</span><br>  <span class="hljs-comment">// 返回值类型是 值 。不然返回的是一个局部变量的地址</span><br>  MyInt <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>)&#123;<br>    <span class="hljs-comment">//先记录当前结果</span><br>    MyInt temp = *<span class="hljs-keyword">this</span>;<br>    <span class="hljs-comment">//后递增</span><br>    m_Num++;<br>    <span class="hljs-comment">//将记录的结果进行返回</span><br>    <span class="hljs-keyword">return</span> temp;<br>  &#125;<br>&#125;<br>MyInt myInt;<br>++myInt;<br>++(++myInt);<br>myInt++;<br></code></pre></td></tr></table></figure><h3 id="赋值运算符重载"><a href="#赋值运算符重载" class="headerlink" title="赋值运算符重载"></a>赋值运算符重载</h3><blockquote><p>赋值运算符operator&#x3D;，对属性进行值拷贝。所以会引发深浅拷贝的问题！</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> *m_Age;<br>Person&amp; <span class="hljs-keyword">operator</span>=(Person&amp;p)&#123;<br><span class="hljs-comment">//先判断堆区有无数据，先释放干净再拷贝</span><br>  <span class="hljs-keyword">if</span>(m_Age !=<span class="hljs-literal">NULL</span>)<br>  &#123;<br>    <span class="hljs-keyword">delete</span> m_Age;<br>    m_Age = <span class="hljs-literal">NULL</span>;<br>  &#125;<br>  <span class="hljs-comment">// 深拷贝</span><br>  m_Age=<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span> (*p.m_Age);<br>  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="关系运算符重载"><a href="#关系运算符重载" class="headerlink" title="关系运算符重载"></a>关系运算符重载</h3><blockquote><p>可以让自定义的数据对象进行比较的操作</p></blockquote><h3 id="函数调用运算符重载"><a href="#函数调用运算符重载" class="headerlink" title="函数调用运算符重载"></a>函数调用运算符重载</h3><blockquote><p>（）的重载，又叫仿函数！</p></blockquote><p>匿名函数对象： <code>类型后加()</code></p><p>​执行完立刻释放！Myadd()(100,100);</p><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CPP</span> : pubilc BasicPage&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unique</span><span class="hljs-params">()</span></span>&#123;<br>cout&lt;&lt;“这是cpp<span class="hljs-string">&quot;&lt;&lt;endl;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure><ul><li>子类：称为派生类</li><li>父类：称为基类</li></ul><p>派生类：包含了基类的内容，和自己独特的内容</p><h2 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h2><ul><li>公共继承</li><li>保护继承</li><li>私有继承</li></ul><p><code>private</code>永远不会被继承到，剩下的由继承方式的级别是最高等级的权限。</p><p>高等级的权限要退化到继承方式的权限。</p><h2 id="继承中的对象模型"><a href="#继承中的对象模型" class="headerlink" title="继承中的对象模型"></a>继承中的对象模型</h2><blockquote><p>在父类中所有的非静态的成员属性都会被子类继承下去，私有成员是被编译器隐藏了的。所以是子类访问不到的。</p></blockquote><h2 id="继承中的构造和析构的顺序"><a href="#继承中的构造和析构的顺序" class="headerlink" title="继承中的构造和析构的顺序"></a>继承中的构造和析构的顺序</h2><ol><li>父类的构造</li><li>子类的构造</li><li>子类的析构</li><li>父类的析构</li></ol><h2 id="继承中同名成员的处理方式"><a href="#继承中同名成员的处理方式" class="headerlink" title="继承中同名成员的处理方式"></a>继承中同名成员的处理方式</h2><blockquote><p>子类和父类中出现了同名的成员，怎么通过子类对象，访问到子类和父类中的同名数据呢？</p></blockquote><p><code>子类对象.父类名 :: 同名成员/函数</code></p><p>如果不加作用域，都是优先调用子类的。</p><p>如果子类中出现了和父类的同名成员函数，子类的同名成员函数会隐藏掉父类的所有同名函数。</p><p>如果想访问到父类中被隐藏的父类函数，要加作用域。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> m_a;<br>    <span class="hljs-built_in">Base</span>()&#123;<br>        m_a = <span class="hljs-number">100</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;func1&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;func1&quot;</span>&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span>  <span class="hljs-title class_">Son</span> : <span class="hljs-keyword">public</span> Base&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> m_a;<br>    <span class="hljs-built_in">Son</span>()&#123;<br>        m_a=<span class="hljs-number">200</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;func1&quot;</span>&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Son s;<br>    cout&lt;&lt;s.m_a&lt;&lt;endl;<br>    cout&lt;&lt;s.Base::m_a&lt;&lt;endl;<br>    <span class="hljs-comment">// 调用函数</span><br>    s.<span class="hljs-built_in">func1</span>();<br>    <span class="hljs-comment">// 同名函数</span><br>    s.<span class="hljs-built_in">func</span>(); <span class="hljs-comment">// 会调用子类的</span><br>    <span class="hljs-comment">//调用父类的同名函数</span><br>    s.Base::<span class="hljs-built_in">func</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="同名静态成员处理方法"><a href="#同名静态成员处理方法" class="headerlink" title="同名静态成员处理方法"></a>同名静态成员处理方法</h3><p>继承中同名的静态成员在子类对象上进行访问的方法，基本上是一样的。</p><p>通过类名访问：<code>Son::Father::alive()</code></p><h2 id="多继承语法"><a href="#多继承语法" class="headerlink" title="多继承语法"></a>多继承语法</h2><blockquote><p>Cpp允许一个类继承多个类</p></blockquote><p><code>class子类:继承方式 父类1,继承方式 父类2,...</code></p><p>多继承中可能会引发父类同名函数的出现，需要用作用域区分。</p><p>子类进行多继承的时候，会把所有父类的成员变量都继承过来。</p><ul><li>如果父类中出现了同名的成员，需要加作用域进行区分！</li></ul><blockquote><p>在开发中，并不建议多继承的方式！</p></blockquote><h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>派生类想要重写基类中的函数，需要在基类中标明 <code>virtual</code>的关键词，并在派生类要重写的函数括号后面标明 <code>override</code>（C++11引入）</p><p>在一个基类指针指向派生类的对象的时候，该指针调用的函数就被正确的指定为派生类的函数了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Entity</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::string <span class="hljs-title">get_name</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;entity&quot;</span>; &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Player</span> : <span class="hljs-keyword">public</span> Entity<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">std::string <span class="hljs-title">get_name</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-keyword">return</span> m_name; &#125;<br><span class="hljs-keyword">private</span>:<br>    std::string m_name = <span class="hljs-string">&quot;Player&quot;</span>;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Entity *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Player</span>();<br>    std::cout &lt;&lt; p-&gt;<span class="hljs-built_in">get_name</span>() &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="代价"><a href="#代价" class="headerlink" title="代价"></a>代价</h3><ol><li>额外的内存，来保存虚函数表</li><li>额外的时间，需要便利虚函数表</li></ol><h2 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h2><p> 就是接口奥，继承的子类必须实现纯虚函数！！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Entity</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::string <span class="hljs-title">get_name</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h2><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul><li>两个派生类继承同一个基类</li><li>又有某个类继承了两个派生类</li><li>这种继承被称作菱形继承或者钻石继承</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> m_age = <span class="hljs-number">10</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sheep</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> Animal &#123;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tuo</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> Animal &#123;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cnm</span> : <span class="hljs-keyword">public</span> Tuo, <span class="hljs-keyword">public</span> Sheep &#123;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    Cnm c1;<br>    c1.Sheep::m_age =<span class="hljs-number">18</span>;<br>    c1.Tuo::m_age =<span class="hljs-number">28</span>;<br>    cout&lt;&lt;c1.m_age&lt;&lt;endl;<br>    <span class="hljs-comment">// 这样是在浪费资源</span><br>    <span class="hljs-comment">// 利用虚继承可以解决菱形继承的问题</span><br>    <span class="hljs-comment">// 继承之前加上关键字 virtual，重复的数据都会被归一为一个！</span><br>    <span class="hljs-comment">// 最大的类被称作：虚基类</span><br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h4><p>这样是在浪费资源，利用虚继承可以解决菱形继承的问题<br>继承之前加上关键字 <code>virtual</code>，重复的数据都会被归一为一个！<br>最大的类被称作：虚基类</p><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol><li><p>静态</p><p>函数名、运算符重载</p></li><li><p>动态</p><p>派生类和虚函数实现运行时多态</p></li></ol><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul><li>静态多态：函数地址<strong>早绑定</strong>——<strong>编译</strong>阶段确定函数地址</li><li>动态多态：函数地址<strong>晚绑定</strong>——<strong>运行</strong>阶段确定函数地址<ul><li><p>在继承关系中</p></li><li><p>子类重写父类的虚函数，子类的virtual前缀可以不写</p><ul><li>重写：只有函数体不一样，其他的都一样</li></ul></li><li><p><code>virtual</code>关键词，可以让这个函数变成动态多态</p></li><li><p>父类的指针或者引用指向子类对象</p></li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;动物在说话&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> : <span class="hljs-keyword">public</span> Animal &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// 子类重写父类中的虚函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;小猫在说话&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><span class="hljs-comment">// 不加virtual时是地址早绑定，在编译阶段就确定了函数的地址</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSpeak</span><span class="hljs-params">(Animal&amp; animal)</span></span>&#123; <span class="hljs-comment">//父类的引用指向子类对象 Animal&amp; animal = cat</span><br>    animal.<span class="hljs-built_in">speak</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    Cat cat;<br>    <span class="hljs-comment">// 此时的本意是想让猫咪去说话！但是此时是动物在说话</span><br>    <span class="hljs-built_in">doSpeak</span>(cat);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>&#125;<br></code></pre></td></tr></table></figure><img src="屏幕快照 2022-04-15 下午20.40.17 下午.png" alt="屏幕快照 2022-04-15 下午20.40.17 下午" style="zoom:50%;" /><img src="屏幕快照 2022-04-15 下午20.45.19 下午.png" alt="屏幕快照 2022-04-15 下午20.45.19 下午" style="zoom:50%;" /><p>此时如果访问animal.speak()的时候，会走猫的说话！</p><h3 id="多态的实例"><a href="#多态的实例" class="headerlink" title="多态的实例"></a>多态的实例</h3><h4 id="计算器类"><a href="#计算器类" class="headerlink" title="计算器类"></a>计算器类</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractCalculator</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">getResult</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br>    <span class="hljs-type">int</span> m_num1;<br>    <span class="hljs-type">int</span> m_num2;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Add</span> : <span class="hljs-keyword">public</span> AbstractCalculator&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getResult</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> m_num1+m_num2;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>    AbstractCalculator *abc = <span class="hljs-keyword">new</span> Add;<br>    abc-&gt;m_num1=<span class="hljs-number">1</span>;<br>    abc-&gt;m_num2=<span class="hljs-number">1</span>;<br>    cout&lt;&lt;abc-&gt;<span class="hljs-built_in">getResult</span>()&lt;&lt;endl;<br>    <span class="hljs-keyword">delete</span> abc;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>多态的好处：</p><ul><li>组织结构清晰</li><li>可读性强</li><li>代码的维护性高：开放原则 ：对扩展进行开放，对修改进行封闭。</li></ul><h2 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h2><p>多态中，通常父类的虚函数的实现是毫无意义的，主要都是子类重写的内容。因此可以将虚函数改为<strong>纯虚函数</strong>。</p><p><code>virtual 返回值类型 函数名 (参数列表) = 0</code></p><p>当类中有了纯虚函数时，这个类也被称为<strong>抽象类。</strong></p><h4 id="抽象类的特点（java中的接口？）"><a href="#抽象类的特点（java中的接口？）" class="headerlink" title="抽象类的特点（java中的接口？）"></a>抽象类的特点（java中的接口？）</h4><ul><li>无法实例化对象</li><li>子类必须重写抽象类中的纯虚函数，否则也属于抽象类。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">// 抽象类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 纯虚函数！</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span>:<span class="hljs-keyword">public</span> Base&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-number">1</span>&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Base *base = <span class="hljs-keyword">new</span> Son;<br>    base-&gt;<span class="hljs-built_in">func</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractDrinking</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">boil</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">brew</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">pourInCup</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">putSomething</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">makeDrink</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-built_in">boil</span>();<br>        <span class="hljs-built_in">brew</span>();<br>        <span class="hljs-built_in">pourInCup</span>();<br>        <span class="hljs-built_in">putSomething</span>();<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Coffee</span>:<span class="hljs-keyword">public</span> AbstractDrinking&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">boil</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;煮水&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">brew</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;倒咖啡&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pourInCup</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;倒杯子里&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">putSomething</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;放niu奶，milk&quot;</span>&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tea</span>:<span class="hljs-keyword">public</span> AbstractDrinking&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">boil</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;煮水&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">brew</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;倒茶叶&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pourInCup</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;倒小杯儿里&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">putSomething</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;放柠檬，ninmen，怎么这么酸啊啊啊&quot;</span>&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doWork</span><span class="hljs-params">(AbstractDrinking* abs)</span></span>&#123;<br>    abs-&gt;<span class="hljs-built_in">makeDrink</span>();<br>  <span class="hljs-comment">// 释放内存！</span><br>    <span class="hljs-keyword">delete</span> abs;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Coffee* coffee = <span class="hljs-keyword">new</span> Coffee;<br>    <span class="hljs-built_in">doWork</span>(coffee);<br>    Tea* tea = <span class="hljs-keyword">new</span> Tea;<br>    <span class="hljs-built_in">doWork</span>(tea);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="虚析构和纯虚析构"><a href="#虚析构和纯虚析构" class="headerlink" title="虚析构和纯虚析构"></a>虚析构和纯虚析构</h3><blockquote><p>多态使用时，如果子类中有属性开辟到堆区，那么父指针在释放的时候是没有办法调用到子类的析构代码的。 会出现内存泄漏！</p></blockquote><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>将父类中的析构函数改为虚析构 或者 纯虚析构。</p><h4 id="共性"><a href="#共性" class="headerlink" title="共性"></a>共性</h4><ul><li>可以解决父类指针释放子类的问题</li><li>都要有具体的实现函数</li></ul><h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><p><strong>如果是纯虚析构，该类就变为抽象类，无法实例化对象！</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br>    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> : <span class="hljs-keyword">public</span> Animal &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Cat</span>(string name) &#123;<br>       m_name =  <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(name);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; *m_name&lt;&lt; <span class="hljs-string">&quot;黑子说话！&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-comment">// 利用虚析构可以解决父类指针释放子类对象不干净的问题</span><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Cat</span>()&#123;<br>        <span class="hljs-keyword">if</span> (m_name!=<span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-keyword">delete</span> m_name;<br>            m_name = <span class="hljs-literal">NULL</span>;<br>        &#125;<br>    &#125;<br><br>    string *m_name;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>    Animal *animal = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Cat</span>(<span class="hljs-string">&quot;猪鼻&quot;</span>);<br>    animal-&gt;<span class="hljs-built_in">speak</span>();<br>    <span class="hljs-keyword">delete</span> animal;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>纯虚析构： <strong>既要有声明，也要有实现！</strong></p><p><code>virtual ~Animal()=0;</code></p><p>这个纯虚析构函数要有一个函数的具体实现！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br>Animal::~<span class="hljs-built_in">Animal</span>()&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;纯虚析构函数&quot;</span>&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用场景</strong>：</p><ul><li>多态<ul><li>子类中的属性开辟到了堆区（此时父类的析构函数不能调用子类的析构函数，所以要将父类的析构函数变为虚析构，来调子类的析构！）</li></ul></li></ul><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="rand-，random-的区别"><a href="#rand-，random-的区别" class="headerlink" title="rand()，random()的区别"></a>rand()，random()的区别</h2><h3 id="rand（）"><a href="#rand（）" class="headerlink" title="rand（）"></a>rand（）</h3><p>要使用srand()函数设置随机数种子。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">srand</span>((<span class="hljs-type">int</span>)<span class="hljs-built_in">time</span>(<span class="hljs-number">0</span>));  <span class="hljs-comment">// 产生随机种子  把0换成NULL也行</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<span class="hljs-comment">//产生十次</span><br>    &#123;<br>        cout &lt;&lt; <span class="hljs-built_in">rand</span>()%<span class="hljs-number">100</span>&lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<span class="hljs-comment">//范围在[0,100)的随机数</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>当类对象离开作用域的时候，会自动调用析构函数。可以用到的应用：智能指针、计时器和作用域锁。</p><hr><h2 id="堆、栈和内存管理"><a href="#堆、栈和内存管理" class="headerlink" title="堆、栈和内存管理"></a>堆、栈和内存管理</h2><p>c++执行程序时，会将内存分为4个区域</p><ul><li>代码区：存放函数体的二进制代码，由操作系统进行管理</li><li>全局区：存放全局变量和静态变量以及常量</li><li>栈区：由编译器自动分配释放。存放函数的参数值和局部变量</li><li>堆区：由程序员分配和释放，若不人为释放，程序结束时由系统回收。</li></ul><p><strong>不同区域存放的数据，有不同生命周期。</strong></p><h3 id="程序运行前"><a href="#程序运行前" class="headerlink" title="程序运行前"></a>程序运行前</h3><p>编译以后，exe可执行文件在<strong>未执行</strong>的时候，分为两个区域。</p><ul><li>代码区<ul><li>共享</li><li>只读</li><li>cpu执行的机器指令</li></ul></li><li>全局区<ul><li>全局变量和静态变量存放在此</li><li>常量区：字符串常量和const修饰的全局变量<ul><li>const修饰的局部变量<strong>不在全局区</strong></li></ul></li><li>程序结束后，由系统释放</li></ul></li></ul><h3 id="程序运行后"><a href="#程序运行后" class="headerlink" title="程序运行后"></a>程序运行后</h3><ul><li><p>栈区：</p><ul><li><p>由编译器自动分配释放，存放函数的参数值、局部变量、形参。</p></li><li><p><strong>注意：</strong>不要返回局部变量的地址，栈区开辟的数据由编译器自动释放。（函数里不要返回函数里定义的变量的地址）</p></li><li><p>堆区：</p><p>程序员进行分配释放、使用new在堆区开辟内存。 <strong>这里也是内存泄漏的原发地</strong></p></li></ul></li></ul><h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><p>存在于某个作用域内的一块内存空间，当调用函数的时候，函数本身就会形成一个stack用来放置他所接受的参数、local object、返回地址。离开作用域的时候，就自动消失了。</p><h3 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h3><p>由操作系统提供的一块global内存空间。这块空间由new操作符，动态的取得，<strong>手动释放！</strong></p><p><strong>离开作用域后，那块申请的内存空间也不会消失！</strong>但是，离开作用域后，新建的指针就不可见了，就发生了内存泄漏，没机会delete。</p><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p>其生命在作用域结束后，也仍然存在！直到程序结束。</p><h3 id="全局对象"><a href="#全局对象" class="headerlink" title="全局对象"></a>全局对象</h3><p>任何大括号之外的，全局对象。生命在程序结束后才消失。</p><hr><h2 id="new操作符"><a href="#new操作符" class="headerlink" title="new操作符"></a>new操作符</h2><p><a href="https://blog.csdn.net/hazir/article/details/21413833?spm=1001.2101.3001.6650.9&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-9.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-9.pc_relevant_default&utm_relevant_index=13">https://blog.csdn.net/hazir/article/details/21413833?spm=1001.2101.3001.6650.9&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-9.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-9.pc_relevant_default&amp;utm_relevant_index=13</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">10</span>);<br><span class="hljs-keyword">delete</span> p;<br><span class="hljs-type">int</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>];<br><span class="hljs-keyword">delete</span>[] p;<br></code></pre></td></tr></table></figure><p><strong>New[] 一定要搭配delete[]</strong>, 编译器才知道，delete的是一个数组，delete会调用数组长度次。不然的话，只调用一次，剩下的内存就泄漏了。</p><h3 id="new发生了什么？"><a href="#new发生了什么？" class="headerlink" title="new发生了什么？"></a>new发生了什么？</h3><ol><li>先分配内存，内部调用了C的malloc() </li><li>将指针转型</li><li>通过2得到的指针调用构造函数</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-type">void</span>* mem = <span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(<span class="hljs-built_in">sizeof</span>(Complex));<br>pc = <span class="hljs-built_in">static_cast</span>&lt;Complex*&gt;(mem);<br>pc-&gt;Complex::<span class="hljs-built_in">Complex</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>); <span class="hljs-comment">// pc调用了构造函数，那么构造函数中的this就是pc  谁调用就是谁</span><br></code></pre></td></tr></table></figure><h3 id="什么时候在堆上分配内存"><a href="#什么时候在堆上分配内存" class="headerlink" title="什么时候在堆上分配内存"></a>什么时候在堆上分配内存</h3><ul><li>类的对象比较大</li><li>想要显示的控制对象的生命周期</li></ul><hr><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ol><li>引用必须初始化。</li><li>引用初始化后不能再改变他里面的地址。</li><li>赋值可以。</li></ol><h3 id="引用作为函数的返回值"><a href="#引用作为函数的返回值" class="headerlink" title="引用作为函数的返回值"></a>引用作为函数的返回值</h3><p><strong>不要返回局部变量的引用</strong></p><h4 id="传递者不需要知道接受者是以引用的形式接受"><a href="#传递者不需要知道接受者是以引用的形式接受" class="headerlink" title="传递者不需要知道接受者是以引用的形式接受"></a>传递者不需要知道接受者是以引用的形式接受</h4><p>意思是，函数的返回值是引用，但是我在函数中return一个value也是可以的。如果设计者足够聪明，就会用reference的形式进行接受，速度足够快。 </p><p>例子代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">inline</span> complex&amp; __doapl(complex&amp; ths)&#123;<br><span class="hljs-keyword">return</span> *ths;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="explicit和隐式类型转换"><a href="#explicit和隐式类型转换" class="headerlink" title="explicit和隐式类型转换"></a>explicit和隐式类型转换</h2><p>某个类有一些构造函数，我们可以直接给类成员赋值 <code>=</code>  字面量。这样看上去很不合理，但是C++认为这个字面量可以触发该类的构造函数，所以会隐式的调用构造函数。但是隐式转换只允许转换一次，也就是说 <code>“this is a string!&quot;</code>这个字符数组不会被转换为一个含有 <code>string </code>构造函数的类的，因为这样要经过两次转换。先从 <code>char*[]</code> 转换为 <code> string</code> 在转换为 <code>类类型</code>。</p><h3 id="explicit关键词"><a href="#explicit关键词" class="headerlink" title="explicit关键词"></a>explicit关键词</h3><p><code>explicit</code>关键词放在构造函数的前面，该关键词限制了对象必须<strong>显示调用构造函数</strong>来生成类对象。</p><p>所以就不会有上面的那种情况了。</p><hr><h2 id="函数的默认参数"><a href="#函数的默认参数" class="headerlink" title="函数的默认参数"></a>函数的默认参数</h2><p>第一个默认参数的后面必须都有默认值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fun</span> <span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b=<span class="hljs-number">10</span>, <span class="hljs-type">int</span> c=<span class="hljs-number">100</span>)</span></span>&#123;<br>xxxxxxx<br>&#125;<br></code></pre></td></tr></table></figure><p>声明和实现，只能有一个有默认参数！</p><hr><h2 id="函数的占位参数"><a href="#函数的占位参数" class="headerlink" title="函数的占位参数"></a>函数的占位参数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a ,<span class="hljs-type">int</span>)</span></span>&#123;<br>  xxxx;<br>&#125;<br><span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>,<span class="hljs-number">10</span>);<span class="hljs-comment">//这样才能调用，但是目前阶段的占位参数还用不到。</span><br></code></pre></td></tr></table></figure><hr><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><ul><li>同一作用域</li><li>函数名相同</li><li>函数参数<ul><li>类型不同</li><li>个数不同</li><li>顺序不同</li></ul></li></ul><h3 id="函数重载的注意事项"><a href="#函数重载的注意事项" class="headerlink" title="函数重载的注意事项"></a>函数重载的注意事项</h3><h4 id="引用作为重载的条件"><a href="#引用作为重载的条件" class="headerlink" title="引用作为重载的条件"></a>引用作为重载的条件</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;a)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;a)</span></span>;<br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">func</span>(a); <br><span class="hljs-comment">// result: 调用第一行的！</span><br><br><span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>);<br><span class="hljs-comment">// result :调用第二行的！</span><br></code></pre></td></tr></table></figure><h3 id="重载碰到默认参数"><a href="#重载碰到默认参数" class="headerlink" title="重载碰到默认参数"></a>重载碰到默认参数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;a)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b=<span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-type">int</span> a =<span class="hljs-number">10</span>;<br><span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>);<span class="hljs-comment">//会出现错误，有二义性的出现</span><br></code></pre></td></tr></table></figure><hr><h2 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h2><p><a href="https://blog.csdn.net/K346K346/article/details/52065524">https://blog.csdn.net/K346K346/article/details/52065524</a></p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>用来代替C中宏定义的。</p><h3 id="编译器的处理方法"><a href="#编译器的处理方法" class="headerlink" title="编译器的处理方法"></a>编译器的处理方法</h3><p>编译器在编译阶段进行处理，但是编译器有权不去做。通过减少函数调用的相关痕迹，来提升性能。</p><ol><li>将inline函数体复制到调用处</li><li>给inline函数中的局部变量分配内存空间</li></ol><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>在函数的定义处，返回值之前加inline。</p><p>在声明时也最好加上，但是<strong>只在声明时加不好使</strong>！</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li>内联函数在代码处直接展开，减少了参数压栈、栈帧开辟和回收、结果返回等操作，提高运行速度。</li><li>和<strong>宏函数</strong>相比，有安全检查和自动类型转换。宏函数没有这些。</li><li>类内声明且定义的成员函数，自动转为内联函数。<strong>内联函数能访问成员变量，宏函数不行。</strong></li><li>inline运行时可以调试，宏函数不行。</li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li><p>代码膨胀，空间换时间。</p></li><li><p>内联不可控，由编译器决定</p></li><li><p>不能跟随函数库升级而更新。如果f是函数库的一个inline函数，f会直接编译到程序中，如果函数库改变f，则用到f的程序都需要重新编译。</p><p>如果f不是内联的，那么只重新链接就行。</p></li></ol><hr><h2 id="临时对象-temp-object"><a href="#临时对象-temp-object" class="headerlink" title="临时对象 temp object"></a>临时对象 temp object</h2><p>使用方法是 typename();例如，int(1)、complex(real(x),imagine(x));</p><p>临时使用，声明周期到下一行就结束啦。</p><hr><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p>在 <code>&lt;memory&gt;</code>文件中</p><h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><p>优先使用unique，因为它的开销低。当需要共享指针，进行赋值的时候，再考虑使用smart_ptr</p><h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><p>智能指针允许多个指针指向一个目标。使用 <code>make_shared&lt;int&gt;(996)</code>函数进行构造，在进行拷贝和赋值操作时（作为函数返回值），会进行记数操作。记数为0时，就自动释放指针指向的对象。</p><h4 id="空悬指针"><a href="#空悬指针" class="headerlink" title="空悬指针"></a>空悬指针</h4><p>delete一个指针以后，其他地方可能还会保存着这个指针。这个指针现在指向的内容不存在了，属于是空悬指针。</p><p>有一种方法可以避免空悬指针问题，即在指针离开作用域时，将其释放掉。这样就不会出现后面再使用这个指针的状况了。但这个方法只提供了有限的保护。</p><h4 id="不要使用get为另一个智能指针初始化或者赋值、"><a href="#不要使用get为另一个智能指针初始化或者赋值、" class="headerlink" title="不要使用get为另一个智能指针初始化或者赋值、"></a>不要使用get为另一个智能指针初始化或者赋值、</h4><p>因为这样可能会导致智能指针自动释放了内存，出现空悬指针和多次释放。</p><h4 id="reset"><a href="#reset" class="headerlink" title="reset()"></a>reset()</h4><p>reset()函数可以为智能指针重新分配底层的对象，同时重制计数，甚至释放内存。一般和unique混合使用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(!p.<span class="hljs-built_in">unique</span>())&#123;<br>p.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(*p)); <span class="hljs-comment">//不是唯一用户的时候，拷贝一份新的进行操作。</span><br>&#125;<br>*p +=newVal;<br></code></pre></td></tr></table></figure><h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><h2 id="vector中的push-back-和empalce-back"><a href="#vector中的push-back-和empalce-back" class="headerlink" title="vector中的push_back()和empalce_back()"></a>vector中的push_back()和empalce_back()</h2><p><strong>两个的功能都是往vector的尾部插入一个新值。</strong></p><h3 id="emplace-back-和-push-back-的区别，就在于底层实现的机制不同。"><a href="#emplace-back-和-push-back-的区别，就在于底层实现的机制不同。" class="headerlink" title="emplace_back() 和 push_back() 的区别，就在于底层实现的机制不同。"></a>emplace_back() 和 push_back() 的区别，就在于底层实现的机制不同。</h3><p>push_back()向容器尾部添加元素时，首先会创建这个元素，然后再将这个元素拷贝或者移动到容器中（如果是拷贝的话，事后会自行销毁先前创建的这个元素）</p><p>而emplace_back()在实现时，则是直接在容器尾部创建这个元素，省去了拷贝或移动元素的过程。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><h3 id="头文件作用"><a href="#头文件作用" class="headerlink" title="头文件作用"></a>头文件作用</h3><ol><li>定义常量</li><li>引用其他头文件</li><li>声明类</li></ol><h3 id="预编译器和头文件"><a href="#预编译器和头文件" class="headerlink" title="预编译器和头文件"></a>预编译器和头文件</h3><h4 id="为了防止头文件被重复包含"><a href="#为了防止头文件被重复包含" class="headerlink" title="为了防止头文件被重复包含"></a>为了防止头文件被重复包含</h4><p><strong>在头文件中：</strong></p><ul><li>使用#ifndef</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> SALES_DATA_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SALES_DATA_H</span><br>xxx ...<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><ul><li>使用 <code>#pragma once</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++语言</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
